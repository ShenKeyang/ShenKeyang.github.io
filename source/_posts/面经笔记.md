---
title: 面经笔记
date: 2025-09-28 23:12:50
tags:
---


## Redis 有哪些数据结构？
Redis 提供了 5 种基础数据结构，以及基于这些扩展的高级结构：
- 字符串（String）：最基础的键值对，可存储文本、数字（支持自增自减），最大容量 512MB。
- 哈希（Hash）：键值对的集合，适合存储对象（如用户信息），每个哈希可包含最多 2^32-1 个字段。
- 列表（List）：有序字符串集合，支持两端插入 / 删除，底层是双向链表，适合实现消息队列。
- 集合（Set）：无序且唯一的字符串集合，支持交集、并集、差集等运算，适合存储标签、共同好友。
- 有序集合（ZSet/Sorted Set）：带分数（score）的有序集合，分数决定排序，适合排行榜、优先级队列。
此外还有 Bitmap（位图）、HyperLogLog（基数统计）、Geospatial（地理位置） 等扩展结构。

## 内存泄露
C++ 因无自动垃圾回收（GC）机制，内存需手动管理（new 分配内存、delete 释放内存），若分配的内存未正确释放，就会导致内存泄漏 —— 这部分内存无法被系统回收，长期积累会耗尽可用内存，引发程序卡顿、崩溃。常见场景包括：使用 new 动态分配对象 / 数组后未调用 delete/delete[]；函数中动态分配内存后，因提前返回、异常抛出等分支未执行释放逻辑；类的构造函数中分配内存，但析构函数未实现释放（如未重写析构函数或析构函数未调用 delete）；容器（如 vector 存储动态指针）销毁时，仅释放容器本身，未遍历释放指针指向的内存等。    
解决 C++ 内存泄漏需从 “规范管理” 和 “工具检测” 两方面入手。规范上，优先使用智能指针（std::unique_ptr、std::shared_ptr）自动管理内存，其会在对象生命周期结束时自动调用 delete，避免手动释放遗漏；动态数组建议用 std::vector 等容器替代，减少 new[]/delete[] 的直接使用；类中若有动态内存成员，必须在析构函数中实现释放逻辑，且避免浅拷贝。检测上，可借助专业工具（如 Valgrind 的 Memcheck、Visual Studio 的内存诊断工具），这些工具能跟踪内存分配 / 释放过程，定位未释放的内存地址、分配位置，帮助快速排查泄漏点。

## 智能指针
智能指针是 C++ 标准库提供的自动内存管理工具，核心作用是替代手动 new/delete，通过 “对象生命周期管理” 自动释放动态分配的内存，从源头避免内存泄漏。其本质是 “封装了原始指针的类对象”，利用 C++ 类的析构函数（对象销毁时自动调用）实现内存自动释放，无需开发者手动操作。  
C++ 标准库中常用的智能指针有三种：std::unique_ptr 是 “独占所有权” 指针，同一时间只能有一个指针指向内存，适合管理无需共享的资源；std::shared_ptr 是 “共享所有权” 指针，通过引用计数跟踪指向内存的指针数量，所有指针都销毁后才释放内存，适合资源共享场景；std::weak_ptr 是 “弱引用” 指针，不增加引用计数，仅用于观察 std::shared_ptr 管理的资源，避免循环引用导致的内存泄漏。使用时只需包含 memory 头文件，通过构造函数或 std::make_unique/std::make_shared 函数创建，即可像普通指针一样使用，无需手动调用 delete。

## 指针与引用
在 C++ 中，指针和引用都是用于间接访问变量的工具，但本质和用法有显著区别：
指针是一个变量，它存储另一个变量的内存地址，自身有独立的内存空间。指针可以被赋值为 nullptr（表示空指针），也可以通过 * 运算符解引用访问目标变量，还能通过 & 运算符获取变量地址。指针本身可以被重新赋值，指向不同的变量，例如 int* p = &a; p = &b; 是合法的。
引用是变量的别名，它没有独立的内存空间，必须在定义时初始化且绑定到一个变量，之后无法再绑定到其他变量（从一而终）。引用不存在空引用，也不能通过引用自身修改其绑定的目标，使用时无需解引用，直接操作引用就等同于操作被绑定的变量，例如 int& r = a; r = 5; 会直接修改 a 的值。
简单说，指针是 “指向变量的变量”，灵活但需手动管理；引用是 “变量的别名”，更安全但缺乏指针的灵活性。

## 缓存穿透、缓存击穿和缓存雪崩
- 缓存穿透：请求查询不存在的数据（如 ID=-1），缓存和数据库都无结果，导致请求一直穿透到数据库。解决：缓存空值（短期有效）；布隆过滤器提前拦截不存在的 key。
- 缓存击穿：某一个热点 key 过期瞬间，大量请求同时访问该 key，直接穿透到数据库。解决：热点 key 永不过期；互斥锁（如 Redis 的 SETNX）控制并发访问。
- 缓存雪崩：大量缓存 key 在同一时间过期，或缓存服务宕机，导致所有请求直接冲击数据库，造成数据库崩溃。解决：key 过期时间加随机值避免同时过期；缓存集群部署；降级熔断机制。

## 线程池
线程池是管理线程的容器，避免频繁创建 / 销毁线程的开销，提高资源利用率。核心思想是复用线程：  
- 初始化时创建一定数量的线程，放入 “线程池”。
- 任务提交时，从池中取空闲线程执行；无空闲线程则按策略处理（如排队、拒绝）。
- 任务执行完后，线程不销毁，放回池中等待下一个任务。  
核心作用：控制并发线程数、降低资源消耗、提高响应速度。

## 线程池哪些参数设置不当会造成 OOM？
Java 线程池（ThreadPoolExecutor）的以下参数设置不当可能导致 OOM（内存溢出）：  
- corePoolSize 和 maximumPoolSize：设置过大，导致创建过多线程，占用大量内存。  
- workQueue（任务队列）：使用无界队列（如 LinkedBlockingQueue 不指定容量），当任务提交速度远快于处理速度时，队列无限膨胀，耗尽内存。  
- 任务本身：任务执行时创建大量对象（如大集合），若线程池并发高，可能导致内存占用激增。  
建议：根据业务场景合理设置队列容量（如用有界队列 ArrayBlockingQueue），控制最大线程数。

## 数据库的四大特性ACID
- 原子性（Atomicity）：事务是不可分割的最小单位，要么全部执行成功，要么全部失败回滚。例如转账操作中，扣款和收款必须同时完成，若中间出错则恢复到初始状态，避免资金不一致。
- 一致性（Consistency）：事务执行前后，数据库从一个合法状态转换到另一个合法状态，满足预设的业务规则。比如转账后双方账户总金额不变，库存不会出现负数等。
- 隔离性（Isolation）：多个并发事务同时执行时，彼此的操作互不干扰，仿佛各自独立运行。数据库通过隔离级别（如读未提交、读已提交、可重复读、串行化）控制隔离程度，平衡并发效率和数据正确性。
- 持久性（Durability）：事务一旦提交，其修改会永久保存到数据库中，即使系统崩溃也不会丢失。通常通过事务日志（如 redo log）实现，确保数据在提交后能被持久化存储。

## 数据库的隔离级别
数据库的隔离级别用于控制多个并发事务之间的相互影响，平衡并发效率与数据一致性，SQL 标准定义了 4 种基础隔离级别（由低到高）：
- 读未提交（Read Uncommitted）：事务可读取其他未提交事务的修改。可能导致脏读（读取到未提交的无效数据），但并发性能最高，实际中很少使用。
- 读已提交（Read Committed）：事务只能读取其他已提交事务的修改，避免脏读，但可能出现不可重复读（同一事务内两次读取同一数据结果不同）。多数数据库默认采用此级别（如 Oracle、SQL Server）。
- 可重复读（Repeatable Read）：保证同一事务内多次读取同一数据结果一致，避免不可重复读，但可能产生幻读（事务期间新增符合查询条件的记录）。MySQL 默认为此级别，且通过 MVCC 机制进一步避免了幻读。
- 串行化（Serializable）：最高隔离级别，强制事务串行执行，完全避免脏读、不可重复读和幻读，但并发性能极差，仅适合数据一致性要求极高的场景。  
隔离级别越高，数据一致性越好，但并发能力越弱，实际应用需根据业务场景选择（如金融场景常用可重复读或串行化，互联网高并发场景常用读已提交）。

## 数据库是怎么保证事务的原子性的？
数据库通过事务日志（Undo Log + Redo Log）保证原子性：  
- Undo Log：记录事务执行前的数据状态。若事务失败（如异常），通过 Undo Log 回滚到事务开始前的状态，确保 “要么全做，要么全不做”。  
- Redo Log：记录事务执行的修改操作。若数据库崩溃，重启后通过 Redo Log 重新执行未完成的事务，避免数据丢失。  
例如：银行转账时，若扣款后系统崩溃，Undo Log 会回滚扣款操作，保证原子性。

## 二叉树右视图
二叉树的右视图是指从右侧观察二叉树时能看到的节点，即每一层最右侧的节点。  
实现思路：  
- 使用层序遍历（BFS），记录每一层的最后一个节点。
- 或使用深度优先遍历（DFS），优先访问右子树，确保每层第一个访问的节点是最右侧节点。

## 数据库连接池了解吗
数据库连接池本质上是一个缓存和管理数据库连接的容器。应用程序启动时，连接池会预先创建一定数量的数据库连接并维护起来。当应用程序需要操作数据库时，它不再是自己新建一个连接，而是从连接池‘借用’一个现成的连接；用完后，也不是真正关
闭连接，而是‘归还’给连接池。  
如果没有连接池，每次数据库请求都要经历一次完整的 TCP 三次握手、数据库认证、连接分配等过程，操作完毕后又要断开连接。这个过程非常耗时耗资源。  
连接池通过复用连接 避免了频繁的创建和销毁，极大地节约了系统开销，显著提升了应用程序的响应速度 和整体的并发处理能力。同时，它还能统一管理连接资源，防止因程序漏洞导致连接无法关闭而引起的数据库连接耗尽（内存泄漏）。  
核心参数：  
- 初始连接数 (initialSize): 池启动时创建的初始连接数量。
- 最大连接数 (maxTotal): 池中能同时存在的最大活动连接数。这取决于数据库和系统的负载能力。
- 最小空闲连接数 (minIdle): 保证池中至少维持的空闲连接数，用于快速响应请
求。
- 最大空闲连接数 (maxIdle): 防止空闲连接过多浪费资源。
- 最大等待时间 (maxWaitMillis): 当池中无可用连接时，新的请求等待多长时间，超时则抛出异常。这是防止请求被无限挂起的重要参数。

常用连接池：
- HikariCP: 以其高性能、轻量级 著称，是 Spring Boot 2.x 以后的默认连接池。
- Druid (德鲁伊): 阿里开源的产品，功能全面，提供强大的监控和扩展功能，在国内非常流行

## C++ 基本数据类型及字节数（32 位 / 64 位平台通用参考）
- 布尔型：bool，1 字节
- 字符型：char（1 字节）、wchar_t（2/4 字节，取决于编译器）
- 整数型：short（2 字节）、int（4 字节）、long（4 字节 / 8 字节，32 位平台 4 字节，64 位平台 8 字节）、long long（8 字节）
- 浮点型：float（4 字节）、double（8 字节）、long double（8/16 字节，依平台而定）  
注：int 与处理器字长相关，long 与操作系统位数相关，具体以编译器和平台为准。

## 不同平台类型字节数差异的原因
核心是平台架构和编译器实现的差异：  
- 硬件层面：32 位处理器地址总线为 32 位，寄存器宽度 32 位，long 等类型通常适配为 4 字节；64 位处理器则适配为 8 字节以提高效率。
- 编译器层面：C++ 标准仅规定类型的 “最小字节数” 和 “相对大小”（如 int ≥ short），具体字节数由编译器厂商根据平台特性（如内存对齐、性能优化）决定。  
- 历史兼容：部分平台为兼容旧代码，保留了传统字节数定义（如某些系统 long 仍为 4 字节）。

## 死锁的产生及必要条件
产生原因：多线程（或进程）因竞争资源而相互等待，且彼此持有对方所需资源，导致所有线程无法继续执行。  
四个必要条件（缺一不可）：
- 互斥条件：资源只能被一个线程持有（如独占锁）。
- 持有并等待：线程持有部分资源，同时等待其他资源。
- 不可剥夺：资源不能被强制从持有者手中夺走。
- 循环等待：线程间形成环形等待链（如 A 等 B 的资源，B 等 A 的资源）。

## 规避死锁的方法
- 破坏循环等待：按固定顺序申请资源（如所有线程均先申请资源 1，再申请资源 2）。
- 破坏持有并等待：一次性申请所有所需资源，未获取全部则释放已持有的资源。
- 超时释放：申请资源时设置超时时间，超时则释放已持有资源并重试。
- 使用 try_lock：尝试获取锁失败时主动释放已持有的锁，避免阻塞。
- 定期检测：通过算法检测死锁（如资源分配图），发现后主动释放部分资源。

## 超时释放锁是否会导致业务逻辑出错？
可能会，但可通过设计规避：
- 若超时释放后，原线程仍在执行任务，新线程可能重复执行，导致数据不一致（如重复扣款）。
- 解决方式：结合 “业务幂等性设计”（确保重复执行结果一致）、“锁标识校验”（任务执行前验证锁是否仍有效）、“超时时间合理设置”（大于业务最大执行时间）。

## 设计简单线程池需考虑的方面
- 核心参数：核心线程数（常驻线程）、最大线程数（允许的临时线程上限）、任务队列（缓冲待执行任务）、拒绝策略（队列满时如何处理新任务）。
- 线程管理：线程池中的线程没有任务可执行时进入阻塞状态，直到有新任务到来才被唤醒继续工作，任务队列空且超过空闲时间则销毁临时线程。
- 同步机制：用互斥锁保护任务队列的读写，条件变量通知线程有新任务。
- 优雅关闭：停止接收新任务，等待队列中任务执行完毕后销毁所有线程。

## 线程池里的锁的作用
- 保护任务队列：多个线程（生产者提交任务、消费者线程取任务）并发操作队列时，通过锁保证队列操作的原子性（如避免同时添加 / 删除任务导致数据错乱）。  
- 同步线程状态：结合条件变量，实现线程的阻塞等待（队列空时线程休眠）和唤醒（有新任务时唤醒线程），减少无效轮询。

## 线程 A/B 交替执行，C 最后执行的实现
- 用两个互斥锁（lockA、lockB）控制 A 和 B 的交替：
    - 初始化时 lockA 解锁，lockB 锁定，确保 A 先执行。
    - A 打印完一个数字后，解锁 lockB 并锁定自己，等待 B 执行。
    - B 打印完后，解锁 lockA 并锁定自己，循环直至所有数字打印完毕。
- 用线程 join 确保 C 在 A、B 结束后执行：A 和 B 启动后，主线程调用 A.join() 和 B.join()，再启动 C。

## 红黑树的底层原理
红黑树是一种自平衡的二叉搜索树（BST），通过维持特定规则保证树的高度始终为 O (log n)，从而确保插入、删除、查找等操作的时间复杂度稳定在 O (log n)。其核心原理是通过颜色规则和旋转操作平衡树结构，避免出现普通 BST 因极端插入顺序导致的 “斜树”（退化为链表）问题。  

红黑树的 5 条核心规则（维持平衡的关键）  
- 节点颜色：每个节点要么是红色，要么是黑色。
- 根节点：根节点必须是黑色。
- 叶节点：所有叶子节点（NIL 节点，空节点）都是黑色。
- 红节点限制：红色节点的两个子节点必须是黑色（即不允许连续两个红色节点）。
- 路径规则：从任意节点到其所有叶子节点的路径中，包含的黑色节点数量相同（称为 “黑高” 相等）。

插入与删除后的平衡调整：
当插入或删除节点打破上述规则时，红黑树会通过以下两种操作恢复平衡：
1. 变色：修改节点的颜色（红→黑或黑→红），通常用于解决 “连续红节点” 问题。
2. 旋转：通过调整节点的位置关系改变树的结构，分为左旋和右旋，用于调整树的倾斜方向，避免单侧深度过大。
- 插入场景：新节点默认设为红色（减少对黑高的影响），若插入后违反规则（如父节点也是红色），则通过 “变色→旋转” 修复（具体步骤取决于叔叔节点的颜色）。
- 删除场景：删除黑色节点可能破坏 “黑高” 规则，需通过 “兄弟节点调整”“旋转” 等操作恢复，过程比插入更复杂。

核心优势：  
红黑树通过严格的颜色规则和高效的旋转操作，在最坏情况下仍能保持 O (log n) 的高度，兼顾了平衡性能和实现复杂度（相比 AVL 树，旋转操作更少，插入删除效率更高），因此被广泛应用于 C++ STL 的 map/set、Linux 内核的进程调度等场景。

## 一把锁会产生死锁吗
绝对不会。 这是理解死锁的关键。
- 如果整个系统只有一把锁，那么所有线程都在竞争这同一把锁。
- 当一个线程持有这把锁时，其他线程会在这把锁上等待。这是一种简单的竞争和串行化，不存在循环等待。
- 持有锁的线程释放锁后，等待的线程中的一个会成功获取并继续执行。这是正常的同步，不是死锁。

## OSI 七层模型的分层与功能（从下到上）
1. 物理层（Physical Layer，第 1 层）
- 核心功能：负责物理介质上的信号传输，将数据转换为电 / 光 / 无线电信号（如以太网的电信号、光纤的光信号）；
- 关键技术：
    - 物理介质（网线、光纤、无线电波）；
    - 信号编码（如曼彻斯特编码、差分曼彻斯特编码）；
    - 接口标准（如 RJ45 网线接口、USB 接口、光纤 LC 接口）；
    - 传输速率（如 100Mbps、10Gbps）、双工模式（半双工 / 全双工）；
- 典型设备：网卡、网线、光纤、集线器（Hub）、中继器。
2. 数据链路层（Data Link Layer，第 2 层）
- 核心功能：负责相邻设备间的可靠数据传输，解决物理层的 “信号错误” 问题，将物理层的 “信号流” 封装为 “帧（Frame）”；
- 关键技术：
    - 帧封装（添加帧头：源 / 目的 MAC 地址；帧尾：CRC 校验码）；
    - MAC 地址（设备的物理地址，如网卡的 6 字节地址，用于局域网内寻址）；
    - 差错控制（CRC 校验，检测帧是否损坏，损坏则要求重发）；
    - 流量控制（避免发送方速度过快导致接收方拥塞）；
    - 介质访问控制（MAC 协议，如以太网的 CSMA/CD、无线的 CSMA/CA，解决多设备争用物理介质的问题）；
- 典型设备：交换机（Layer 2 交换机，基于 MAC 地址转发帧）、网桥。
3. 网络层（Network Layer，第 3 层）
- 核心功能：负责跨网络的端到端寻址与路由，解决 “不同局域网间如何通信” 的问题，将数据链路层的 “帧” 封装为 “数据包（Packet）”；
- 关键技术：
    - IP 地址（逻辑地址，如 IPv4 的 32 位地址、IPv6 的 128 位地址，用于跨网络寻址）；
    - 路由选择（通过路由协议如 RIP、OSPF、BGP，选择从源网络到目的网络的最佳路径）；
    - 拥塞控制（检测网络拥塞并调整发送速率，避免数据包丢失）；
    - 分片与重组（当数据包超过物理介质的 MTU（最大传输单元）时，拆分成分片，接收端重组）；
- 典型设备：路由器（基于 IP 地址转发数据包）、三层交换机。
4. 传输层（Transport Layer，第 4 层）
- 核心功能：负责端到端的可靠数据传输，连接 “应用程序” 与 “网络层”，为上层应用提供 “面向连接” 或 “无连接” 的传输服务，将网络层的 “数据包” 封装为 “段（Segment，TCP）” 或 “数据报（Datagram，UDP）”；
- 关键技术：
    - 端口号（如 HTTP 的 80、HTTPS 的 443、SSH 的 22，用于标识主机上的应用程序）；
    - 面向连接（TCP 协议）：三次握手建立连接、四次挥手关闭连接，通过序列号、确认号、重传机制保证可靠性；
    - 无连接（UDP 协议）：无需建立连接，速度快但不可靠，适合实时场景（如视频通话、DNS 查询）；
    - 流量控制（TCP 滑动窗口机制，避免接收方缓冲区溢出）；
    - 拥塞控制（TCP 慢启动、拥塞避免机制，适应网络负载）；
- 典型协议：TCP（传输控制协议）、UDP（用户数据报协议）。
5. 会话层（Session Layer，第 5 层）
- 核心功能：负责建立、管理和终止应用程序间的 “会话”（如用户登录、文件传输的会话），解决 “应用程序如何维持通信状态” 的问题；
- 关键技术：
    - 会话建立（如通过认证机制验证双方身份，建立会话标识）；
    - 会话管理（维持会话状态，如断点续传时记录传输进度）；
    - 会话终止（正常关闭会话或异常中断后的资源释放）；
- 典型场景：FTP 的文件传输会话、Telnet 的远程登录会话、数据库连接会话。
6. 表示层（Presentation Layer，第 6 层）
-核心功能：负责数据的 “格式转换” 与 “安全处理”，确保发送方的应用数据能被接收方的应用程序正确解析；
- 关键技术：
    - 数据编码（如 ASCII、UTF-8、Unicode，统一字符编码格式）；
    - 数据压缩（如 ZIP、GZIP，减少数据传输量）；
    - 数据加密（如 TLS/SSL 的加密、SM4 国密算法，保护数据机密性）；
    - 格式转换（如将二进制数据转换为 XML/JSON 格式，或不同应用的自定义数据格式转换）；
- 典型场景：HTTPS 的 TLS 加密（表示层 + 传输层结合）、文件压缩传输、跨平台数据格式适配。
7. 应用层（Application Layer，第 7 层）
- 核心功能：直接为应用程序提供网络服务，是用户与网络的 “接口”，定义应用程序间通信的协议规范；
- 关键协议：
    - HTTP/HTTPS（网页浏览、API 通信）；
    - FTP（文件传输）、SMTP/POP3/IMAP（电子邮件）；
    - DNS（域名解析，将域名转换为 IP 地址）；
    - Telnet/SSH（远程登录）、SNMP（网络设备管理）；
- 典型应用：浏览器（Chrome、Edge）、邮件客户端（Outlook）、文件传输工具（FileZilla）。

## TCP与UDP的区别
1. 连接方式：TCP 是面向连接的，传输前需通过 “三次握手” 建立连接，结束后需 “四次挥手” 释放连接；UDP 是无连接的，直接封装数据发送，无需建立 / 释放连接。
2. 可靠性：TCP 能保证数据不丢失、不重复、按序到达，靠确认机制（ACK）、序号校验、超时重传实现；UDP 不保证可靠性，数据可能丢失或乱序，仅 “尽力传输”。
3. 数据边界：TCP 面向字节流，数据无固定边界，需应用层自行划分；UDP 面向数据报，每个数据报是独立单元，接收方按数据报完整接收。
4. 传输效率：TCP 效率低，因握手、确认、重传等额外开销；UDP 效率高，无多余流程，首部仅 8 字节（TCP 固定 20 字节），适合高速传输。
5. 拥塞控制：TCP 支持拥塞控制（滑动窗口、慢启动等），能根据网络状态调整传输速率，避免网络过载；UDP 无拥塞控制，会持续发送数据，可能加剧网络拥堵。
6. 适用场景：TCP 用于需可靠性的场景（文件传输、网页加载、转账支付）；UDP 用于需实时性的场景（视频通话、语音聊天、游戏数据、DNS 查询）。