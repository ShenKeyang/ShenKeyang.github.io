---
title: 算法笔记(C++) ——深度优先搜索
date: 2025-09-10 22:06:32
tags:
---


深度优先搜索(Depth First Search , DFS)是一种用于遍历或搜索图（图可以是树、无向图、有向图等）的算法。它按照深度优先的策略，优先访问当前节点的下一层邻接节点，直到无法继续为止，再回溯到上一层。可以粗略的理解为：DFS就是在图上做特定的递归，DFS⊂递归。  

## 树的存储和遍历
__树的两种读入方式：__
1. 边形式:  
- 存储：这种读入形式将树看成一张图进行读入，本质就是上一篇中的的读入形式，所以可以使用邻接表（记录对应节点的相邻节点信息的表格）直接存储。但特别要注意的是，虽然树在定义上是有向图，但有时读入的数据可能会不符合其定义。例如，树中的一条有向边从节点 1 指向节点 2，但在输入时可能会以 2 1 的形式读入，所以为了能够正确进行遍历，就需要使用无向图的存储方式(也就是对于读入进来的边，正反都存储一遍)。  
- 遍历:由于存储结构被迫变成了无向图(虽然它本应该是有向图的结构)，那么在递归遍历的时候(或者说在深度优先搜索的过程中)，我们需要注意由于返祖边的存在导致的无限递归（返祖边:假设树里存在一条从节点 1 指向节点 2的有向边1 2。那么1是2的父亲，也是2的祖先。但在实际的存储中又存在从2指向1的边2 1。那么2 1 就是一条返祖边）。  
解决方法: 增加父亲参数father，禁止由子节点访问父节点。  
2. 父亲数组：
- 存储：树中的每个节点都有唯一的父节点，这种唯一性使得我们可以通过数组来存储父节点信息。所以树可以用父亲数组（father[]）来表示树的结构。
```
示例 1：一棵简单的树  

树的结构：
    1
   / \
  2   3
     / \
    4   5

父亲数组表示：
father[1] = 0  （根节点无父节点，约定为 0）
father[2] = 1  （节点 2 的父亲是 1）
father[3] = 1  （节点 3 的父亲是 1）
father[4] = 3  （节点 4 的父亲是 3）
father[5] = 3  （节点 5 的父亲是 3）

父亲数组：father = [0, 1, 1, 3, 3]
```
但由于我们访问的顺序是从父亲到儿子，而父亲数组存储的是每个儿子的父亲。所以我们无法直接利用父亲数组进行DFS。我们还是将父亲数组转化为邻接表进行存储：
```c++
adjList[father[i]].push_back(i);
```
- 遍历：  
在这种读入形式下，不再存在第一种形式所提及的无限递归问题。可以直接进行遍历。
```c++
for(int i = 1; i <= n; i++)
{
	sort(adjList[i].begin(), adjList[i].end());
}

void DFS(int node, int parent) 
{
	traversalResult.push_back(node); // 访问当前节点
	for(auto &child : adjList[node]) 
    {
		if(child != parent) 
        { // 避免回到父节点
			DFS(child, node); // 递归访问子节点
		}
	}
}
```

__注：__  
`vector<int> matrix(MAX);`和`vector<int> arr[MAX];`的区别：  
在 C++ 中，二者是两种完全不同的定义方式，核心区别在于数据结构的类型和用途：  
- `vector<int> tree(MAX);`  
本质：定义一个单个 vector<int> 对象，其元素为int类型，并指定其初始大小为 MAX。
这个 vector 会预先分配能容纳 MAX 个 int 元素的内存，且每个元素会被默认初始化（int 类型默认值为 0）。
用途：需要一个初始大小固定的动态数组时使用，例如需要存储 MAX 个元素的序列。
- `vector<int> tree[MAX];`  
本质：定义一个数组，数组的每个元素都是一个 vector<int> 对象。
其中 MAX 是数组的大小（必须是编译期常量），表示这个数组包含 MAX 个 vector<int> 容器。
用途：通常用于表示邻接表（如树、图的存储），例如 tree[i] 表示第 i 个节点的所有邻接节点。

<br>





## DFS的核心思想与实现方式
__核心思想：__  
- DFS 的本质是 “不撞南墙不回头”，其关键在于 “回溯”（Backtracking）—— 当当前路径无法继续探索时，撤销上一步的选择，回到之前的状态并尝试新的可能性。可以用一个生活化的例子理解：假设你走进一个迷宫，面前有 3 条岔路（A、B、C）。DFS 会先选择岔路 A，一直走到尽头（可能是出口，也可能是死胡同）；如果是死胡同，就退回到岔路口，再选择岔路 B，重复探索；最后再探索岔路 C。整个过程中，“退回岔路口” 就是回溯，“走到底” 就是深度优先。

__实现方式：__
- 根据其“走到底”的特性，DFS可以看作是一种特殊的递归算法，同时树又是DFS的典型应用场景。以下是一道运用递归对树的各节点/子树进行深度优先搜索的例题：
```c++
/*题目描述：
有一棵有n个节点的树，根节点为1号节点，树的每个节点是红色或者黑色，想知道有多少节点的子树中同时包含红点和黑点。

输入描述：
第一行输入一个整数n表示节点数量
第二行输入一个长度为n的字符串s表示节点的颜色，第i个节点的颜色为si ，若si为'B'表示节点的颜色为黑色，若si为'R' 则表示节点的颜色为红色。 接下来n−1行，每行输入两个整数 u,v(1≤u,v≤n)表示树上的边.

输出描述：
输出一个整数表示答案。*/

#include <bits/stdc++.h>
using namespace std;

//定义全局变量邻接表、颜色信息向量、结果值
vector<vector<int>> adj;
vector<char> colors;
int result = 0;

vector<bool> dfs(int node, int parent)
{
    // 标记当前子树是否包含红色和黑色
    bool hasRed = false, hasBlack = false;
    if (colors[node] == 'R') hasRed = true;
    else hasBlack = true;

    for (int neighbor : adj[node]) //遍历每一个孩子节点，探索每一种可能性（回溯）
    {
        if (neighbor != parent) //邻接表是无向的，应确保搜索的是子树而不是父节点
        {
            vector<bool> child = dfs(neighbor, node);
            //针对每一个孩子节点，递归调用进行深度优先搜索（DFS）
            if(child[0])
            {
                hasRed = true;
            }
            if(child[1])
            {
                hasBlack = true;
            }
        }
    }
    // 如果当前子树既有红色又有黑色节点，则满足条件
    if (hasRed && hasBlack)
    {
        result++;
    }

    return {hasRed, hasBlack};
}

int main()
{
    int n;
    cin >> n;
    //根据输入的n对全局变量resize
    colors.resize(n);
    adj.resize(n);
    
    for (int i = 0; i < n; i++)
    {
        cin >> colors[i];
    }
    
    for (int i = 0; i < n - 1; i++)
    {
        int u, v;
        cin >> u >> v;
        adj[u-1].push_back(v-1); //由于题目中的根节点是从1开始标号
        adj[v-1].push_back(u-1); //故而实际代码中应先-1后再存入
    }

    dfs(0, -1);

    cout << result << endl;

    return 0;
}
```