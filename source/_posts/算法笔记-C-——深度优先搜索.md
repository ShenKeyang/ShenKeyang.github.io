---
title: 算法笔记(C++) ——深度优先搜索
date: 2025-09-10 22:06:32
tags:
---


## 树的存储和遍历
深度优先搜索(Depth First Search , DFS)是一种用于遍历或搜索图（图可以是树、无向图、有向图等）的算法。它按照深度优先的策略，优先访问当前节点的下一层邻接节点，直到无法继续为止，再回溯到上一层。可以粗略的理解为：DFS就是在图上做特定的递归，DFS⊂递归。  

__树的两种读入方式：__
1. 边形式:  
- 存储：这种读入形式将树看成一张图进行读入，本质就是上一篇中的的读入形式，所以可以使用邻接表（记录对应节点的相邻节点信息的表格）直接存储。但特别要注意的是，虽然树在定义上是有向图，但有时读入的数据可能会不符合其定义。例如，树中的一条有向边从节点 1 指向节点 2，但在输入时可能会以 2 1 的形式读入，所以为了能够正确进行遍历，就需要使用无向图的存储方式(也就是对于读入进来的边，正反都存储一遍)。  
- 遍历:由于存储结构被迫变成了无向图(虽然它本应该是有向图的结构)，那么在递归遍历的时候(或者说在深度优先搜索的过程中)，我们需要注意由于返祖边的存在导致的无限递归（返祖边:假设树里存在一条从节点 1 指向节点 2的有向边1 2。那么1是2的父亲，也是2的祖先。但在实际的存储中又存在从2指向1的边2 1。那么2 1 就是一条返祖边）。  
解决方法: 增加父亲参数father，禁止由子节点访问父节点。  
2. 父亲数组：
- 存储：树中的每个节点都有唯一的父节点，这种唯一性使得我们可以通过数组来存储父节点信息。所以树可以用父亲数组（father[]）来表示树的结构。
```
示例 1：一棵简单的树  

树的结构：
    1
   / \
  2   3
     / \
    4   5

父亲数组表示：
father[1] = 0  （根节点无父节点，约定为 0）
father[2] = 1  （节点 2 的父亲是 1）
father[3] = 1  （节点 3 的父亲是 1）
father[4] = 3  （节点 4 的父亲是 3）
father[5] = 3  （节点 5 的父亲是 3）

父亲数组：father = [0, 1, 1, 3, 3]
```
但由于我们访问的顺序是从父亲到儿子，而父亲数组存储的是每个儿子的父亲。所以我们无法直接利用父亲数组进行DFS。我们还是将父亲数组转化为邻接表进行存储：
```c++
adjList[father[i]].push_back(i);
```
- 遍历：  
在这种读入形式下，不再存在第一种形式所提及的无限递归问题。可以直接进行遍历。
```c++
for(int i = 1; i <= n; i++)
{
	sort(adjList[i].begin(), adjList[i].end());
}

void DFS(int node, int parent) 
{
	traversalResult.push_back(node); // 访问当前节点
	for(auto &child : adjList[node]) 
    {
		if(child != parent) 
        { // 避免回到父节点
			DFS(child, node); // 递归访问子节点
		}
	}
}
```

__注：__  
`vector<int> matrix(MAX);`和`vector<int> arr[MAX];`的区别：  
在 C++ 中，二者是两种完全不同的定义方式，核心区别在于数据结构的类型和用途：  
- `vector<int> tree(MAX);`  
本质：定义一个单个 vector<int> 对象，其元素为int类型，并指定其初始大小为 MAX。
这个 vector 会预先分配能容纳 MAX 个 int 元素的内存，且每个元素会被默认初始化（int 类型默认值为 0）。
用途：需要一个初始大小固定的动态数组时使用，例如需要存储 MAX 个元素的序列。
- `vector<int> tree[MAX];`  
本质：定义一个数组，数组的每个元素都是一个 vector<int> 对象。
其中 MAX 是数组的大小（必须是编译期常量），表示这个数组包含 MAX 个 vector<int> 容器。
用途：通常用于表示邻接表（如树、图的存储），例如 tree[i] 表示第 i 个节点的所有邻接节点。

<br>





