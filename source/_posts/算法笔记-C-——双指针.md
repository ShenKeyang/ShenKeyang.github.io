---
title: 算法笔记(C++) ——双指针
date: 2025-08-31 21:37:05
tags:
---


## 双指针算法概述:
双指针算法（双指针技术）是一种在处理线性数据结构（如数组、链表）时常用的算法策略。它通过同时使用两个指针，以不同的方式遍历数据结构，从而优化时间复杂度或简化问题的解决过程。双指针算法广泛应用于各种经典问题，如数组排序、链表操作、字符串处理等。  

- 双指针的常见类型
1. 快慢指针（快指针与慢指针）:  
    - 用途：常用于检测链表中的环、找到链表的中间节点等。
    - 原理：设定两个指针，快指针一次移动两步，慢指针一次移动一步。如果链表中存在环，快指针最终会与慢指针相遇；如果不存在环，快指针会先到达链表末尾。

2. 左右指针（双端指针）:  
    - 用途：常用于处理有序数组中的问题，如两数之和、三数之和、四数之和等。
    - 原理：设定一个指针指向数组的起始位置，另一个指针指向数组的末尾，根据当前指针对应的值与目标值的关系来移动指针，以缩小搜索范围。

3. 滑动窗口:  
    - 用途：用于解决字符串或数组中满足特定条件的子串或子数组问题，如最长不重复子串、最小覆盖子串等。
    - 原理：通过维护一个“窗口”区间（左右边界通常由两个指针left和right表示），动态调整窗口的范围来高效地解决问题。窗口扩展：通常通过固定左指针left、右移（枚举）右指针right来扩大窗口，纳入新的元素；窗口收缩：当窗口内不满足条件时，通过固定右指针right、右移左指针left来缩小窗口，排除不需要的元素；动态调整：根据题目要求，动态调整窗口的大小和位置，直到找到满足条件的解。
  
<br><br>





## 例题：互相嘲笑的两个人
- 题目描述：
小红和小堡正在玩一个游戏，每一关都有一个分数。如果某人某一关分数比上一关高，但另一个人这一关分数比上一关低，那么他就可以嘲笑对方。如果两个人这一关游戏的分数都比上一关多，则增量更多的可以嘲笑对方;如果两个人这一关游戏的分数都比上一关少，则减量更少的可以嘲笑对方。只有当他们的增量相同或者减量相同时，才不会互相嘲笑。  
例如，假设小红第一关的分数为2，第二关的分数为8;小堡第一关的分数为5，第二关的分数为10，显然小红增加的比小堡多，那么小红就可以嘲笑小堡。  
现在给定了小红和小堡每一关的分数，你可以选择一段连续的关卡，使得一段关卡中两个人都不会互相嘲笑，问最多可以选择多少个关卡。特别的一段连续关卡中的第一关两人不会互相嘲笑。
- 输入：
    - 第一行输入一个正整数n,代表关卡数。
    - 第二行输入n个整数a_i,代表小红每一关的分数。
    - 第三行输入n个整数b_i,代表小堡每一关的分数。
- 输出：  
    - 输出可以选择最多的关卡数。

- 题解代码：
```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin >> n;
    vector<int> a(n),b(n);
    for(int i=0;i<n;i++)
    {
        cin >> a[i];
    }
    for(int i=0;i<n;i++)
    {
        cin >> b[i];
    }
    
    // 计算差分数组
    vector<int> diff_a(n - 1), diff_b(n - 1);
    for (int i = 0; i < n - 1; ++i) {
        diff_a[i] = a[i + 1] - a[i];
        diff_b[i] = b[i + 1] - b[i];
    }
    int l=0,r=0,res=0;
    int m = diff_a.size();

    while(l<m)
    {
        while (r < m && diff_a[r] == diff_b[r]) {
            r++;
        }
        // 计算该区间的长度
        res = max(res, r - l + 1);
        // 左指针移动到右指针的位置，开始新的检查
        l = r + 1;
        r = l;
    }

    cout << res <<endl;

    return 0;
}
```