---
title: 算法笔记(C++) ——动态规划
date: 2025-09-22 00:03:16
tags:
---


动态规划（Dynamic Programming，简称 DP）是一种有效的算法设计思想，用于解决具有`最优子结构`和`重叠子问题`的复杂问题。其核心思想是通过`记录已解决子问题的结果`来避免重复计算，从而优化效率。关键在于`定义问题的状态和状态转移方程`。  
​以下是一道关于DP的简单例题，并通过集合视角一步步推导状态和转移方程的详细过程：
```
题目描述：
小明正在爬楼梯。楼梯总共有n级台阶，小明每次可以选择爬1级或2级台阶。请问小明爬到第n级台阶的不同方法有多少种。
注意：假设小明从地面（第 0 级台阶）开始爬楼梯，每次可以从当前台阶选择爬1级或2级台阶，直到到达第n级台阶。

输入：
输入一个整数 n（1 ≤ n ≤ 40），表示楼梯的总级数。

输出：
输出一个整数，表示爬到第 n 级台阶的不同方法数。
```
1. __讨论 n = 4 的情况：__  
对于 (n = 4)，所有可能的爬楼方式如下(5种)：
    - 0→1→2→3→4
    - 0→1→2→4
    - 0→1→3→4
    - 0→2→3→4
    - 0→2→4
将这些方案的集合定义为 D4 ，那么集合的大小∣D4∣=5 就是问题的答案。
2. __情况分类：__  
考虑到达第 4 级楼梯的方式，可以从两种途径到达：
    - 最后一步从第 3 级到达第 4 级，即 3→4；
    - 最后一步从第 2 级到达第 4 级，即 2→4；
根据这两种情况，我们可以将集合 D4 分为两部分:  
![ ](/images/cpp_11_1.png) 
3. __等价映射：__  
从集合划分可以观察到：  
    - 将上图中的第一个式子中最后的(4)去掉，得到的方案等价于从(0)到(3)的所有方案，即1式等价于D3；  
    - 将上图中的第二个式子中最后的(4)去掉，得到的方案等价于从(0)到(2)的所有方案，即1式等价于D2；  
4. __递推方程:__  
通过上述分析，可以得出递推关系：  
    - __|D4| = |D2| + |D3|__
5. __推广情况:__  
我们可以用相同的思路分析任意 (n)：  
要到达第 n 级楼梯，最后一步只能是从 n−1 或 n−2 到达。因此，所有从 0 到 n 的方案可以表示为：  
    - __|D_n| = |D_n-1| + |D_n-2|__  
这就是爬楼梯问题的`核心状态转移方程`。
6. __边界条件：__  
在动态规划中，需要明确边界条件来初始化状态转移：
    - 从 (0) 到 (1) 的方案：只能 0→1，因此：∣D1∣=1;
    - 从 (0) 到 (2) 的方案：可以是 0→1→2或0→2，因此：∣D2∣=2;
7. __总结：__  
    - 状态定义：D_n为从第 (0) 级楼梯到第 (n) 级楼梯的所有方案数。
    - 状态转移方程：|D_n| = |D_n-1| + |D_n-2|；
    - 边界条件：∣D1∣=1 ，∣D2∣=2;  
通过上述递推公式，可以高效地计算任意 (n) 的爬楼方案数。  

__上述例题的代码：__
```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin >> n;

    //这里第 i 个元素对应第 i+1 级台阶
    vector<int> D[n];

    D[0] = 1;
    D[1] = 2;

    for(int i=2;i<n;i++)
    {
        D[i] = D[i-1] + D[i-2];
    }

    cout << D[n-1] << endl;

    return 0;
}
```
<br>

__DP例题2 （二维状态转移）：__
```c++
/*题目描述
给定一个大小为 n×n 的二维矩阵，计算从起点 (1,1) 到终点 (n,n) 的所有可能路径的数量。
每一步可以向右或向下移动一个格子。

输入：
输入包含一个整数 n，表示矩阵的大小。 1<=n<=17

输出：
输出一个整数，表示从 (1,1) 到 (n,n) 的路径总数。*/

#include <bits/stdc++.h>
using namespace std;

/*思路：
1.状态定义：dp[i][j]表示从起点 (0,0) 到达位置 (i,j) 的路径总数;
2.状态转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1];
3.边界条件：dp[0][0] = 1 ，dp[i][0] = 1 ，dp[0][j] = 1;
*/

int main()
{
    int n;
    cin >> n;

    vector<vector<int>> dp(n,vector<int>(n, 0));

    dp[0][0] = 1;

    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++)
        {
            // 如果不是起点 (0, 0)，则计算当前点的路径数
            if (i>0) dp[i][j]+=dp[i - 1][j];//从上方来（前提不是第一行）
            if (j>0) dp[i][j]+=dp[i][j - 1];//从左方来（前提不是第一列）
            // 若既不是第一行，也不是第一列，则dp[i][j]=dp[i-1][j]+dp[i][j-1]
        }
    }

    cout << dp[n - 1][n - 1] << endl;

    return 0;
}
```
<br>

__DP例题3：__
```c++
/*题目内容：
圣诞节到了，小塔的妈妈准备了很多圣诞礼盒，礼盒大小不同，小塔在玩堆盒子的游戏，妈妈问小塔，怎么堆
盒子使得堆出的高度最高，每个礼盒的大小由长、宽、高表示，堆盒子的时候要求下面的盒子长、宽、高都必
须大于上面的盒子，不包含等于。请你帮助小塔一起堆出最高的一堆礼盒，高度为堆出的礼盒的所有高度的总和。

输入描述：
输入的第一行是礼盒的个数N，接下来输入N行，每行表示每个礼盒的长、宽、高。
礼盒的数量不超过1000个，每个盒子的长、宽、高取值范围为1~10。

输出描述：
输出一行，输出能堆出盒子的最高高度*/

#include <bits/stdc++.h>
using namespace std;

/*思路：
1.排序：首先，将所有盒子按照长、宽、高三个维度进行从小到大的排序。由于后面的盒子在长、宽、高方面
  都大于前面的盒子，因此可以确保后一个盒子不会被放在前一个盒子上面，从而简化了问题。
2.动态规划：接下来，使用动态规划来解决问题。定义 dp[i] 表示以第 i 个盒子为底部盒子时，所能达到的
  最大堆叠高度。我们需要考虑所有之前的盒子，如果一个盒子可以放在另一个盒子上面，就更新 dp[i] 的值。
3.结果计算：最终，结果为所有 dp[i] 中的最大值，即为我们能够堆叠的最高高度。
*/

const int maxn=1005;
int dp[maxn];
int n;
struct node{
	int l, w, h;
}box[maxn];


int main()
{
    cin>>n;
    for(int i=1;i<=n;++i)
    {
    	cin>>box[i].l>>box[i].w>>box[i].h;
	}

    //长、宽、高的三个优先级进行从小到大的排序
    sort(box+1, box+n+1, [&](node a, node b){
		if(a.l!=b.l){
			return a.l<b.l;   
		}
		if(a.w!=b.w){
			return a.w<b.w;
		}
		return a.h<b.h;
        }
    );

    int ans=0;

    //dp[i]表示第i个盒子作为底部时所能达到的最大高度
    for(int i=1;i<=n;++i)
    {
        dp[i]=box[i].h;
        for (int j = 1; j < i; j++)
        {
            if (box[i].h > box[j].h && box[i].l > box[j].l && box[i].w > box[j].w)
            {
                dp[i]=max(dp[i],dp[j]+box[i].h); //尝试匹配前面所有的“前最大高度”dp[j]，取最大值
            }
        }
        ans = max(ans,dp[i]);
    }
    cout << ans;
    return 0;
}
```
__注：__  
如下所示，上述代码中的此部分是一种C++中使用sort函数对一个结构体数组（数组或容器）进行自定义排序，其形式为`sort(box+1, box+n+1, lambda);`
```c++
sort(box+1, box+n+1, [&](node a, node b){
		if(a.l!=b.l){
			return a.l<b.l;   
		}
		if(a.w!=b.w){
			return a.w<b.w;
		}
		return a.h<b.h;
        }
    );
```
- 前两个参数表示对从box[1]到box[n]（左闭右开区间，实际包含box[1]到box[n]）的元素进行排序；
- 第三个参数是一个 lambda 表达式，定义了排序的比较规则：
    - [&]表示按引用捕获外部变量；
    - 参数a和b是node类型的对象，代表要比较的两个元素；
    - 比较逻辑采用优先级排序：先比较l，l相等再比较w，前两者都相等最后比较h；