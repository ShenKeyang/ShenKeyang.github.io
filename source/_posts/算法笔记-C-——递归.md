---
title: 算法笔记(C++) ——递归
date: 2025-08-25 18:16:14
tags:
---


## 递归的概念
递归是一种函数调用自己的编程技巧。递归的基本思想是将一个复杂的问题分解为更简单的子问题，直到子问题的规模足够小，能够直接解决。递归通常由两个部分组成：
1. 终止条件：递归的终止条件，防止无限递归。
2. 递归调用：将当前问题转化为更小规模的同类问题，并在其上进行求解。  

__示例：__
```c++
#include <iostream>
using namespace std;

// 递归函数计算斐波那契数列
int fibonacci(int n) 
{
    if (n == 0) return 0; // 斐波那契数列的第0项
    if (n == 1) return 1; // 斐波那契数列的第1项
    return fibonacci(n - 1) + fibonacci(n - 2); // 递归计算F(n)
}

int main() 
{
    int n;
    cin >> n; // 输入整数n
    cout << fibonacci(n) << endl; // 输出斐波那契数列的第n项
    return 0;
}
```
  
<br><br>






## 树以及二叉树的概念
1. 树（Tree）：  
树是一种由节点（Node）组成的非线性数据结构，其中的每个节点可以有零个或多个子节点。树通常用来表示层次结构的数据关系，比如文件系统、家谱等。    
`根节点（Root）`：树中的第一个节点，根节点没有父节点。  
`父节点（Parent）`：一个节点的直接上级节点。  
`子节点（Child）`：一个节点的直接下级节点。  
`叶子节点（Leaf）`：没有任何子节点的节点。  
`深度（Depth）`：从根节点到当前节点的路径长度。  
`高度（Height）`：从当前节点到叶子节点的最长路径长度。  
`度（Degree）`：节点的子节点数目。

- 树的常见类型有：  
    - 二叉树：每个节点最多有两个子节点。
    -  平衡树：比如AVL树，二叉搜索树（BST）等，它们有一些特定的规则来保证树的平衡性。  
<br>
2. 二叉树（Binary Tree）：  
二叉树是一种特殊的树结构，它的每个节点最多有两个子节点，通常称为左子节点和右子节点。二叉树是最常见的一种树结构，广泛应用于各种算法和数据结构中。  

- 二叉树的性质：  
    1. 每个节点最多有两个子节点。  
    2. 每个节点有两个指针，一个指向左子节点，另一个指向右子节点。  

- 二叉树的类型：  
    1. 满二叉树：所有的非叶子节点都有两个子节点，且所有叶子节点都在同一层。  
    2. 完全二叉树：除了最后一层外，其他每一层的节点都达到最大节点数，且最后一层的节点从左到右连续排列。  
    3. 二叉搜索树（BST）：对于每一个节点，其左子树的所有节点值都小于该节点的值，右子树的所有节点值都大于该节点的值。  
    4. 平衡二叉树（AVL树、红黑树）：为了保持高效的查询、插入和删除操作，这些树会自动保持平衡，即左右子树的高度差不超过某个阈值。  

- 二叉树的遍历：  
    1. 前序遍历（Pre-order）：访问根节点，再访问左子树，最后访问右子树。
    2. 中序遍历（In-order）：访问左子树，再访问根节点，最后访问右子树。 
    3. 后序遍历（Post-order）：访问左子树，再访问右子树，最后访问根节点。
    4. 层序遍历（Level-order）：从上到下、从左到右按层次遍历。  

  
<br><br>







## 完全二叉树
完全二叉树是一种特殊的二叉树，它具有以下特点：
1. 每一层节点都要填满：除了最后一层外，完全二叉树的每一层都必须是满的，也就是说，除了最底层，其他层的节点数都达到最大值。  
2. 最后一层的节点尽量靠左：最后一层的节点从左到右依次排列，不能有空缺。也就是说，最后一层的节点虽然可以不满，但必须尽量靠左对齐。  

完全二叉树的一个重要特点是，它是非常紧凑的结构，不像普通二叉树那样可能会出现大量的空白位置。由于这一特性，完全二叉树通常用于堆数据结构（例如最大堆或最小堆）中，因为在这种树形结构下，插入和删除节点的操作效率较高。

举例说明：  
假设有7个节点，它们按顺序排列构建成完全二叉树，结果如下：
```
        1
      /   \
     2     3
    / \   / 
   4   5 6   
```
1. 这棵树的第1层有1个节点，第2层有2个节点，第3层有3个节点。
2. 最后一层的节点是从左到右依次排列的，没有空缺。  

  
<br><br>








## 例题：路径统计
- 题目描述：
给定一个大小为 n * n 的二维网格。你从坐标 (sx, sy) 出发，允许你每次移动到上下左右四个方向之一。每次移动的步数记为 1 步。现在给定一个目标坐标 (ex, ey)，请问在最多  k  步以内，你可以到达目标位置 (ex, ey) 的不同路径数。  
请注意，你可以在任何时刻选择停止，不一定要在刚好  k  步时到达目标。
- 输入：
    - 第一行输入一个整数  n ，表示网格的大小（ 1 \leq n \leq 10 ）。
    - 第二行输入四个整数  sx, sy, ex, ey ，表示起点 (sx, sy) 和终点 (ex, ey) 的坐标。
    - 第三行输入一个整数  k ，表示最多的步数（ 1 \leq k \leq 10 ）。
- 输出：  
    - 输出一个整数，表示在最多  k  步以内从 (sx, sy) 到达 (ex, ey) 的不同路径数。

- 题解代码：
```c++
#include <bits/stdc++.h>
using namespace std;

int n, sx, sy, ex, ey, k;
long long countPaths = 0;

  // 四个方向：上，下，左，右
int dx[4] = {0, 0, -1, 1};
int dy[4] = {-1, 1, 0, 0};

// 递归函数，当前坐标 (x, y)，已经走的步数 steps
void dfs(int x, int y, int steps) 
{
    // 如果当前坐标是终点，则计数加一
    if (x == ex && y == ey) 
    {
        countPaths++;
        // 注意：即使达到终点，也可以选择继续移动，直到步数达到 k
        // 所以不在此处 return
    }

    // 如果已经达到最大步数，停止递归
    if (steps == k)  return;

    // 尝试四个方向移动
    for(int dir = 0; dir < 4; dir++) {
        int newX = x + dx[dir];
        int newY = y + dy[dir];
        // 检查新位置是否在网格内
        if(newX >= 1 && newX <= n && newY >=1 && newY <=n) 
        {
            dfs(newX, newY, steps + 1);
        }
    }
}

int main()
{
    cin >> n;
    cin >> sx >> sy >> ex >> ey;
    cin >> k;
    
    dfs(sx, sy, 0);
    
    cout << countPaths;

    return 0;
}
```