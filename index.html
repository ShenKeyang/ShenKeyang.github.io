<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>YOLO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="YOLO的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="YOLO">
<meta property="og:url" content="https://shenkeyang.github.io/index.html">
<meta property="og:site_name" content="YOLO">
<meta property="og:description" content="YOLO的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ShenKeyang">
<meta property="article:tag" content="sky">
<meta property="article:tag" content="shenkeyang">
<meta property="article:tag" content="YOLO">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="YOLO" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">YOLO</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">You Only Live Once.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shenkeyang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Python-——基本数据类型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2025-09-28T09:49:20.000Z" itemprop="datePublished">2025-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Python ——基本数据类型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p>
<p>等号（&#x3D;）用来给变量赋值。</p>
<p>等号（&#x3D;）运算符左边是一个变量名,等号（&#x3D;）运算符右边是存储在变量中的值。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">100</span>          <span class="comment"># 整型变量</span></span><br><span class="line">miles   = <span class="number">1000.0</span>       <span class="comment"># 浮点型变量</span></span><br><span class="line">name    = <span class="string">&quot;nowcoder&quot;</span>     <span class="comment"># 字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (counter)</span><br><span class="line"><span class="built_in">print</span> (miles)</span><br><span class="line"><span class="built_in">print</span> (name)</span><br></pre></td></tr></table></figure>
<p>执行以上程序会输出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">1000.0</span><br><span class="line">nowcoder</span><br></pre></td></tr></table></figure>

<h2 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h2><p>Python允许你同时为多个变量赋值。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。</p>
<p>也可以为多个对象指定多个变量。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;nowcoder&quot;</span></span><br></pre></td></tr></table></figure>
<p>以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “nowcoder” 分配给变量 c。</p>
<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>Tuple（元组）</li>
<li>List（列表）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<p>Python3 的六个标准数据类型中：</p>
<ul>
<li>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</li>
<li>可变数据（3 个）：List（列表）、Set（集合）、Dictionary（字典）。</li>
</ul>
<h2 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h2><p>Python3 支持 int、float、bool、complex（复数）。</p>
<p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p>
<p>像大多数语言一样，数值类型的赋值和计算都是很直观的。</p>
<p>内置的 type() 函数可以用来查询变量所指的对象类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j</span><br><span class="line">&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))</span><br><span class="line">&lt;class &#x27;int&#x27;&gt; &lt;class &#x27;float&#x27;&gt; &lt;class &#x27;bool&#x27;&gt; &lt;class &#x27;complex&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>此外还可以用 isinstance 来判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = 111</span><br><span class="line">&gt;&gt;&gt; isinstance(a, int)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>isinstance 和 type 的区别在于：</p>
<ul>
<li>type()不会认为子类是一种父类类型。</li>
<li>isinstance()会认为子类是一种父类类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B(A):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; isinstance(A(), A)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(A()) == A</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(B(), A)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(B()) == A</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>当指定一个值时，Number 对象就会被创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 = 1</span><br><span class="line">var2 = 10</span><br></pre></td></tr></table></figure>
<p>也可以使用del语句删除一些对象引用。</p>
<p>del语句的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del var1[,var2[,var3[....,varN]]]</span><br></pre></td></tr></table></figure>
<p>可以通过使用del语句删除单个或多个对象。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del var</span><br><span class="line">del var_a, var_b</span><br></pre></td></tr></table></figure>

<h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;5 + 4  # 加法</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; 4.3 - 2 # 减法</span><br><span class="line">2.3</span><br><span class="line">&gt;&gt;&gt; 3 * 7  # 乘法</span><br><span class="line">21</span><br><span class="line">&gt;&gt;&gt; 2 / 4  # 除法，得到一个浮点数</span><br><span class="line">0.5</span><br><span class="line">&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 17 % 3 # 取余</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 2 ** 5 # 乘方</span><br><span class="line">32</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li><p>Python可以同时为多个变量赋值，如a, b &#x3D; 1, 2。</p>
</li>
<li><p>一个变量可以通过赋值指向不同类型的对象。</p>
</li>
<li><p>数值的除法包含两个运算符：&#x2F; 返回一个浮点数，&#x2F;&#x2F; 返回一个整数。</p>
</li>
<li><p>在混合计算时，Python会把整型转换成为浮点数。</p>
</li>
</ol>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>Python中的字符串用单引号 ‘ 或双引号 “ 括起来，同时使用反斜杠 \ 转义特殊字符。</p>
<p>字符串的截取的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br></pre></td></tr></table></figure>
<p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<p>加号 + 是字符串的连接符， 星号 ***** 表示复制当前字符串，紧跟的数字为复制的次数。实例如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Nowocder&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>)          <span class="comment"># 输出字符串</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])    <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">0</span>])       <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])     <span class="comment"># 输出从第三个开始到第五个的字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">2</span>:])      <span class="comment"># 输出从第三个开始的后的所有字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span> * <span class="number">2</span>)      <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span> + <span class="string">&quot;TEST&quot;</span>) <span class="comment"># 连接字符串</span></span><br></pre></td></tr></table></figure>
<p>执行以上程序会输出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Nowcoder</span><br><span class="line">Nowcode</span><br><span class="line">N</span><br><span class="line">wco</span><br><span class="line">wcoder</span><br><span class="line">NowcoderNowcoder</span><br><span class="line">NowcoderTEST</span><br></pre></td></tr></table></figure>
<p>Python 使用反斜杠()转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;Now\ncoder&#x27;)</span><br><span class="line">Now</span><br><span class="line">coder</span><br><span class="line">&gt;&gt;&gt; print(r&#x27;Now\ncoder&#x27;)</span><br><span class="line">Now\ncoder</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>另外，反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 “””…””” 或者 ‘’’…’’’ 跨越多行。</p>
<p>注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;word = &#x27;Python&#x27;</span><br><span class="line">&gt;&gt;&gt; print(word[0], word[5])</span><br><span class="line">P n</span><br><span class="line">&gt;&gt;&gt; print(word[-1], word[-6])</span><br><span class="line">n P</span><br></pre></td></tr></table></figure>
<p>与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] &#x3D; ‘m’会导致错误。</p>
<p>注意：</p>
<ol>
<li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</li>
<li>字符串可以用+运算符连接在一起，用*运算符重复。</li>
<li>Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li>
<li>Python中的字符串不能改变。</li>
</ol>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>List（列表） 是 Python 中使用最频繁的数据类型。</p>
<p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p>
<p>列表是写在方括号 [] 之间、用逗号分隔开的元素列表。</p>
<p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p>
<p>列表截取的语法格式如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量[头下标:尾下标+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<p>加号 + 是列表连接运算符，星号 ***** 是重复操作。如下实例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;nowcoder&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;nowcoder&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>)            <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">0</span>])         <span class="comment"># 输出列表第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>])       <span class="comment"># 从第二个开始输出到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">2</span>:])        <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinylist * <span class="number">2</span>)    <span class="comment"># 输出两次列表</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span> + tinylist) <span class="comment"># 连接列表</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;abcd&#x27;, 786, 2.23, &#x27;nowcoder&#x27;, 70.2]</span><br><span class="line">abcd</span><br><span class="line">[786, 2.23]</span><br><span class="line">[2.23, &#x27;nowcoder&#x27;, 70.2]</span><br><span class="line">[123, &#x27;nowcoder&#x27;, 123, &#x27;nowcoder&#x27;]</span><br><span class="line">[&#x27;abcd&#x27;, 786, 2.23, &#x27;nowcoder&#x27;, 70.2, 123, &#x27;nowcoder&#x27;]</span><br></pre></td></tr></table></figure>
<p>与Python字符串不一样的是，列表中的元素是可以改变的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; a[0] = 9</span><br><span class="line">&gt;&gt;&gt; a[2:5] = [13, 14, 15]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[9, 2, 13, 14, 15, 6]</span><br><span class="line">&gt;&gt;&gt; a[2:5] = []   # 将对应的元素值设置为 []</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[9, 2, 6]</span><br></pre></td></tr></table></figure>
<p>List 内置了有很多方法，例如 append()、pop() 等等。</p>
<p>注意：</p>
<ol>
<li>List写在方括号之间，元素用逗号隔开。</li>
<li>和字符串一样，list可以被索引和切片。</li>
<li>List可以使用+操作符进行拼接。</li>
<li>List中的元素是可以改变的。</li>
</ol>
<p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串.</p>
<p>如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4], </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重新组合字符串</span></span><br><span class="line">    output = <span class="string">&#x27; &#x27;</span>.join(inputWords)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">input</span> = <span class="string">&#x27;I like nowcoder&#x27;</span></span><br><span class="line">    rw = reverseWords(<span class="built_in">input</span>)</span><br><span class="line">    <span class="built_in">print</span>(rw)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nowcoder like I</span><br></pre></td></tr></table></figure>

<h2 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h2><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。</p>
<p>元组中的元素类型也可以不相同：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;nowcoder&#x27;</span>, <span class="number">70.2</span>  )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;nowcoder&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>)             <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">0</span>])          <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>])        <span class="comment"># 输出从第二个元素开始到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">2</span>:])         <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinytuple * <span class="number">2</span>)     <span class="comment"># 输出两次元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span> + tinytuple) <span class="comment"># 连接元组</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;abcd&#x27;, 786, 2.23, &#x27;nowcoder&#x27;, 70.2)</span><br><span class="line">abcd</span><br><span class="line">(786, 2.23)</span><br><span class="line">(2.23, &#x27;nowcoder&#x27;, 70.2)</span><br><span class="line">(123, &#x27;nowcoder&#x27;, 123, &#x27;nowcoder&#x27;)</span><br><span class="line">(&#x27;abcd&#x27;, 786, 2.23, &#x27;nowcoder&#x27;, 70.2, 123, &#x27;nowcoder&#x27;)</span><br></pre></td></tr></table></figure>
<p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。其实，可以把字符串看作一种特殊的元组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;tup = (1, 2, 3, 4, 5, 6)</span><br><span class="line">&gt;&gt;&gt; print(tup[0])</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(tup[1:5])</span><br><span class="line">(2, 3, 4, 5)</span><br><span class="line">&gt;&gt;&gt; tup[0] = 11  # 修改元组元素的操作是非法的</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure>
<p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p>
<p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()    # 空元组</span><br><span class="line">tup2 = (20,) # 一个元素，需要在元素后添加逗号</span><br><span class="line">string、list 和 tuple 都属于 sequence（序列）。</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>与字符串一样，元组的元素不能修改。</li>
<li>元组也可以被索引和切片，方法一样。</li>
<li>注意构造包含 0 或 1 个元素的元组的特殊语法规则。</li>
<li>元组也可以使用+操作符进行拼接。</li>
</ol>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p>
<p>基本功能是进行成员关系测试和删除重复元素。</p>
<p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
<p>创建格式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parame = &#123;value01,value02,...&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">set</span>(value)</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">student = &#123;<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jim&#x27;</span>, <span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(student)   <span class="comment"># 输出集合，重复的元素被自动去掉</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;Rose&#x27;</span> <span class="keyword">in</span> student :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Rose 在集合中&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Rose 不在集合中&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a - b)     <span class="comment"># a 和 b 的差集</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a | b)     <span class="comment"># a 和 b 的并集</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a &amp; b)     <span class="comment"># a 和 b 的交集</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a ^ b)     <span class="comment"># a 和 b 中不同时存在的元素</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;Mary&#x27;, &#x27;Jim&#x27;, &#x27;Rose&#x27;, &#x27;Jack&#x27;, &#x27;Tom&#x27;&#125;</span><br><span class="line">Rose 在集合中</span><br><span class="line">&#123;&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&#123;&#x27;b&#x27;, &#x27;d&#x27;, &#x27;r&#x27;&#125;</span><br><span class="line">&#123;&#x27;l&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;z&#x27;, &#x27;m&#x27;, &#x27;b&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;c&#x27;&#125;</span><br><span class="line">&#123;&#x27;l&#x27;, &#x27;r&#x27;, &#x27;z&#x27;, &#x27;m&#x27;, &#x27;b&#x27;, &#x27;d&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p>
<p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。</p>
<p>键(key)必须使用不可变类型。</p>
<p>在同一个字典中，键(key)必须是唯一的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;1 - 脚本&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>]     = <span class="string">&quot;2 - 工具&quot;</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;coder&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.coder.com&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])       <span class="comment"># 输出键为 &#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="number">2</span>])           <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> (tinydict)          <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.keys())   <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.values()) <span class="comment"># 输出所有值</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: &#x27;coder&#x27;, &#x27;code&#x27;: 1, &#x27;site&#x27;: &#x27;www.coder.com&#x27;&#125;</span><br><span class="line">dict_keys([&#x27;name&#x27;, &#x27;code&#x27;, &#x27;site&#x27;])</span><br><span class="line">dict_values([&#x27;coder&#x27;, 1, &#x27;www.coder.com&#x27;])</span><br></pre></td></tr></table></figure>
<p>构造函数 dict() 可以直接从键值对序列中构建字典如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;dict([(&#x27;coder&#x27;, 1), (&#x27;Google&#x27;, 2), (&#x27;Taobao&#x27;, 3)])</span><br><span class="line">&#123;&#x27;Taobao&#x27;: 3, &#x27;coder&#x27;: 1, &#x27;Google&#x27;: 2&#125;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;</span><br><span class="line">&#123;2: 4, 4: 16, 6: 36&#125;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; dict(coder=1, Google=2, Taobao=3)</span><br><span class="line">&#123;&#x27;coder&#x27;: 1, &#x27;Google&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;</span><br></pre></td></tr></table></figure>
<p>另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。</p>
<p>注意：</p>
<ol>
<li>字典是一种映射类型，它的元素是键值对。</li>
<li>字典的关键字必须为不可变类型，且不能重复。</li>
<li>创建空字典使用 { }。</li>
</ol>
<h2 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    函数	                描述</span><br><span class="line">int(x [,base])	        将x转换为一个整数</span><br><span class="line">float(x)	            将x转换到一个浮点数</span><br><span class="line">complex(real [,imag])   创建一个复数</span><br><span class="line">str(x)	                将对象 x 转换为字符串</span><br><span class="line">repr(x)	                将对象 x 转换为表达式字符串</span><br><span class="line">eval(str)	            用来计算在字符串中的有效Python表达式,并返回一个对象</span><br><span class="line">tuple(s)	            将序列 s 转换为一个元组</span><br><span class="line">list(s)	                将序列 s 转换为一个列表</span><br><span class="line">set(s)	                转换为可变集合</span><br><span class="line">dict(d)	                创建一个字典。d 必须是一个 (key, value)元组序列。</span><br><span class="line">frozenset(s)	        转换为不可变集合</span><br><span class="line">chr(x)	                将一个整数转换为一个字符</span><br><span class="line">ord(x)	                将一个字符转换为它的整数值</span><br><span class="line">hex(x)	                将一个整数转换为一个十六进制字符串</span><br><span class="line">oct(x)	                将一个整数转换为一个八进制字符串</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" data-id="cmg3qqgc80001nw96bbfx4axl" data-title="Python ——基本数据类型" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Python-——基础语法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-09-28T09:04:43.000Z" itemprop="datePublished">2025-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Python ——基础语法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp-1252 -*-</span></span><br></pre></td></tr></table></figure>
<p>上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码，对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>第一个字符必须是字母表中字母或下划线 _ 。<br>标识符的其他的部分由字母、数字和下划线组成。<br>标识符对大小写敏感。<br>在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。  </p>
<h2 id="python保留字"><a href="#python保留字" class="headerlink" title="python保留字"></a>python保留字</h2><p>保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import keyword</span><br><span class="line">&gt;&gt;&gt; keyword.kwlist</span><br><span class="line">[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Python中单行注释以 # 开头，实例如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个注释</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Hello, Python!&quot;</span>) <span class="comment"># 第二个注释</span></span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Python!</span><br></pre></td></tr></table></figure>
<p>多行注释可以用多个 # 号，还有 ‘’’ 和 “””：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个注释</span></span><br><span class="line"><span class="comment"># 第二个注释</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第三注释</span></span><br><span class="line"><span class="string">第四注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">第五注释</span></span><br><span class="line"><span class="string">第六注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Hello, Python!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Python!</span><br></pre></td></tr></table></figure>

<h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。</p>
<p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;False&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>以下代码最后一行语句缩进数的空格数不一致，会导致运行错误：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span> (<span class="string">&quot;False&quot;</span>)    <span class="comment"># 缩进不一致，会导致运行错误</span></span><br></pre></td></tr></table></figure>
<p>以上程序由于缩进不一致，执行后会出现类似以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File &quot;test.py&quot;, line 6</span><br><span class="line">    print (&quot;False&quot;)    # 缩进不一致，会导致运行错误</span><br><span class="line">                                      ^</span><br><span class="line">IndentationError: unindent does not match any outer indentation level</span><br></pre></td></tr></table></figure>

<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure>
<p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠()，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h2><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p>
<ul>
<li>int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li>
<li>bool (布尔), 如 True。</li>
<li>float (浮点数), 如 1.23、3E-2</li>
<li>complex (复数), 如 1 + 2j、 1.1 + 2.2j</li>
</ul>
<h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h2><ul>
<li>python中单引号和双引号使用完全相同。</li>
<li>使用三引号(‘’’或”””)可以指定一个多行字符串。</li>
<li>转义符 ‘’</li>
<li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \n” 则\n会显示，并不是换行。</li>
<li>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</li>
<li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li>
<li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li>
<li>Python中的字符串不能改变。</li>
<li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li>
<li>字符串的截取的语法格式如下：变量[头下标:尾下标:步长]</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;字符串&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一个段落，</span></span><br><span class="line"><span class="string">可以由多行组成&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;Nowcoder&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)                 <span class="comment"># 输出字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])           <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])              <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])            <span class="comment"># 输出从第三个开始到第五个的字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])             <span class="comment"># 输出从第三个开始的后的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> * <span class="number">2</span>)             <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">&#x27;你好&#x27;</span>)        <span class="comment"># 连接字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello\nowcoder&#x27;</span>)      <span class="comment"># 使用反斜杠(\)+n转义特殊字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;hello\nowcoder&#x27;</span>)     <span class="comment"># 在字符串前面添加一个 r，表示原始字符串，不会发生转义</span></span><br></pre></td></tr></table></figure>
<p>这里的 r 指 raw，即 raw string。<br>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Nowcoder</span><br><span class="line">Nowcode</span><br><span class="line">N</span><br><span class="line">wco</span><br><span class="line">wcoder</span><br><span class="line">NowcoderNowcoder</span><br><span class="line">Nowcoder你好</span><br><span class="line">------------------------------</span><br><span class="line">hello</span><br><span class="line">nowcoder</span><br><span class="line">hello\nowcoder</span><br></pre></td></tr></table></figure>

<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p>空行也是程序代码的一部分。</p>
<h2 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h2><p>执行下面的程序在按回车键后就会等待用户输入：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&quot;\n\n按下 enter 键后退出。&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>以上代码中 ，”\n\n”在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。</p>
<h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;nowcoder&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用脚本执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nowcoder</span><br></pre></td></tr></table></figure>
<p>使用交互式命令行执行，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys; x = &#x27;nowcoder&#x27;; sys.stdout.write(x + &#x27;\n&#x27;)</span><br><span class="line">nowcoder</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>此处的 9 表示字符数。</p>
<h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p>
<p>我们将首行及后面的代码组称为一个子句(clause)。</p>
<p>如下实例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression :</span><br><span class="line">   suite</span><br><span class="line"><span class="keyword">elif</span> expression :</span><br><span class="line">   suite</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">   suite</span><br></pre></td></tr></table></figure>

<h2 id="Print-输出"><a href="#Print-输出" class="headerlink" title="Print 输出"></a>Print 输出</h2><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end&#x3D;””：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="string">&quot;a&quot;</span></span><br><span class="line">y=<span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment"># 换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x )</span><br><span class="line"><span class="built_in">print</span>( y )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------&#x27;</span>)</span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( y, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>以上实例执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">---------</span><br><span class="line">a b</span><br></pre></td></tr></table></figure>

<h2 id="import-与-from…import"><a href="#import-与-from…import" class="headerlink" title="import 与 from…import"></a>import 与 from…import</h2><p>在 python 用 import 或者 from…import 来导入相应的模块。</p>
<p>将整个模块(somemodule)导入，格式为： import somemodule</p>
<p>从某个模块中导入某个函数,格式为： from somemodule import somefunction</p>
<p>从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc</p>
<p>将某个模块中的全部函数导入，格式为： from somemodule import *</p>
<p><strong>导入 sys 模块</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;================Python import mode==========================&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;命令行参数为:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="built_in">print</span> (i)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n python 路径为&#x27;</span>,sys.path)</span><br></pre></td></tr></table></figure>
<p><strong>导入 sys 模块的 argv,path 成员</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv,path  <span class="comment">#  导入特定的成员</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;================python from import===================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;path:&#x27;</span>,path) <span class="comment"># 因为已经导入path成员，所以此处引用时不需要加sys.path</span></span><br></pre></td></tr></table></figure>

<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python -h</span><br><span class="line">usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...</span><br><span class="line">Options and arguments (and corresponding environment variables):</span><br><span class="line">-c cmd : program passed in as string (terminates option list)</span><br><span class="line">-d     : debug output from parser (also PYTHONDEBUG=x)</span><br><span class="line">-E     : ignore environment variables (such as PYTHONPATH)</span><br><span class="line">-h     : print this help message and exit</span><br><span class="line"> </span><br><span class="line">[ etc. ]</span><br></pre></td></tr></table></figure>
<p>我们在使用脚本形式执行 Python 时，可以接收命令行输入的参数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" data-id="cmg3qqgca0002nw96himufgwc" data-title="Python ——基础语法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——并查集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2025-09-23T08:58:49.000Z" itemprop="datePublished">2025-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86/">算法笔记(C++) ——并查集</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="并查集的概念"><a href="#并查集的概念" class="headerlink" title="并查集的概念"></a>并查集的概念</h2><p>并查集（Union-Find）是一种树型数据结构，它的作用是管理元素所属集合的数据结构，主要支持两种操作：</p>
<ul>
<li>合并（Union）：将两个不同的集合合并成一个集合。</li>
<li>查询（Find）：查询某个元素属于哪个集合。</li>
</ul>
<p>从代码实现来说：  </p>
<ul>
<li>并查集是一个森林，每一棵树是一个集合。</li>
<li>查询是找元素所在树的根节点。</li>
<li>合并是把一个树的根节点成为另一个树的根节点的子节点。</li>
</ul>
<br>



<h2 id="数据结构实现原理："><a href="#数据结构实现原理：" class="headerlink" title="数据结构实现原理："></a>数据结构实现原理：</h2><p>并查集通常使用数组实现：</p>
<ul>
<li>使用一个数组parent来表示每个元素的父节点。每个集合由一个代表（根节点）表示。</li>
<li>如果某个元素的父节点是自身（即parent[i] &#x3D; i），则该元素是集合的代表（根节点）。</li>
</ul>
<p>例如，初始情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">元素：1 2 3 4</span><br><span class="line">父亲：1 2 3 4</span><br></pre></td></tr></table></figure>

<br>



<h2 id="代码结合说明："><a href="#代码结合说明：" class="headerlink" title="代码结合说明："></a>代码结合说明：</h2><ol>
<li>初始化：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始parent数组为：[0, 1, 2, 3, 4,…] (下标0未用，元素1-4为独立集合)<br>2. 查找操作（路径压缩）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>路径压缩的作用：</strong><br>当查找某个节点的根节点时，直接将该节点挂在根节点下面，这样能减少后续查询的复杂度。<br>示例说明：<br>x → y 表示 parent[x] &#x3D; y<br>假设集合结构：1→2→3，此时查询1的根，路径压缩前是1→2→3，路径压缩后变为：<br>1 → 3<br>2 → 3<br>查询效率明显提升。<br>3. 合并操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> xRoot = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> yRoot = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (xRoot != yRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[xRoot] = yRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例说明：<br>假设集合结构：1→1，2→2，3→1，执行union(2,3)后集合变为：<br>1 → 1<br>2 → 1<br>3 → 1  </p>
<br>



<h2 id="并查集的优势和适用场景："><a href="#并查集的优势和适用场景：" class="headerlink" title="并查集的优势和适用场景："></a>并查集的优势和适用场景：</h2><ul>
<li><p>优势：</p>
<ul>
<li>路径压缩优化：在查询(find)过程中，让树的结构更加扁平化，大大提升了查询和合并的效率。</li>
<li>并查集的平均复杂度为O(log2 N)，性能优秀。</li>
</ul>
</li>
<li><p>适用场景：</p>
<ul>
<li>判断两个元素是否属于同一集合或群组（如好友关系、网络连接性等）。</li>
<li>动态计算图中联通块数量。</li>
<li>快速实现“分组”操作，如“好友圈”问题。</li>
</ul>
</li>
</ul>
<p><strong>并查集例题1：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">如题，现在有一个并查集，你需要完成合并和查询操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入格式：</span></span><br><span class="line"><span class="comment">第一行包含两个整数n,m表示共有 n 个元素和 m 个操作。接下来 m 行，每行包含三个整数 zi,xi,yi.</span></span><br><span class="line"><span class="comment">当 zi = 1 时，将 xi 与 yi 所在的集合合并。</span></span><br><span class="line"><span class="comment">当 zi = 2 时，输出 xi 与 yi 是否在同一集合内，是的输出Y，否则输出N。</span></span><br><span class="line"><span class="comment">（1&lt;=N,M&lt;=10^5）</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">输出格式：</span></span><br><span class="line"><span class="comment">对于每一个 zi =2 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找（路径压缩）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y))</span><br><span class="line">    &#123;</span><br><span class="line">        parent[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, z, x, y;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    parent.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; z &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (z == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unionSet</span>(x, y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y))</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Y\n&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;N\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>并查集例题2：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述</span></span><br><span class="line"><span class="comment">小红想要处理一批图片，将相似的图片分类。他首先对图片的特征采样，得到图片之间的相似度，然后按照以下规则判断</span></span><br><span class="line"><span class="comment">图片是否可以归为一类:</span></span><br><span class="line"><span class="comment">1.相似度&gt;0表示两张图片相似；</span></span><br><span class="line"><span class="comment">2.如果A和B相似，B和C相似，但A和C不相似。那么认为A和C间接相似，可以把ABC归为一类，但不计算AC的相似度；</span></span><br><span class="line"><span class="comment">3.如果A和所有其他图片都不相似，则A自己归为一类，相似度为0。给定一个大小为N×N的矩阵 M 存储任意两张图片的相</span></span><br><span class="line"><span class="comment">  似度，M[i][j]即为第i个图片和第j个图片的相似度，请按照&quot;从大到小&quot;的顺序返回每个相似类中所有图片的相似度之和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">第一行一个数N(1≤N≤900)，代表矩阵M中有N个图片。下面跟着N行，每行有N列数据，空格分隔，代表N个图片之间的相似度。</span></span><br><span class="line"><span class="comment">其中 0≤M[i][j]≤100，输入保证 M[i][j] = M[j][i]；</span></span><br><span class="line"><span class="comment">输入的矩阵分隔符为1个或多个连续空格。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">每个相似类的相似度之和。格式为:一行数字，分隔符为1个空格。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != parent[x])</span><br><span class="line">    &#123;</span><br><span class="line">        parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSet</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y))</span><br><span class="line">    &#123;</span><br><span class="line">        parent[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    parent.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">unionSet</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res[<span class="number">905</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 计算每个相似类的相似度之和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j= i ;j&lt;n;j++) <span class="comment">// 矩阵是对称的，只用得到半个矩阵</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j] &amp;&amp; <span class="built_in">find</span>(i)==<span class="built_in">find</span>(j))</span><br><span class="line">            &#123;</span><br><span class="line">                res[<span class="built_in">find</span>(i)]+=map[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(res<span class="number">+1</span>,res+n<span class="number">+1</span>);</span><br><span class="line">    <span class="comment">// 先排序，再倒序输出，遇到0则说明输出结束</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cout &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86/" data-id="cmg3qqgce000anw968ewx33ex" data-title="算法笔记(C++) ——并查集" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——贪心" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/" class="article-date">
  <time class="dt-published" datetime="2025-09-23T07:44:25.000Z" itemprop="datePublished">2025-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/">算法笔记(C++) ——贪心</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在解决一些优化问题时，我们通常需要找出最优解（例如：最大化、最小化）。而<code>贪心算法（Greedy Algorithm）</code>是一种常用的求解方法，它的基本思想是：在每一步选择中都采取<code>当前最优的选择</code>，以期得到全局的最优解。  </p>
<p><strong>具体来说，贪心算法有以下特点：</strong></p>
<ol>
<li>局部最优选择：在每个阶段或步骤中，选择当前最优的解决方案，通常是选择那个“最好”的选项。</li>
<li>不考虑全局情况：在每一步的决策中，贪心算法并不考虑未来的步骤，也不关心当前选择对后续的影响。它只专注于当前问题的最优解，而不是全局最优解。</li>
<li>贪心策略的正确性：有时候，贪心算法能给出最优解，但<code>并不是所有的优化问题都能通过贪心算法找到全局最优解</code>。在能通过贪心算法找到最优解的情况下，这种算法非常高效。</li>
</ol>
<p><strong>贪心正确性的证明：</strong></p>
<ol>
<li>交换法（Exchange Argument）：假设在某个最优解中，某些选择的顺序与贪心算法的选择顺序不一致。通过交换这些选择，证明交换后的解并不比原解差，或者至少能得到相同的最优解，从而证明贪心算法能得到全局最优解。</li>
<li>归纳法（Inductive Proof）：在贪心算法中，归纳法常用于证明每一步选择的局部最优性能够导致全局最优解。在归纳步骤中，我们假设贪心算法对于较小规模问题的正确性，然后证明它对较大规模问题也能成立。</li>
</ol>
<p><strong>贪心算法的实现步骤：</strong></p>
<ol>
<li>选择标准：确定每一步选择的标准，即选择当前最优的选项。</li>
<li>选择过程：通过选择当前的最优解，逐步逼近问题的全局最优解。</li>
<li>可行性检查：在选择过程中，要随时检查当前选择是否符合问题的约束条件。</li>
<li>问题的最终解：在所有步骤完成后，得出最终的解。</li>
</ol>
<p><strong>贪心算法例题1：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：有一堆商品，每个商品有一个重量和价值。你有一个背包，背包的最大承重为 C，你需要从商品中选择</span></span><br><span class="line"><span class="comment">一部分商品放入背包，使得总价值最大化。商品可以被分割，即你可以选择一部分商品放入背包。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入格式：</span></span><br><span class="line"><span class="comment">第一行包含两个整数 </span></span><br><span class="line"><span class="comment">n 和 C，分别表示商品的数量和背包的最大承重。(2&lt;=n&lt;=10^5),(1&lt;=C&lt;=10^5)接下来的n行，每行包含 2 个整数，</span></span><br><span class="line"><span class="comment">格式为 (w1,v1),(w2,v2),...,(wn,vn),其中 wi表示商品的重量，vi表示商品的价值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出格式：</span></span><br><span class="line"><span class="comment">输出一个浮点值，表示背包中放入商品后能得到的最大价值。结果保留 2 位小数。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span>&#123; <span class="comment">// 定义结构体存储每件商品的重量、价值、价重比</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">double</span> ratio;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> Item &amp;a, <span class="type">const</span> Item &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// 为后续的依照价重比降序排序作准备</span></span><br><span class="line">    <span class="keyword">return</span> a.ratio &gt; b.ratio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> c, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; &amp;items)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Item&gt; itemsWithRatio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> weight = items[i].first;</span><br><span class="line">        <span class="type">int</span> value = items[i].second;</span><br><span class="line">        <span class="type">double</span> ratio = (<span class="type">double</span>)value / weight;</span><br><span class="line">        itemsWithRatio.<span class="built_in">push_back</span>(&#123;weight, value, ratio&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按照价重比降序排序（用到第三个参数，自定义排序办法）</span></span><br><span class="line">    <span class="built_in">sort</span>(itemsWithRatio.<span class="built_in">begin</span>(),itemsWithRatio.<span class="built_in">end</span>(),compare);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> totalValue = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> remainingCapacity = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;item : itemsWithRatio)</span><br><span class="line">    &#123;   <span class="comment">// 贪心：每次选取当前未装入背包的商品中价重比最高的</span></span><br><span class="line">        <span class="keyword">if</span>(remainingCapacity == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item.weight &lt;= remainingCapacity)</span><br><span class="line">        &#123;   <span class="comment">// 商品能完全放入背包</span></span><br><span class="line">            totalValue += item.value;</span><br><span class="line">            remainingCapacity -= item.weight;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 注意本题中提到“商品可分割”，可以部分放入，到最后背包肯定是满的</span></span><br><span class="line">            totalValue += item.value * ((<span class="type">double</span>)remainingCapacity / item.weight);</span><br><span class="line">            remainingCapacity = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> totalValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">items</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; items[i].first &gt;&gt; items[i].second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> res = <span class="built_in">func</span>(n,c,items);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依照题目要求格式化输出</span></span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>贪心算法例题2：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目内容：</span></span><br><span class="line"><span class="comment">小塔正在给自己的物品贴标签。她一共有m种不同的标签，每种标签只有一个。 对于第i个物品，如果贴上ai号标签，</span></span><br><span class="line"><span class="comment">那么它的美观值为bi;如果没有贴上ai号标签，则其美观值为ci。小美想知道在合理的分配下，所有物品的美观值之</span></span><br><span class="line"><span class="comment">和最大为多少。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">第一行输入两个整数n和m代表小美的物品个数和标签种类。第二行输入n个整数ai代表每个物品适合的标签种类. 第</span></span><br><span class="line"><span class="comment">三行输入n个整数bi代表每个物品贴上适合的标签后的美观值。第四行输入n个整数ci代表每个物品未贴上适合标签时</span></span><br><span class="line"><span class="comment">的美观值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">在一行上输出一个整数，代表所有物品美观值之和的最大值。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*思路：</span></span><br><span class="line"><span class="comment">1.标签分配：我们首先将物品根据它们适合的标签进行分组，记录每个标签所对应的物品索引。</span></span><br><span class="line"><span class="comment">2.优先选择贴标签：对于每个标签所对应的物品，优先选择能够带来更高美观值的物品贴标签。如果物品不能贴标签，</span></span><br><span class="line"><span class="comment">  就选择不贴标签的美观值。</span></span><br><span class="line"><span class="comment">3.排序策略：每个标签所对应的物品排序时，应该根据 bi - ci（即贴上标签和不贴标签的美观值差）来排序。这样</span></span><br><span class="line"><span class="comment">  可以优先选择那些能够通过贴标签获得更大美观值的物品。*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">greedy</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">idx</span>(m<span class="number">+1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        idx[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll total_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; lst : idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lst.<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sorted_lst = lst;</span><br><span class="line">        <span class="built_in">sort</span>(sorted_lst.<span class="built_in">begin</span>(), sorted_lst.<span class="built_in">end</span>(), [&amp;c, &amp;b](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">                <span class="keyword">return</span> b[x] - c[x] &gt; b[y] - c[y];</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        total_value += <span class="built_in">max</span>(b[sorted_lst[<span class="number">0</span>]], c[sorted_lst[<span class="number">0</span>]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; sorted_lst.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            total_value += c[sorted_lst[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="built_in">greedy</span>(n, m, a, b, c);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/" data-id="cmg3qqgcg000enw963z3t70cr" data-title="算法笔记(C++) ——贪心" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——动态规划" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="article-date">
  <time class="dt-published" datetime="2025-09-21T16:03:16.000Z" itemprop="datePublished">2025-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">算法笔记(C++) ——动态规划</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>动态规划（Dynamic Programming，简称 DP）是一种有效的算法设计思想，用于解决具有<code>最优子结构</code>和<code>重叠子问题</code>的复杂问题。其核心思想是通过<code>记录已解决子问题的结果</code>来避免重复计算，从而优化效率。关键在于<code>定义问题的状态和状态转移方程</code>。<br>​以下是一道关于DP的简单例题，并通过集合视角一步步推导状态和转移方程的详细过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">小明正在爬楼梯。楼梯总共有n级台阶，小明每次可以选择爬1级或2级台阶。请问小明爬到第n级台阶的不同方法有多少种。</span><br><span class="line">注意：假设小明从地面（第 0 级台阶）开始爬楼梯，每次可以从当前台阶选择爬1级或2级台阶，直到到达第n级台阶。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">输入一个整数 n（1 ≤ n ≤ 40），表示楼梯的总级数。</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">输出一个整数，表示爬到第 n 级台阶的不同方法数。</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>讨论 n &#x3D; 4 的情况：</strong><br>对于 (n &#x3D; 4)，所有可能的爬楼方式如下(5种)：<ul>
<li>0→1→2→3→4</li>
<li>0→1→2→4</li>
<li>0→1→3→4</li>
<li>0→2→3→4</li>
<li>0→2→4<br>将这些方案的集合定义为 D4 ，那么集合的大小∣D4∣&#x3D;5 就是问题的答案。</li>
</ul>
</li>
<li><strong>情况分类：</strong><br>考虑到达第 4 级楼梯的方式，可以从两种途径到达：<ul>
<li>最后一步从第 3 级到达第 4 级，即 3→4；</li>
<li>最后一步从第 2 级到达第 4 级，即 2→4；<br>根据这两种情况，我们可以将集合 D4 分为两部分:<br><img src="/images/cpp_11_1.png" alt=" "></li>
</ul>
</li>
<li><strong>等价映射：</strong><br>从集合划分可以观察到：  <ul>
<li>将上图中的第一个式子中最后的(4)去掉，得到的方案等价于从(0)到(3)的所有方案，即1式等价于D3；  </li>
<li>将上图中的第二个式子中最后的(4)去掉，得到的方案等价于从(0)到(2)的所有方案，即1式等价于D2；</li>
</ul>
</li>
<li><strong>递推方程:</strong><br>通过上述分析，可以得出递推关系：  <ul>
<li><strong>|D4| &#x3D; |D2| + |D3|</strong></li>
</ul>
</li>
<li><strong>推广情况:</strong><br>我们可以用相同的思路分析任意 (n)：<br>要到达第 n 级楼梯，最后一步只能是从 n−1 或 n−2 到达。因此，所有从 0 到 n 的方案可以表示为：  <ul>
<li><strong>|D_n| &#x3D; |D_n-1| + |D_n-2|</strong><br>这就是爬楼梯问题的<code>核心状态转移方程</code>。</li>
</ul>
</li>
<li><strong>边界条件：</strong><br>在动态规划中，需要明确边界条件来初始化状态转移：<ul>
<li>从 (0) 到 (1) 的方案：只能 0→1，因此：∣D1∣&#x3D;1;</li>
<li>从 (0) 到 (2) 的方案：可以是 0→1→2或0→2，因此：∣D2∣&#x3D;2;</li>
</ul>
</li>
<li><strong>总结：</strong>  <ul>
<li>状态定义：D_n为从第 (0) 级楼梯到第 (n) 级楼梯的所有方案数。</li>
<li>状态转移方程：|D_n| &#x3D; |D_n-1| + |D_n-2|；</li>
<li>边界条件：∣D1∣&#x3D;1 ，∣D2∣&#x3D;2;<br>通过上述递推公式，可以高效地计算任意 (n) 的爬楼方案数。</li>
</ul>
</li>
</ol>
<p><strong>上述例题的代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里第 i 个元素对应第 i+1 级台阶</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; D[n];</span><br><span class="line"></span><br><span class="line">    D[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    D[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        D[i] = D[i<span class="number">-1</span>] + D[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; D[n<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>DP例题2 （二维状态转移）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述</span></span><br><span class="line"><span class="comment">给定一个大小为 n×n 的二维矩阵，计算从起点 (1,1) 到终点 (n,n) 的所有可能路径的数量。</span></span><br><span class="line"><span class="comment">每一步可以向右或向下移动一个格子。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">输入包含一个整数 n，表示矩阵的大小。 1&lt;=n&lt;=17</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">输出一个整数，表示从 (1,1) 到 (n,n) 的路径总数。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*思路：</span></span><br><span class="line"><span class="comment">1.状态定义：dp[i][j]表示从起点 (0,0) 到达位置 (i,j) 的路径总数;</span></span><br><span class="line"><span class="comment">2.状态转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1];</span></span><br><span class="line"><span class="comment">3.边界条件：dp[0][0] = 1 ，dp[i][0] = 1 ，dp[0][j] = 1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果不是起点 (0, 0)，则计算当前点的路径数</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>) dp[i][j]+=dp[i - <span class="number">1</span>][j];<span class="comment">//从上方来（前提不是第一行）</span></span><br><span class="line">            <span class="keyword">if</span> (j&gt;<span class="number">0</span>) dp[i][j]+=dp[i][j - <span class="number">1</span>];<span class="comment">//从左方来（前提不是第一列）</span></span><br><span class="line">            <span class="comment">// 若既不是第一行，也不是第一列，则dp[i][j]=dp[i-1][j]+dp[i][j-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>DP例题3：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目内容：</span></span><br><span class="line"><span class="comment">圣诞节到了，小塔的妈妈准备了很多圣诞礼盒，礼盒大小不同，小塔在玩堆盒子的游戏，妈妈问小塔，怎么堆</span></span><br><span class="line"><span class="comment">盒子使得堆出的高度最高，每个礼盒的大小由长、宽、高表示，堆盒子的时候要求下面的盒子长、宽、高都必</span></span><br><span class="line"><span class="comment">须大于上面的盒子，不包含等于。请你帮助小塔一起堆出最高的一堆礼盒，高度为堆出的礼盒的所有高度的总和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">输入的第一行是礼盒的个数N，接下来输入N行，每行表示每个礼盒的长、宽、高。</span></span><br><span class="line"><span class="comment">礼盒的数量不超过1000个，每个盒子的长、宽、高取值范围为1~10。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">输出一行，输出能堆出盒子的最高高度*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*思路：</span></span><br><span class="line"><span class="comment">1.排序：首先，将所有盒子按照长、宽、高三个维度进行从小到大的排序。由于后面的盒子在长、宽、高方面</span></span><br><span class="line"><span class="comment">  都大于前面的盒子，因此可以确保后一个盒子不会被放在前一个盒子上面，从而简化了问题。</span></span><br><span class="line"><span class="comment">2.动态规划：接下来，使用动态规划来解决问题。定义 dp[i] 表示以第 i 个盒子为底部盒子时，所能达到的</span></span><br><span class="line"><span class="comment">  最大堆叠高度。我们需要考虑所有之前的盒子，如果一个盒子可以放在另一个盒子上面，就更新 dp[i] 的值。</span></span><br><span class="line"><span class="comment">3.结果计算：最终，结果为所有 dp[i] 中的最大值，即为我们能够堆叠的最高高度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l, w, h;</span><br><span class="line">&#125;box[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">    	cin&gt;&gt;box[i].l&gt;&gt;box[i].w&gt;&gt;box[i].h;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长、宽、高的三个优先级进行从小到大的排序</span></span><br><span class="line">    <span class="built_in">sort</span>(box<span class="number">+1</span>, box+n<span class="number">+1</span>, [&amp;](node a, node b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.l!=b.l)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.l&lt;b.l;   </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a.w!=b.w)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[i]表示第i个盒子作为底部时所能达到的最大高度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=box[i].h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (box[i].h &gt; box[j].h &amp;&amp; box[i].l &gt; box[j].l &amp;&amp; box[i].w &gt; box[j].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+box[i].h); <span class="comment">//尝试匹配前面所有的“前最大高度”dp[j]，取最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong><br>如下所示，上述代码中的此部分是一种C++中使用sort函数对一个结构体数组（数组或容器）进行自定义排序，其形式为<code>sort(box+1, box+n+1, lambda);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(box<span class="number">+1</span>, box+n<span class="number">+1</span>, [&amp;](node a, node b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.l!=b.l)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.l&lt;b.l;   </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a.w!=b.w)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<ul>
<li>前两个参数表示对从box[1]到box[n]（左闭右开区间，实际包含box[1]到box[n]）的元素进行排序；</li>
<li>第三个参数是一个 lambda 表达式，定义了排序的比较规则：<ul>
<li>[&amp;]表示按引用捕获外部变量；</li>
<li>参数a和b是node类型的对象，代表要比较的两个元素；</li>
<li>比较逻辑采用优先级排序：先比较 l，l 相等再比较 w ，前两者都相等最后比较 h ；</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" data-id="cmg3qqgcc0005nw966hgfcuqi" data-title="算法笔记(C++) ——动态规划" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——广度优先搜索" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="article-date">
  <time class="dt-published" datetime="2025-09-20T08:36:45.000Z" itemprop="datePublished">2025-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">算法笔记(C++) ——广度优先搜索</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>广度优先搜索（Breadth-First Search，简称 BFS）是一种图或树的遍历或搜索算法。它从起始节点开始，首先访问所有相邻节点，然后对这些相邻节点的未访问邻居进行同样的操作，逐层向外扩展，直到遍历完所有节点或找到目标节点。BFS的特点就是：层次遍历（按照节点与起始节点的距离逐层遍历）与最短路径（在无权图中，BFS可以找到起始节点到目标节点的最短路径）  </p>
<p><strong>算法步骤：</strong></p>
<ol>
<li>初始化队列：创建一个空队列，用于存储待访问的节点。</li>
<li>起始节点入队：将起始节点入队。</li>
<li>循环以下操作，直到队列为空：<ul>
<li>从队列中出队一个节点作为当前节点，并标记它为已访问。</li>
<li>访问当前节点的所有未被访问的邻居节点：<ul>
<li>将这些邻居节点标记为已访问。</li>
<li>将这些邻居节点入队。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>队列的种类决定了BFS的使用范围，例如普通队列（先进先出）适用于层次遍历，优先队列（大根堆或小根堆）适用于最短路算法。以下先来看普通队列的BFS。</li>
</ul>
<p>如下所示的是一个BFS的简单例子，需要从节点1开始使用BFS标记整个图，我们通过图示来逐步拆解这个过程：  </p>
<ol>
<li>创建一个空的普通队列，把节点1作为起始节点，标记节点1，先让它进入队列。<br><img src="/images/cpp_10_1.png" alt=" ">  </li>
<li>接着开始执行BFS，从队列头部取出节点1，访问节点1的所有未被访问的邻居节点（2，3），然后将节点2和节点3入队，并标记它们。<br><img src="/images/cpp_10_2.png" alt=" ">  </li>
<li>从队列头部取出节点2，标记节点2，访问节点2的所有未被访问的邻居节点（4，5），然后将节点4和节点5入队，并标记它们。<br><img src="/images/cpp_10_3.png" alt=" ">  </li>
<li>重复上述步骤，直到队列为空，退出循环，到这里BFS就执行结束了。<br><img src="/images/cpp_10_4.png" alt=" "></li>
</ol>
<br>





<h2 id="队列queue的使用"><a href="#队列queue的使用" class="headerlink" title="队列queue的使用"></a>队列queue的使用</h2><p>C++ 中的 queue 是一个基于 FIFO（先进先出）原则的容器适配器。它通常用于需要按顺序处理元素的场景。queue 适配器是基于底层容器（通常是 deque 或 list）实现的，它提供了简单的接口来进行数据的插入和删除操作。</p>
<p><strong>基本使用：</strong><br>首先，需要包含头文件queue，然后可以通过以下几种基本操作来使用 queue。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">//必要头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的队列</span></span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作：push</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">10</span>);  <span class="comment">// 向队列中添加元素 10</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">20</span>);  <span class="comment">// 向队列中添加元素 20</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">30</span>);  <span class="comment">// 向队列中添加元素 30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队列大小: &quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看队列的前端元素：front</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队列头部元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作：pop</span></span><br><span class="line">    q.<span class="built_in">pop</span>();  <span class="comment">// 移除队列中的第一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次查看队列的前端元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;新的队列头部元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空：empty</span></span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;队列不为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用方法：</strong></p>
<ul>
<li>push(value)：将元素添加到队列的末尾。</li>
<li>pop()：移除队列的头部元素。</li>
<li>front()：获取队列的头部元素（但不移除它）。</li>
<li>back()：获取队列的尾部元素（但不移除它）。</li>
<li>size()：返回队列中元素的数量。</li>
<li>empty()：检查队列是否为空。</li>
</ul>
<p><strong>特点与注意事项：</strong></p>
<ul>
<li>queue 是一个容器适配器，只能进行插入和删除操作，不能随机访问元素。</li>
<li>queue 默认使用 deque 作为底层容器，因此具有高效的插入和删除操作，尤其是在队列两端。</li>
<li>不能通过下标访问队列中的元素，因为 queue 是一个先进先出（FIFO）结构。</li>
</ul>
<p><strong>队列实现BFS例题 1：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">给定一个二维矩阵，表示一个迷宫，其中 1 表示墙壁，0 表示可以通行的道路。你有两个点，起点和终点，问是否存在</span></span><br><span class="line"><span class="comment">一条从起点到终点的路径，使得你可以从起点走到终点。你可以上下左右四个方向移动，但不能穿过墙壁，也不能离开迷</span></span><br><span class="line"><span class="comment">宫范围。坐标以行和列表示，均从0开始，左上角坐标是 (0,0) ，右下角坐标是 (n-1,m-1) 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">第一行输入两个整数 n 和 m，表示迷宫的行数和列数(1≤n,m≤100)。</span></span><br><span class="line"><span class="comment">接下来 n 行，每行包含 m 个整数，表示迷宫的地图，其中 0 表示通路，1 表示墙壁。</span></span><br><span class="line"><span class="comment">最后输入两个整数 x_1, y_1 和 x_2, y_2，表示起点和终点的坐标。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">输出一个字符串，若从起点到终点存在路径，输出 &quot;YES&quot;，否则输出 &quot;NO&quot;。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">maze</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; maze[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查起点和终点是否在迷宫范围内，并且不是墙壁</span></span><br><span class="line">    <span class="keyword">if</span>(x1 &lt; <span class="number">0</span> || x1 &gt;= n || y1 &lt; <span class="number">0</span> || y1 &gt;= m || </span><br><span class="line">       x2 &lt; <span class="number">0</span> || x2 &gt;= n || y2 &lt; <span class="number">0</span> || y2 &gt;= m ||</span><br><span class="line">       maze[x1][y1] == <span class="number">1</span> || maze[x2][y2] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化访问数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 定义四个移动方向：左，右，上，下</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用队列进行BFS</span></span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x1, y1&#125;);</span><br><span class="line">    visited[x1][y1] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; current = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前点是终点，设置 found 为 true 并跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(current.first == x2 &amp;&amp; current.second == y2)</span><br><span class="line">        &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试四个方向移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> newX = current.first + dx[i];</span><br><span class="line">            <span class="type">int</span> newY = current.second + dy[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查新位置是否在迷宫范围内，且是通路，且未被访问过</span></span><br><span class="line">            <span class="keyword">if</span>(newX &gt;=<span class="number">0</span> &amp;&amp; newX &lt; n &amp;&amp; newY &gt;=<span class="number">0</span> &amp;&amp; newY &lt; m &amp;&amp;</span><br><span class="line">               maze[newX][newY] == <span class="number">0</span> &amp;&amp; !visited[newX][newY])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;newX, newY&#125;);</span><br><span class="line">                visited[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据是否找到终点输出结果</span></span><br><span class="line">    <span class="keyword">if</span>(found)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>队列实现BFS例题 2：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">给定一个无向图，该图通过邻接表的方式存储。请你使用广度优先搜索（BFS）算法计算该图的连通块数量。</span></span><br><span class="line"><span class="comment">在无向图中，一个连通块是指图中所有节点之间有路径相连的最大子图。你需要输出图中连通块的数量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">第一行包含两个整数 n 和 m（2≤n≤10^4 ，1≤m≤10^5 ），表示图中有 n 个节点和 m 条边。</span></span><br><span class="line"><span class="comment">接下来的 m 行，每行包含两个整数 u 和 v（1≤u,v≤n），表示存在一条从节点 u 到节点 v 的无向边。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">输出一个整数，表示图中连通块的数量。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        adj[u<span class="number">-1</span>].<span class="built_in">push_back</span>(v<span class="number">-1</span>);</span><br><span class="line">        adj[v<span class="number">-1</span>].<span class="built_in">push_back</span>(u<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> allvisited = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!allvisited)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            visited[cur]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;adj[cur].<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[adj[cur][i]]!=<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(adj[cur][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                allvisited=<span class="literal">false</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            allvisited=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>队列实现BFS例题 3：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目内容：</span></span><br><span class="line"><span class="comment">每天早晨，环卫工人需要处理各个小区的生活垃圾，每个小区的生活垃圾由一队坏卫工人负责运送到最近的垃圾回收站</span></span><br><span class="line"><span class="comment">进行处理，求将所有小区垃圾送到垃圾回收站的最小距离和.假设小区和垃圾回收站都在都在一个m行n列的区域矩阵上，</span></span><br><span class="line"><span class="comment">相邻点的距离为1，只能上下左右移动;其中0表示垃圾处理站，1表示小区，2表示空白区域，−1表示障碍区域不可通行。</span></span><br><span class="line"><span class="comment">区域内如果没有小区或者没有垃圾回收站，则最小距离和返回0。</span></span><br><span class="line"><span class="comment">无法到达垃圾回收站的小区不计入本次距离和中。</span></span><br><span class="line"><span class="comment">计算所有小区垃圾送到垃圾回收站的最小距离和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">第一行为两个数字m和n的和，表示区域矩阵的行数和列数，中间使用空格分隔，m和n的范围均为[1,300]。</span></span><br><span class="line"><span class="comment">接下来的m行表示一个m×n的区域矩阵数组，每行的元素间以空格分隔，其中元素取值仅为−1(障碍)、0(垃圾处理站)、</span></span><br><span class="line"><span class="comment">1(小区)、2(空白区域)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">一个整数，表示所计算的最小距离和。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> hasXiaoqu = <span class="literal">false</span>,hasLajizhan=<span class="literal">false</span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; xiaoqu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="comment">//判断是否有小区和垃圾站并记录小区</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>) hasLajizhan=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j]==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hasXiaoqu=<span class="literal">true</span>;</span><br><span class="line">                xiaoqu.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dx=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dy=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!hasLajizhan||!hasXiaoqu)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    queue&lt;pair&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt;&gt; q; <span class="comment">//定义队列，元素为坐标绑定步数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> xq : xiaoqu) <span class="comment">//每个小区各进行一轮BFS</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) <span class="comment">//把上一个小区所遗留的队列清空</span></span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;&#123;xq.first,xq.second&#125;,<span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> step=cur.second; <span class="comment">//步数迭代</span></span><br><span class="line">            visited[cur.first.first][cur.first.second]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map[cur.first.first][cur.first.second]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=step;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> newX = cur.first.first+dx[i];</span><br><span class="line">                <span class="type">int</span> newY = cur.first.second+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> </span><br><span class="line">                    &amp;&amp; newY &lt; n &amp;&amp; map[newX][newY]!=<span class="number">-1</span> </span><br><span class="line">                    &amp;&amp; visited[newX][newY]!=<span class="number">1</span>) <span class="comment">//不越界，不调头，不是墙</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;&#123;newX,newY&#125;,step<span class="number">+1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" data-id="cmg3qqgcf000bnw96335kcply" data-title="算法笔记(C++) ——广度优先搜索" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——深度优先搜索" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="article-date">
  <time class="dt-published" datetime="2025-09-10T14:06:32.000Z" itemprop="datePublished">2025-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">算法笔记(C++) ——深度优先搜索</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>深度优先搜索(Depth First Search , DFS)是一种用于遍历或搜索图（图可以是树、无向图、有向图等）的算法。它按照深度优先的策略，优先访问当前节点的下一层邻接节点，直到无法继续为止，再回溯到上一层。可以粗略的理解为：DFS就是在图上做特定的递归，DFS⊂递归。  </p>
<h2 id="树的存储和遍历"><a href="#树的存储和遍历" class="headerlink" title="树的存储和遍历"></a>树的存储和遍历</h2><p><strong>树的两种读入方式：</strong></p>
<ol>
<li>边形式:</li>
</ol>
<ul>
<li>存储：这种读入形式将树看成一张图进行读入，本质就是上一篇中的的读入形式，所以可以使用邻接表（记录对应节点的相邻节点信息的表格）直接存储。但特别要注意的是，虽然树在定义上是有向图，但有时读入的数据可能会不符合其定义。例如，树中的一条有向边从节点 1 指向节点 2，但在输入时可能会以 2 1 的形式读入，所以为了能够正确进行遍历，就需要使用无向图的存储方式(也就是对于读入进来的边，正反都存储一遍)。  </li>
<li>遍历:由于存储结构被迫变成了无向图(虽然它本应该是有向图的结构)，那么在递归遍历的时候(或者说在深度优先搜索的过程中)，我们需要注意由于返祖边的存在导致的无限递归（返祖边:假设树里存在一条从节点 1 指向节点 2的有向边1 2。那么1是2的父亲，也是2的祖先。但在实际的存储中又存在从2指向1的边2 1。那么2 1 就是一条返祖边）。<br>解决方法: 增加父亲参数father，禁止由子节点访问父节点。</li>
</ul>
<ol start="2">
<li>父亲数组：</li>
</ol>
<ul>
<li>存储：树中的每个节点都有唯一的父节点，这种唯一性使得我们可以通过数组来存储父节点信息。所以树可以用父亲数组（father[]）来表示树的结构。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：一棵简单的树  </span><br><span class="line"></span><br><span class="line">树的结构：</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">父亲数组表示：</span><br><span class="line">father[1] = 0  （根节点无父节点，约定为 0）</span><br><span class="line">father[2] = 1  （节点 2 的父亲是 1）</span><br><span class="line">father[3] = 1  （节点 3 的父亲是 1）</span><br><span class="line">father[4] = 3  （节点 4 的父亲是 3）</span><br><span class="line">father[5] = 3  （节点 5 的父亲是 3）</span><br><span class="line"></span><br><span class="line">父亲数组：father = [0, 1, 1, 3, 3]</span><br></pre></td></tr></table></figure>
<p>但由于我们访问的顺序是从父亲到儿子，而父亲数组存储的是每个儿子的父亲。所以我们无法直接利用父亲数组进行DFS。我们还是将父亲数组转化为邻接表进行存储：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adjList[father[i]].<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历：<br>在这种读入形式下，不再存在第一种形式所提及的无限递归问题。可以直接进行遍历。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">sort</span>(adjList[i].<span class="built_in">begin</span>(), adjList[i].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> parent)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	traversalResult.<span class="built_in">push_back</span>(node); <span class="comment">// 访问当前节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;child : adjList[node]) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span>(child != parent) </span><br><span class="line">        &#123; <span class="comment">// 避免回到父节点</span></span><br><span class="line">			<span class="built_in">DFS</span>(child, node); <span class="comment">// 递归访问子节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong><br><code>vector&lt;int&gt; matrix(MAX);</code>和<code>vector&lt;int&gt; arr[MAX];</code>的区别：<br>在 C++ 中，二者是两种完全不同的定义方式，核心区别在于数据结构的类型和用途：  </p>
<ul>
<li><code>vector&lt;int&gt; tree(MAX);</code><br>本质：定义一个单个 vector<int> 对象，其元素为int类型，并指定其初始大小为 MAX。<br>这个 vector 会预先分配能容纳 MAX 个 int 元素的内存，且每个元素会被默认初始化（int 类型默认值为 0）。<br>用途：需要一个初始大小固定的动态数组时使用，例如需要存储 MAX 个元素的序列。</li>
<li><code>vector&lt;int&gt; tree[MAX];</code><br>本质：定义一个数组，数组的每个元素都是一个 vector<int> 对象。<br>其中 MAX 是数组的大小（必须是编译期常量），表示这个数组包含 MAX 个 vector<int> 容器。<br>用途：通常用于表示邻接表（如树、图的存储），例如 tree[i] 表示第 i 个节点的所有邻接节点。</li>
</ul>
<br>





<h2 id="DFS的核心思想与实现方式"><a href="#DFS的核心思想与实现方式" class="headerlink" title="DFS的核心思想与实现方式"></a>DFS的核心思想与实现方式</h2><p><strong>核心思想：</strong>  </p>
<ul>
<li>DFS 的本质是 “不撞南墙不回头”，其关键在于 “回溯”（Backtracking）—— 当当前路径无法继续探索时，撤销上一步的选择，回到之前的状态并尝试新的可能性。可以用一个生活化的例子理解：假设你走进一个迷宫，面前有 3 条岔路（A、B、C）。DFS 会先选择岔路 A，一直走到尽头（可能是出口，也可能是死胡同）；如果是死胡同，就退回到岔路口，再选择岔路 B，重复探索；最后再探索岔路 C。整个过程中，“退回岔路口” 就是回溯，“走到底” 就是深度优先。</li>
</ul>
<p><strong>实现方式：</strong></p>
<ul>
<li>根据其“走到底”的特性，DFS可以看作是一种特殊的递归算法，同时树又是DFS的典型应用场景。以下是一道运用递归对树的各节点&#x2F;子树进行深度优先搜索的例题：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">有一棵有n个节点的树，根节点为1号节点，树的每个节点是红色或者黑色，想知道有多少节点的子树中同时包含红点和黑点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">第一行输入一个整数n表示节点数量</span></span><br><span class="line"><span class="comment">第二行输入一个长度为n的字符串s表示节点的颜色，第i个节点的颜色为si ，若si为&#x27;B&#x27;表示节点的颜色为黑色，若si为&#x27;R&#x27; </span></span><br><span class="line"><span class="comment">则表示节点的颜色为红色。 接下来n−1行，每行输入两个整数 u,v(1≤u,v≤n)表示树上的边.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">输出一个整数表示答案。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量邻接表、颜色信息向量、结果值</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; colors;</span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 标记当前子树是否包含红色和黑色</span></span><br><span class="line">    <span class="type">bool</span> hasRed = <span class="literal">false</span>, hasBlack = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (colors[node] == <span class="string">&#x27;R&#x27;</span>) hasRed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> hasBlack = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj[node]) <span class="comment">//遍历每一个孩子节点，探索每一种可能性（回溯）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (neighbor != parent) <span class="comment">//邻接表是无向的，应确保搜索的是子树而不是父节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">bool</span>&gt; child = <span class="built_in">dfs</span>(neighbor, node);</span><br><span class="line">            <span class="comment">//针对每一个孩子节点，递归调用进行深度优先搜索（DFS）</span></span><br><span class="line">            <span class="keyword">if</span>(child[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                hasRed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(child[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                hasBlack = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前子树既有红色又有黑色节点，则满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (hasRed &amp;&amp; hasBlack)</span><br><span class="line">    &#123;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;hasRed, hasBlack&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//根据输入的n对全局变量resize</span></span><br><span class="line">    colors.<span class="built_in">resize</span>(n);</span><br><span class="line">    adj.<span class="built_in">resize</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; colors[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        adj[u<span class="number">-1</span>].<span class="built_in">push_back</span>(v<span class="number">-1</span>); <span class="comment">//由于题目中的根节点是从1开始标号</span></span><br><span class="line">        adj[v<span class="number">-1</span>].<span class="built_in">push_back</span>(u<span class="number">-1</span>); <span class="comment">//故而实际代码中应先-1后再存入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" data-id="cmg3qqgcg000dnw96b9vb314n" data-title="算法笔记(C++) ——深度优先搜索" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——图的存储" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/" class="article-date">
  <time class="dt-published" datetime="2025-09-10T10:11:36.000Z" itemprop="datePublished">2025-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/">算法笔记(C++) ——图的存储</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul>
<li>稀疏图：边的数量远小于顶点数的平方。  </li>
<li>稠密图：边的数量接近顶点数的平方。  </li>
<li>有向图：边具有方向性。  </li>
<li>无向图：边没有方向，可以视作双向边。  </li>
<li>有权图与无权图：有权图的边具有权值，无权图的边没有权值。</li>
</ul>
<p><br><br></p>
<h2 id="邻接矩阵（Adjacency-Matrix）"><a href="#邻接矩阵（Adjacency-Matrix）" class="headerlink" title="邻接矩阵（Adjacency Matrix）"></a>邻接矩阵（Adjacency Matrix）</h2><p>邻接矩阵用一个二维数组表示图，matrix[i][j] 表示从顶点 i 到 j 的边的信息（例如 1 代表有边，0 代表无边），适用于稠密图。<br><img src="/images/cpp_8_1.png" alt=" ">  </p>
<p><strong>实现：</strong>  </p>
<ol>
<li>建表操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立一张具有n个节点的图，此时这张图没有任何一条边</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjMatrix</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>加边操作<br>有时，一张图的读入通常以给定若干条边u v w 的形式给出，其中u代表这条边的起点,v代表这条边的终点,w代表这条边的权值。如果不含w，则读入的是无权图。<br>对于邻接矩阵而言，需要了解如何对一张图进行加边操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    adjMatrix[u][v] = <span class="number">1</span>;</span><br><span class="line">    adjMatrix[v][u] = <span class="number">1</span>; <span class="comment">// 无向图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>输出邻接矩阵</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        cout &lt;&lt; (adjMatrix[i][j] ? <span class="string">&quot;有边&quot;</span> : <span class="string">&quot;无边&quot;</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h2 id="邻接表（Adjacency-List）"><a href="#邻接表（Adjacency-List）" class="headerlink" title="邻接表（Adjacency List）"></a>邻接表（Adjacency List）</h2><p>对于稀疏图，邻接表是一种更高效的存储方式，只存储实际存在的边，使用数组或 vector 存储每个顶点的邻居列表。<br><img src="/images/cpp_8_1.png" alt=" "> </p>
<p><strong>实现：</strong>  </p>
<ol>
<li>建表操作<br>使用结构体表示边信息，如果是无权图，可以直接使用 vector<int> adjList[n + 1]：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjList</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或定义边的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">adjList</span>(n + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>加边操作<br>无向图的加边操作：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    adjList[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">    adjList[v].<span class="built_in">push_back</span>(&#123;u, w&#125;); <span class="comment">// 无向图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>遍历操作<br>遍历邻接表的示例：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot; connects to &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> edge : adjList[u]) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; edge.to &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; edge.weight &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/" data-id="cmg3qqgcd0008nw96fytdbz41" data-title="算法笔记(C++) ——图的存储" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——双指针" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88/" class="article-date">
  <time class="dt-published" datetime="2025-08-31T13:37:05.000Z" itemprop="datePublished">2025-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88/">算法笔记(C++) ——双指针</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="双指针算法概述"><a href="#双指针算法概述" class="headerlink" title="双指针算法概述:"></a>双指针算法概述:</h2><p>双指针算法（双指针技术）是一种在处理线性数据结构（如数组、链表）时常用的算法策略。它通过同时使用两个指针，以不同的方式遍历数据结构，从而优化时间复杂度或简化问题的解决过程。双指针算法广泛应用于各种经典问题，如数组排序、链表操作、字符串处理等。  </p>
<ul>
<li>双指针的常见类型</li>
</ul>
<ol>
<li><p>快慢指针（快指针与慢指针）:  </p>
<ul>
<li>用途：常用于检测链表中的环、找到链表的中间节点等。</li>
<li>原理：设定两个指针，快指针一次移动两步，慢指针一次移动一步。如果链表中存在环，快指针最终会与慢指针相遇；如果不存在环，快指针会先到达链表末尾。</li>
</ul>
</li>
<li><p>左右指针（双端指针）:  </p>
<ul>
<li>用途：常用于处理有序数组中的问题，如两数之和、三数之和、四数之和等。</li>
<li>原理：设定一个指针指向数组的起始位置，另一个指针指向数组的末尾，根据当前指针对应的值与目标值的关系来移动指针，以缩小搜索范围。</li>
</ul>
</li>
<li><p>滑动窗口:  </p>
<ul>
<li>用途：用于解决字符串或数组中满足特定条件的子串或子数组问题，如最长不重复子串、最小覆盖子串等。</li>
<li>原理：通过维护一个“窗口”区间（左右边界通常由两个指针left和right表示），动态调整窗口的范围来高效地解决问题。窗口扩展：通常通过固定左指针left、右移（枚举）右指针right来扩大窗口，纳入新的元素；窗口收缩：当窗口内不满足条件时，通过固定右指针right、右移左指针left来缩小窗口，排除不需要的元素；动态调整：根据题目要求，动态调整窗口的大小和位置，直到找到满足条件的解。</li>
</ul>
</li>
</ol>
<p><br><br></p>
<h2 id="例题：互相嘲笑的两个人"><a href="#例题：互相嘲笑的两个人" class="headerlink" title="例题：互相嘲笑的两个人"></a>例题：互相嘲笑的两个人</h2><ul>
<li><p>题目描述：<br>小红和小堡正在玩一个游戏，每一关都有一个分数。如果某人某一关分数比上一关高，但另一个人这一关分数比上一关低，那么他就可以嘲笑对方。如果两个人这一关游戏的分数都比上一关多，则增量更多的可以嘲笑对方;如果两个人这一关游戏的分数都比上一关少，则减量更少的可以嘲笑对方。只有当他们的增量相同或者减量相同时，才不会互相嘲笑。<br>例如，假设小红第一关的分数为2，第二关的分数为8;小堡第一关的分数为5，第二关的分数为10，显然小红增加的比小堡多，那么小红就可以嘲笑小堡。<br>现在给定了小红和小堡每一关的分数，你可以选择一段连续的关卡，使得一段关卡中两个人都不会互相嘲笑，问最多可以选择多少个关卡。特别的一段连续关卡中的第一关两人不会互相嘲笑。</p>
</li>
<li><p>输入：</p>
<ul>
<li>第一行输入一个正整数n,代表关卡数。</li>
<li>第二行输入n个整数a_i,代表小红每一关的分数。</li>
<li>第三行输入n个整数b_i,代表小堡每一关的分数。</li>
</ul>
</li>
<li><p>输出：  </p>
<ul>
<li>输出可以选择最多的关卡数。</li>
</ul>
</li>
<li><p>题解代码：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>,<span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算差分数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diff_a</span><span class="params">(n - <span class="number">1</span>)</span>, <span class="title">diff_b</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        diff_a[i] = a[i + <span class="number">1</span>] - a[i];</span><br><span class="line">        diff_b[i] = b[i + <span class="number">1</span>] - b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = diff_a.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; m &amp;&amp; diff_a[r] == diff_b[r]) &#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算该区间的长度</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 左指针移动到右指针的位置，开始新的检查</span></span><br><span class="line">        l = r + <span class="number">1</span>;</span><br><span class="line">        r = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88/" data-id="cmg3qqgcc0006nw96bnvwclg4" data-title="算法笔记(C++) ——双指针" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——递归" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/" class="article-date">
  <time class="dt-published" datetime="2025-08-25T10:16:14.000Z" itemprop="datePublished">2025-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/">算法笔记(C++) ——递归</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h2><p>递归是一种函数调用自己的编程技巧。递归的基本思想是将一个复杂的问题分解为更简单的子问题，直到子问题的规模足够小，能够直接解决。递归通常由两个部分组成：</p>
<ol>
<li>终止条件：递归的终止条件，防止无限递归。</li>
<li>递归调用：将当前问题转化为更小规模的同类问题，并在其上进行求解。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数计算斐波那契数列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 斐波那契数列的第0项</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 斐波那契数列的第1项</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>); <span class="comment">// 递归计算F(n)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n; <span class="comment">// 输入整数n</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">fibonacci</span>(n) &lt;&lt; endl; <span class="comment">// 输出斐波那契数列的第n项</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h2 id="树以及二叉树的概念"><a href="#树以及二叉树的概念" class="headerlink" title="树以及二叉树的概念"></a>树以及二叉树的概念</h2><ol>
<li>树（Tree）：<br>树是一种由节点（Node）组成的非线性数据结构，其中的每个节点可以有零个或多个子节点。树通常用来表示层次结构的数据关系，比如文件系统、家谱等。<br><code>根节点（Root）</code>：树中的第一个节点，根节点没有父节点。<br><code>父节点（Parent）</code>：一个节点的直接上级节点。<br><code>子节点（Child）</code>：一个节点的直接下级节点。<br><code>叶子节点（Leaf）</code>：没有任何子节点的节点。<br><code>深度（Depth）</code>：从根节点到当前节点的路径长度。<br><code>高度（Height）</code>：从当前节点到叶子节点的最长路径长度。<br><code>度（Degree）</code>：节点的子节点数目。</li>
</ol>
<ul>
<li>树的常见类型有：  <ul>
<li>二叉树：每个节点最多有两个子节点。</li>
<li>平衡树：比如AVL树，二叉搜索树（BST）等，它们有一些特定的规则来保证树的平衡性。</li>
</ul>
</li>
</ul>
<br>
2. 二叉树（Binary Tree）：  
二叉树是一种特殊的树结构，它的每个节点最多有两个子节点，通常称为左子节点和右子节点。二叉树是最常见的一种树结构，广泛应用于各种算法和数据结构中。  

<ul>
<li><p>二叉树的性质：  </p>
<ol>
<li>每个节点最多有两个子节点。  </li>
<li>每个节点有两个指针，一个指向左子节点，另一个指向右子节点。</li>
</ol>
</li>
<li><p>二叉树的类型：  </p>
<ol>
<li>满二叉树：所有的非叶子节点都有两个子节点，且所有叶子节点都在同一层。  </li>
<li>完全二叉树：除了最后一层外，其他每一层的节点都达到最大节点数，且最后一层的节点从左到右连续排列。  </li>
<li>二叉搜索树（BST）：对于每一个节点，其左子树的所有节点值都小于该节点的值，右子树的所有节点值都大于该节点的值。  </li>
<li>平衡二叉树（AVL树、红黑树）：为了保持高效的查询、插入和删除操作，这些树会自动保持平衡，即左右子树的高度差不超过某个阈值。</li>
</ol>
</li>
<li><p>二叉树的遍历：  </p>
<ol>
<li>前序遍历（Pre-order）：访问根节点，再访问左子树，最后访问右子树。</li>
<li>中序遍历（In-order）：访问左子树，再访问根节点，最后访问右子树。 </li>
<li>后序遍历（Post-order）：访问左子树，再访问右子树，最后访问根节点。</li>
<li>层序遍历（Level-order）：从上到下、从左到右按层次遍历。</li>
</ol>
</li>
</ul>
<p><br><br></p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树是一种特殊的二叉树，它具有以下特点：</p>
<ol>
<li>每一层节点都要填满：除了最后一层外，完全二叉树的每一层都必须是满的，也就是说，除了最底层，其他层的节点数都达到最大值。  </li>
<li>最后一层的节点尽量靠左：最后一层的节点从左到右依次排列，不能有空缺。也就是说，最后一层的节点虽然可以不满，但必须尽量靠左对齐。</li>
</ol>
<p>完全二叉树的一个重要特点是，它是非常紧凑的结构，不像普通二叉树那样可能会出现大量的空白位置。由于这一特性，完全二叉树通常用于堆数据结构（例如最大堆或最小堆）中，因为在这种树形结构下，插入和删除节点的操作效率较高。</p>
<p>举例说明：<br>假设有7个节点，它们按顺序排列构建成完全二叉树，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   / </span><br><span class="line">4   5 6   </span><br></pre></td></tr></table></figure>
<ol>
<li>这棵树的第1层有1个节点，第2层有2个节点，第3层有3个节点。</li>
<li>最后一层的节点是从左到右依次排列的，没有空缺。</li>
</ol>
<p><br><br></p>
<h2 id="例题：路径统计"><a href="#例题：路径统计" class="headerlink" title="例题：路径统计"></a>例题：路径统计</h2><ul>
<li><p>题目描述：<br>给定一个大小为 n * n 的二维网格。你从坐标 (sx, sy) 出发，允许你每次移动到上下左右四个方向之一。每次移动的步数记为 1 步。现在给定一个目标坐标 (ex, ey)，请问在最多  k  步以内，你可以到达目标位置 (ex, ey) 的不同路径数。<br>请注意，你可以在任何时刻选择停止，不一定要在刚好  k  步时到达目标。</p>
</li>
<li><p>输入：</p>
<ul>
<li>第一行输入一个整数  n ，表示网格的大小（ 1 \leq n \leq 10 ）。</li>
<li>第二行输入四个整数  sx, sy, ex, ey ，表示起点 (sx, sy) 和终点 (ex, ey) 的坐标。</li>
<li>第三行输入一个整数  k ，表示最多的步数（ 1 \leq k \leq 10 ）。</li>
</ul>
</li>
<li><p>输出：  </p>
<ul>
<li>输出一个整数，表示在最多  k  步以内从 (sx, sy) 到达 (ex, ey) 的不同路径数。</li>
</ul>
</li>
<li><p>题解代码：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, sx, sy, ex, ey, k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> countPaths = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 四个方向：上，下，左，右</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数，当前坐标 (x, y)，已经走的步数 steps</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> steps)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前坐标是终点，则计数加一</span></span><br><span class="line">    <span class="keyword">if</span> (x == ex &amp;&amp; y == ey) </span><br><span class="line">    &#123;</span><br><span class="line">        countPaths++;</span><br><span class="line">        <span class="comment">// 注意：即使达到终点，也可以选择继续移动，直到步数达到 k</span></span><br><span class="line">        <span class="comment">// 所以不在此处 return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经达到最大步数，停止递归</span></span><br><span class="line">    <span class="keyword">if</span> (steps == k)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试四个方向移动</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++) &#123;</span><br><span class="line">        <span class="type">int</span> newX = x + dx[dir];</span><br><span class="line">        <span class="type">int</span> newY = y + dy[dir];</span><br><span class="line">        <span class="comment">// 检查新位置是否在网格内</span></span><br><span class="line">        <span class="keyword">if</span>(newX &gt;= <span class="number">1</span> &amp;&amp; newX &lt;= n &amp;&amp; newY &gt;=<span class="number">1</span> &amp;&amp; newY &lt;=n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(newX, newY, steps + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(sx, sy, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; countPaths;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/" data-id="cmg3qqgcg000fnw967tgda50i" data-title="算法笔记(C++) ——递归" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">九月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">八月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">六月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Python ——基本数据类型</a>
          </li>
        
          <li>
            <a href="/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Python ——基础语法</a>
          </li>
        
          <li>
            <a href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86/">算法笔记(C++) ——并查集</a>
          </li>
        
          <li>
            <a href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/">算法笔记(C++) ——贪心</a>
          </li>
        
          <li>
            <a href="/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">算法笔记(C++) ——动态规划</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 ShenKeyang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>