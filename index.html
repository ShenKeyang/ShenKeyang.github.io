<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>YOLO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="YOLO的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="YOLO">
<meta property="og:url" content="https://shenkeyang.github.io/index.html">
<meta property="og:site_name" content="YOLO">
<meta property="og:description" content="YOLO的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ShenKeyang">
<meta property="article:tag" content="sky">
<meta property="article:tag" content="ShenKeyang">
<meta property="article:tag" content="YOLO">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="YOLO" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">YOLO</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">You Only Live Once</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shenkeyang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-算法笔记-C-——哈希表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2025-08-15T14:13:28.000Z" itemprop="datePublished">2025-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/">算法笔记(C++) ——哈希表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="哈希表的概念"><a href="#哈希表的概念" class="headerlink" title="哈希表的概念"></a>哈希表的概念</h2><p>哈希表是一种基于哈希函数（Hash Function）的数据结构，用于实现键值对的快速存储和查找。它的主要特点是：</p>
<ol>
<li><p>快速查找：平均情况下，<strong>哈希表的查找、插入和删除操作的时间复杂度都是<code>O(1)</code></strong>。</p>
</li>
<li><p>键值对存储：哈希表存储的是键值对，每个键（Key）唯一对应一个值（Value）。</p>
</li>
<li><p>哈希函数：通过哈希函数将键映射到哈希表中的位置，从而实现快速存取。</p>
</li>
</ol>
<p><strong>C++ 中的哈希表 ——<code>unordered_map</code>：</strong>   </p>
<p>在 C++ 中，<code>unordered_map</code>是标准库提供的哈希表实现。它具有以下特点：</p>
<ol>
<li><p>键值对存储：unordered_map&lt;Key, T&gt; 存储的是键为 Key，值为 T 的键值对。</p>
</li>
<li><p>快速访问：提供了常数时间复杂度的查找、插入和删除操作。</p>
</li>
</ol>
<p><strong>主要操作：</strong>   </p>
<ol>
<li>插入元素：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash_map;  <span class="comment">//定义哈希表</span></span><br><span class="line">hash_map[key] = value;  <span class="comment">// 插入或更新键为 key 的值为 value</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查找元素： 在C++的<code>unordered_map</code>（或<code>map</code>）中，<code>find(key)</code>方法用于查找关键字<code>key</code>是否存在。<code>find(key)</code>返回一个迭代器，如果<code>key</code>存在，迭代器指向元素，否则指向<code>end()</code>。使用<code>find(key)</code>可以高效检查<code>key</code>的存在。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hash_map.<span class="built_in">find</span>(key) != hash_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 找到了 key</span></span><br><span class="line">    <span class="type">int</span> value = hash_map[key];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没找到 key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>获取某键key的键值：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = hash_map[key];  <span class="comment">// 如果key不存在，会自动插入key并初始化值为0</span></span><br></pre></td></tr></table></figure>
<p><strong>示例代码（有一个包含n个整数的口袋，同时提出q个问题，每个问题询问特定的数字在口袋中出现了多少次。）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,q,num;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;  <span class="comment">//定义哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        map[num]++;   </span><br><span class="line">        <span class="comment">//如果key不存在，会自动插入key并初始化值为0，遇到相应key键时对应的键值自增</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(num)!=map.<span class="built_in">end</span>())  <span class="comment">//如果能找到对应键值的话</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; map[num] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;   <span class="comment">//如果找不到对应键值，则输出0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>在编写程序时，时间复杂度（Time Complexity）是一个重要指标。时间复杂度描述了程序运行时间与输入规模之间的关系。<br>OJ 一般 C++ 1秒大概能跑1e8量级。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; i++) &#123;</span><br><span class="line">		ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于这个简单的代码，x &lt; 1e8，运行不会超时；x &gt; 1e8，运行超时。</span></span><br></pre></td></tr></table></figure>

<p><strong>常见的时间复杂度包括（从小到大）：</strong></p>
<p><code>O(1)</code>：常数时间，无论输入规模多大，执行时间保持不变。</p>
<p><code>O(log n)</code>：对数时间，随着输入规模增加，执行时间按对数增长。例如二分操作。</p>
<p><code>O(n)</code>：线性时间，执行时间与输入规模成正比。</p>
<p><code>O(n log n)</code>：线性对数时间，常见于高效排序算法如快速排序、归并排序。</p>
<p><code>O(n^2)</code>：平方时间，常见于简单的嵌套循环，如冒泡排序。</p>
<p><code>O(n^3)</code>：立方时间。</p>
<p><code>O(2^n)</code>：指数时间。</p>
<p><code>O(n!)</code>：阶乘时间。</p>
<p><code>O(n^n)</code>：幂指时间。</p>
<p><strong>如何计算时间复杂度：</strong></p>
<ol>
<li><p>识别基本操作：确定算法中最频繁执行的操作，如循环中的语句、递归调用等。</p>
</li>
<li><p>计算基本操作的执行次数：根据输入规模，计算这些操作随着输入增长的次数。</p>
</li>
<li><p>忽略低阶项和常数系数：在大O表示法中，只保留增长最快的项，忽略常数和低阶项。</p>
</li>
</ol>
<br>  

<p>对于上述口袋问题题目而言，<code>q=n=10^5</code>，如果考虑对于每次查询去遍历一遍所有数，复杂度为<code>O(n*Q)=10^10</code>，根据上面的<code>1e8定理</code>，显然1秒钟是跑不完的，可能会被反馈超时（Time Exceeded），因此可以选用哈希表（Hash Table）的方式来统计每个数字出现的次数，使用C++提供的<code>unordered_map</code>来实现哈希表，因其具有平均<code>O(1)</code>的查找和插入时间复杂度，故能够高效地回答每个查询。    </p>
<p><br><br></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/" data-id="cmen1x2220001u896gu7jdl37" data-title="算法笔记(C++) ——哈希表" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2025-08-15T09:36:38.000Z" itemprop="datePublished">2025-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%A0%88/">算法笔记(C++) ——栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="栈的特性："><a href="#栈的特性：" class="headerlink" title="栈的特性："></a>栈的特性：</h2><p><code>LIFO（后进先出）原则</code>：栈中的元素是从栈顶添加和移除的，栈顶的元素是最先被访问的。<br><code>只能在一端操作</code>：栈的操作只能在栈顶进行。  </p>
<p><br><br></p>
<h2 id="栈的应用："><a href="#栈的应用：" class="headerlink" title="栈的应用："></a>栈的应用：</h2><p><code>函数调用管理</code>：在程序运行过程中，函数调用的顺序和返回都由栈来管理。每次函数调用时，程序会把当前函数的信息压入栈中，函数执行完成后会从栈中弹出，返回到调用函数的位置。<br><code>表达式求值</code>：栈常用于数学表达式的求值，尤其是处理括号匹配和运算符优先级时。<br><code>浏览器的历史记录</code>：浏览器在你浏览网页时会将每个页面的链接压入栈中，这样你按回退按钮时就可以弹出最近访问的页面。  </p>
<p><br><br></p>
<h2 id="栈的实现："><a href="#栈的实现：" class="headerlink" title="栈的实现："></a>栈的实现：</h2><p>栈可以通过数组或链表来实现。常见的实现方式有：<br><code>数组实现</code>：使用数组来存储栈的元素，栈顶指针记录栈顶元素的位置。<br><code>链表实现</code>：通过链表的头结点来表示栈顶，头结点指向栈顶元素。<br>栈的操作时间复杂度通常是<code>O(1)</code>，即每次操作的时间是常数级别的，因为它只涉及栈顶元素.  </p>
<p><br><br></p>
<h2 id="栈的C-实现和操作"><a href="#栈的C-实现和操作" class="headerlink" title="栈的C++实现和操作"></a>栈的C++实现和操作</h2><p><strong>C++自带的<code>stack</code>容器：</strong><br>C++中的<code>stack</code>是一个标准库容器，用来实现栈（Stack）数据结构。栈是一种后进先出（LIFO，Last In, First Out）的数据结构，意味着最后加入的元素会最先被移除。C++的stack容器是基于其他容器（例如deque或vector）实现的，但提供了一个简化的接口，专注于栈的基本操作。</p>
<p><strong>stack的主要操作:</strong>  </p>
<ol>
<li><code>push()</code>： 向栈顶添加一个元素。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">10</span>);  <span class="comment">// 栈顶添加元素10</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">20</span>);  <span class="comment">// 栈顶添加元素20</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">30</span>);  <span class="comment">// 栈顶添加元素30</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>pop()</code>： 移除栈顶的元素，但并不返回该元素。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">pop</span>();  <span class="comment">// 移除栈顶元素30</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>top()</code>： 返回栈顶的元素，但不移除它。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; s.<span class="built_in">top</span>();  <span class="comment">// 输出栈顶元素20</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>empty()</code>： 检查栈是否为空。如果栈为空，返回true，否则返回false。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;栈是空的&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;栈不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><code>size()</code>： 返回栈中元素的数量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;栈的大小：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 输出栈中的元素数量</span></span><br></pre></td></tr></table></figure>
<p><strong>示例代码（合法括号判断）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;  <span class="comment">// 输入括号字符串</span></span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; stk;  <span class="comment">// 创建一个栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(ch);  <span class="comment">// 遇到左括号，压入栈中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;  <span class="comment">// 栈为空，说明没有匹配的左括号</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">pop</span>();  <span class="comment">// 弹出栈顶元素，匹配对应的左括号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果栈为空，说明所有左括号都有匹配</span></span><br><span class="line">    cout &lt;&lt; (stk.<span class="built_in">empty</span>() ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;  <span class="comment">// 输出结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，C++中的stack是一个非常简单且高效的数据结构，适合处理“先进后出”类型的需求。  </p>
<p><br><br></p>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>auto 是 C++11 引入的一个关键字，主要用于自动推导变量的类型。它使得编程变得更加简洁，减少了显式指定类型的需求，特别是当类型复杂或不容易记住时。  </p>
<p><strong>使用场景：</strong></p>
<ol>
<li>变量声明：在声明变量时，可以使用 auto 来代替显式的类型声明，编译器会根据右边的表达式自动推导出变量的类型。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;  <span class="comment">// x的类型是int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.14</span>;  <span class="comment">// y的类型是double</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>容器迭代器：在使用 STL 容器（如 vector）时，容器的迭代器类型通常比较复杂。使用 auto 可以让代码更加简洁和易读。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>函数返回类型：如果函数返回一个复杂的类型或是模板类型，使用 auto 可以减少繁琐的类型声明。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">// 返回值类型为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>范围 for 循环：在范围 for 循环中，auto 用来推导容器中元素的类型。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;  <span class="comment">// num 的类型是int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%A0%88/" data-id="cmen1x26m0004u896d90v5uwf" data-title="算法笔记(C++) ——栈" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——字符串" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
  <time class="dt-published" datetime="2025-08-15T08:51:38.000Z" itemprop="datePublished">2025-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/">算法笔记(C++) ——字符串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="常用的string成员函数"><a href="#常用的string成员函数" class="headerlink" title="常用的string成员函数"></a>常用的string成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">string s1;                <span class="comment">// 默认构造，创建一个空字符串</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;Hello, C++!&quot;</span>)</span></span>; <span class="comment">// 用常量字符串构造</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>;            <span class="comment">// 用另一个字符串构造（拷贝构造）</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;       <span class="comment">// 创建一个长度为 10 的字符串，每个字符为 &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;World&quot;</span>;  <span class="comment">// 赋新值，原有的内容会被释放并替换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串拼接（连接）</span></span><br><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">string s3 = s1 + <span class="string">&quot; &quot;</span> + s2;  <span class="comment">// 拼接两个字符串</span></span><br><span class="line">s<span class="number">1.</span><span class="built_in">append</span>(<span class="string">&quot; C++&quot;</span>);               <span class="comment">// 使用 append() 进行拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取长度</span></span><br><span class="line">string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> length = s.<span class="built_in">length</span>();   <span class="comment">// 获取字符串的长度</span></span><br><span class="line"><span class="type">size_t</span> size = s.<span class="built_in">size</span>();       <span class="comment">// 等价于 length()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符访问</span></span><br><span class="line">string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> c = s[<span class="number">1</span>];    <span class="comment">// 访问字符串中索引为 1 的字符，结果是 &#x27;e&#x27;</span></span><br><span class="line"><span class="type">char</span> c2 = s.<span class="built_in">at</span>(<span class="number">1</span>); <span class="comment">// 等价于 s[1]，但如果索引越界，会抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找字符或子字符串</span></span><br><span class="line">string s = <span class="string">&quot;Hello, C++!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = s.<span class="built_in">find</span>(<span class="string">&quot;C++&quot;</span>);  <span class="comment">// 返回第一次出现 &quot;C++&quot; 的位置，如果没找到返回string::npos</span></span><br><span class="line"><span class="keyword">if</span> (pos != string::npos) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Found at position &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换字符或子字符串</span></span><br><span class="line">string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">7</span>, <span class="number">5</span>, <span class="string">&quot;C++&quot;</span>);  <span class="comment">// 从位置 7 开始替换 5 个字符，替换为 &quot;C++&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除字符</span></span><br><span class="line">string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">5</span>, <span class="number">7</span>);  <span class="comment">// 从位置 5 开始，删除 7 个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子字符串</span></span><br><span class="line">string s = <span class="string">&quot;Hello, C++!&quot;</span>;</span><br><span class="line">string x = <span class="string">&quot;my &quot;</span>;</span><br><span class="line">string sub1 = s.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">3</span>);  <span class="comment">// 获取从位置 7 开始，长度为 3 的子字符串 &quot;C++&quot;</span></span><br><span class="line">string sub2 = s.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">3</span>);  <span class="comment">// 获取从位置 7 开始往后的整个子字符串 &quot;C++!&quot;</span></span><br><span class="line">string newString = s.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">7</span>) + x + s.<span class="built_in">substr</span>(<span class="number">7</span>);  <span class="comment">// 将字符串x插入到位置7，形成一个新的字符串&quot;Hello, my C++!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较字符串</span></span><br><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Strings are equal.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Strings are not equal.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br>  </p>
<h2 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h2><p>回文字符串是指正着读和反着读都一样的字符串。换句话说，回文字符串从左到右和从右到左的字符顺序完全相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查字符串是否是回文示例（非函数形式）</span></span><br><span class="line"><span class="type">bool</span> is_palindrome = <span class="literal">true</span>; <span class="comment">//先假定其是回文串</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c.<span class="built_in">length</span>() / <span class="number">2</span>; j++) &#123;</span><br><span class="line">    <span class="comment">// 对称位置字符不相等，不是回文</span></span><br><span class="line">    <span class="keyword">if</span> (c[j] != c[c.<span class="built_in">length</span>() - <span class="number">1</span> - j]) &#123;</span><br><span class="line">        is_palindrome = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">//不执行则is_palindrome 仍为 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查字符串是否是回文示例（函数形式）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = str.<span class="built_in">length</span>() - <span class="number">1</span>; <span class="comment">//双指针</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[left] != str[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果不相等，返回 false</span></span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 全部字符都匹配，返回 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <br><br>  </p>
<h2 id="for循环的另一种用法"><a href="#for循环的另一种用法" class="headerlink" title="for循环的另一种用法"></a>for循环的另一种用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : s) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个基于范围的 for 循环（C++11 及以上支持），用于遍历字符串s中的每个字符，<code>char ch</code>表示每次循环中获取的字符串元素（单个字符）<br>  <br><br>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/" data-id="cmen1x2240002u89687uoch5z" data-title="算法笔记(C++) ——字符串" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——IO" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/14/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94IO/" class="article-date">
  <time class="dt-published" datetime="2025-08-14T14:18:35.000Z" itemprop="datePublished">2025-08-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/14/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94IO/">算法笔记(C++) ——IO</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="C-万能头文件"><a href="#C-万能头文件" class="headerlink" title="C++万能头文件"></a>C++万能头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="它包含（但不限于）："><a href="#它包含（但不限于）：" class="headerlink" title="它包含（但不限于）："></a>它包含（但不限于）：</h4><ol>
<li><p>基础头文件：<br><code>&lt;iostream</code>：输入输出流，包含cin、cout等 I&#x2F;O 操作<br><code>&lt;cstdio&gt;</code>：C 风格输入输出，包含printf、scanf等函数<br><code>&lt;cmath&gt;</code>：数学函数库，包含sin、cos、sqrt等数学运算     </p>
</li>
<li><p>容器与数据结构:<br><code>&lt;vector&gt;</code>：动态数组容器<br><code>&lt;string&gt;</code>：字符串类及相关操作<br><code>&lt;map&gt;/&lt;unordered_map&gt;</code>：映射容器（键值对）<br><code>&lt;set&gt;/&lt;unordered_set&gt;</code>：集合容器<br><code>&lt;list&gt;</code>：双向链表容器<br><code>&lt;queue&gt;</code>：队列容器<br><code>&lt;stack&gt;</code>：栈容器<br><code>&lt;array&gt;</code>：固定大小数组（C++11）   </p>
</li>
<li><p>算法:<br><code>&lt;algorithm&gt;</code>：标准算法库，包含排序、查找等算法（如sort、find）</p>
</li>
</ol>
<p><br><br>  </p>
<h2 id="C-的命名空间"><a href="#C-的命名空间" class="headerlink" title="C++的命名空间"></a>C++的命名空间</h2><p>在C++中，<code>using namespace std;</code>是一个用于简化代码的语句，它的作用是告诉编译器你希望使用标准库中的名称而不需要加上 &#96;&#96;前缀。  </p>
<p><br><br></p>
<h2 id="输入输出格式化"><a href="#输入输出格式化" class="headerlink" title="输入输出格式化"></a>输入输出格式化</h2><p>C++ 提供了多种方式来控制输入输出的格式，常用的包括 <code>setw</code>、<code>setprecision</code>、<code>fixed</code>等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>  <span class="comment">// 提供格式化工具</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159265358979</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原始值: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置输出精度为 2 位小数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;保留两位小数: &quot;</span> &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setw(width)</code>用于设置输出的宽度。<br><code>setprecision(n)</code>设置浮点数的精度。<br><code>fixed</code>控制浮点数按照固定格式输出。   </p>
<p><br><br>  </p>
<h2 id="long-long"><a href="#long-long" class="headerlink" title="long long"></a>long long</h2><p>相比于<code>int</code>（通常为 4 字节，32位），<code>long long</code>拥有更大的存储范围（通常占用 8 字节,64 位整数类型，它的取值范围是：从 -2^63 到 2^63 - 1，即约 -9.2 × 10^18 到 9.2 × 10^18），适用于需要存储大整数的场合。如果你需要处理的整数值超过了<code>int</code>的最大值（大约 21 亿, 约为2 × 10^9），那么<code>long long</code>就是更合适的选择。  </p>
<p><br><br></p>
<h2 id="ACM模式下的评测反馈"><a href="#ACM模式下的评测反馈" class="headerlink" title="ACM模式下的评测反馈"></a>ACM模式下的评测反馈</h2><p><code>AC（Accepted，接受）</code>：<br>表示提交的程序正确，输出符合要求，并且在规定的时间和内存限制内运行完成。AC是最理想的反馈，说明选手的代码通过了所有的测试用例。  </p>
<p><code>WA（Wrong Answer，错误答案）</code>：<br>这表示程序的输出与期望的结果不符。选手需要检查程序中的逻辑错误，特别是输入输出的处理部分，确保符合题目要求。 </p>
<p><code>TLE（Time Limit Exceeded，超时）</code>：<br>如果程序运行时间超过了题目规定的时间限制，就会出现TLE错误。通常是算法效率的问题，选手需要优化算法，减少计算时间。 </p>
<p><code>MLE（Memory Limit Exceeded，超出内存限制）</code>：<br>如果程序的内存使用量超过了题目要求的限制，系统会返回MLE反馈。通常是因为程序使用了过多的内存，可能是由于存储过多数据或不必要的数据结构。  </p>
<p><code>RE（Runtime Error，运行时错误）</code>：<br>如果程序在运行过程中发生了错误（如除以零、访问非法内存等），则会返回RE错误。选手需要检查代码中的边界情况、异常处理等。  </p>
<p><code>PE（Presentation Error，输出格式错误）</code>：<br>这个反馈表示程序的输出没有按照题目要求的格式输出。比如输出的数字顺序不对，或者多了不必要的空格或换行符。  </p>
<p><code>CE（Compilation Error，编译错误）</code>：<br>如果提交的代码存在编译问题，平台会给出编译错误的反馈。选手需要检查代码是否存在语法错误或未定义的变量。  </p>
<p><br><br></p>
<h2 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h2><p>1.创建和初始化<br>可以通过以下几种方式创建<code>stringstream</code>对象：</p>
<ul>
<li>默认构造：创建一个空的 stringstream 对象。  </li>
<li>使用字符串初始化：通过构造函数将一个字符串传给 stringstream。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 默认构造</span></span><br><span class="line">    stringstream ss1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用字符串初始化</span></span><br><span class="line">    <span class="function">stringstream <span class="title">ss2</span><span class="params">(<span class="string">&quot;123 456&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.输出操作<br>使用 &lt;&lt; 运算符，可以将数据写入到 stringstream 中，数据将会被存储为一个字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">3.14</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向stringstream中写入数据</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;Integer: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, Double: &quot;</span> &lt;&lt; y;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;  <span class="comment">// 输出字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，ss.str() 返回的是字符串流中存储的字符串。  </p>
<p>3.输入操作<br>使用 &gt;&gt; 运算符，从 stringstream 中读取数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(<span class="string">&quot;100 200 3.14&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从stringstream中读取数据</span></span><br><span class="line">    ss &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，stringstream 中的字符串被解析并提取成不同的变量。</p>
<p>4.清空 stringstream<br>如果想清空 stringstream 中的数据，可以使用 str(“”) 方法，将流的内容设置为空字符串，或者使用 clear() 来重置流的状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;  <span class="comment">// 输出 &quot;Hello, world!&quot;</span></span><br><span class="line">    </span><br><span class="line">    ss.<span class="built_in">str</span>(<span class="string">&quot;&quot;</span>);  <span class="comment">// 清空内容</span></span><br><span class="line">    cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; endl;  <span class="comment">// 输出空字符串</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br><br></p>
<h2 id="多组不定组输入"><a href="#多组不定组输入" class="headerlink" title="多组不定组输入"></a>多组不定组输入</h2><p>在 C++ 中，处理多行不定数量的输入数据是一个常见的需求，特别是在面对不确定数据量的情况下。可以使用一些方法来读取不定行数的数据。下面是几种常见的方式：</p>
<p>1.<code>getline</code>函数介绍<br><code>getline</code>函数是 C++ 中用于从输入流中读取一行文本的函数，通常用于读取用户输入或文件中的一行数据。它的基本用法是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string line;  <span class="comment">// 用来存储输入的文本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示用户输入一行文本</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一行文本: &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 getline 从标准输入中读取一整行</span></span><br><span class="line">    <span class="built_in">getline</span>(cin, line);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出用户输入的内容</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你输入的内容是: &quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getline</code>会读取一整行数据，直到遇到换行符（\n）为止。它不会将换行符包含在返回的字符串中。  </p>
<p>上面的代码举一个例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入一行文本: 你好，世界！</span><br><span class="line">你输入的内容是: 你好，世界！</span><br></pre></td></tr></table></figure>
<p>2.使用<code>cin</code>和循环<br>你可以使用<code>cin</code>来逐行读取输入数据，然后根据特定条件判断是否继续读取。例如，当输入数据结束时（通常是遇到文件结束符 EOF 或空行），停止读取。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line)) &#123;</span><br><span class="line">        <span class="comment">// 处理每一行输入的内容</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;输入的行是: &quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>getline(cin, line)</code>会读取每一行输入数据，直到输入结束（通常通过文件结束符 EOF ： Ctrl + Z 或 Ctrl + D 来结束）。读取的每一行会存储在 line 变量中，之后你可以对该行数据进行处理。  </p>
<p><br><br></p>
<h2 id="动态数组容器vector"><a href="#动态数组容器vector" class="headerlink" title="动态数组容器vector"></a>动态数组容器vector</h2><p>相较于一般数组，<code>vector</code>可以定义动态数组向量，参数可以用变量来设置，更为灵活。用法如下：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;      <span class="comment">//定义一个整型变量</span></span><br><span class="line">    cin &gt;&gt; n;   <span class="comment">//输入给变量赋值</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>; <span class="comment">//定义一个元素种类为int的vector向量</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>vector</code>定义二维数组（矩阵）的用法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m ;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">matrix</span>(n,<span class="built_in">vector</span>(m)); <span class="comment">//vector嵌套vector形成一个二维矩阵</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若上述实现全部使用传统的静态数组，则无法使用变量作为开辟数组的大小，需要定义静态的、超额大小的数组，如：<code>int arr[1010][1010] = &#123;0&#125;</code>，或先在函数外定义<code>const int SIZE = 1010;</code>再定义静态数组<code>int arr[SIZE][SIZE] = &#123;0&#125;</code>。</p>
<p><strong>也可以不设置开辟大小参数，就要用到<code>.push_back()</code>（入栈_尾部）成员函数，与之相对应的还有<code>.push_front()</code>（入栈_头部）成员函数：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr; <span class="comment">//不设开辟大小参数</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; num)&#123;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(num); </span><br><span class="line">        <span class="comment">//.push_back() 是 C++ 标准库中序列容器（如 vector、list、deque、string等）的成员函数。它的作用是在容器的末尾添加一个新元素。</span></span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;  <span class="comment">//如果是通过换行符结束输入，可以用此判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/14/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94IO/" data-id="cmen1x21y0000u89649pmfgd4" data-title="算法笔记(C++) ——IO" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-I-m-back" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/27/I-m-back/" class="article-date">
  <time class="dt-published" datetime="2025-06-27T15:07:57.000Z" itemprop="datePublished">2025-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/27/I-m-back/">I&#39;m back!</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一级标题示例"><a href="#一级标题示例" class="headerlink" title="一级标题示例"></a>一级标题示例</h1><h2 id="二级标题示例"><a href="#二级标题示例" class="headerlink" title="二级标题示例"></a>二级标题示例</h2><h3 id="三级标题示例"><a href="#三级标题示例" class="headerlink" title="三级标题示例"></a>三级标题示例</h3><h4 id="四级标题示例（正文加粗）"><a href="#四级标题示例（正文加粗）" class="headerlink" title="四级标题示例（正文加粗）"></a>四级标题示例（正文加粗）</h4><h5 id="五级标题示例"><a href="#五级标题示例" class="headerlink" title="五级标题示例"></a>五级标题示例</h5><h6 id="五级标题减淡"><a href="#五级标题减淡" class="headerlink" title="五级标题减淡"></a>五级标题减淡</h6><p>正文  -&gt; 换行操作为：两个空格+回车 &#x2F; <code>&lt;br&gt;</code> &#x2F; 中间隔开一行<br><strong>加粗示例</strong> 或 <strong>加粗示例</strong><br><em>斜体示例</em> 或 <em>斜体示例</em><br><em><strong>斜体加粗示例</strong></em> 或 <em><strong>斜体加粗示例</strong></em><br><del>删除示例</del><br><code>单行代码示例</code></p>
<ol>
<li><p>有序列表项 1 示例</p>
</li>
<li><p>有序列表项 2 示例</p>
<ul>
<li>无序列表项 A 示例</li>
<li>无序列表项 B 示例</li>
</ul>
<pre><code class="language-python"> # 代码块示例（Python）
 def hello_world():
     print(&quot;Hello~&quot;)
</code></pre>
</li>
</ol>
<p>超链接示例：<a target="_blank" rel="noopener" href="https://github.com/ShenKeyang">我的github仓库</a>   </p>
<p><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="图片描述（alt属性）" title="可选标题"><br>示例：  </p>
<p><img src="https://hexo.io/logo.svg" alt="Hexo Logo" title="Hexo Logo">    </p>
<p>分割线：用至少 3 个 -、* 或 _ 表示（单独一行）：  </p>
<hr>
<hr>
<hr>
<p>任务列表：<br>用 - [ ] 表示未完成，- [x] 表示已完成：  </p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 完成Markdown学习  </li>
<li><input checked="" disabled="" type="checkbox"> 部署到Hexo  </li>
<li><input disabled="" type="checkbox"> 撰写第100篇博客</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/06/27/I-m-back/" data-id="cmen1x2240003u89684h3gh1g" data-title="I&#39;m back!" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">八月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">六月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/">算法笔记(C++) ——哈希表</a>
          </li>
        
          <li>
            <a href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%A0%88/">算法笔记(C++) ——栈</a>
          </li>
        
          <li>
            <a href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/">算法笔记(C++) ——字符串</a>
          </li>
        
          <li>
            <a href="/2025/08/14/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94IO/">算法笔记(C++) ——IO</a>
          </li>
        
          <li>
            <a href="/2025/06/27/I-m-back/">I&#39;m back!</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 ShenKeyang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>