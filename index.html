<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>YOLO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="YOLO的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="YOLO">
<meta property="og:url" content="https://shenkeyang.github.io/index.html">
<meta property="og:site_name" content="YOLO">
<meta property="og:description" content="YOLO的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ShenKeyang">
<meta property="article:tag" content="sky">
<meta property="article:tag" content="shenkeyang">
<meta property="article:tag" content="YOLO">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="YOLO" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">YOLO</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">You Only Live Once.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shenkeyang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-算法笔记-C-——动态规划" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="article-date">
  <time class="dt-published" datetime="2025-09-21T16:03:16.000Z" itemprop="datePublished">2025-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">算法笔记(C++) ——动态规划</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>动态规划（Dynamic Programming，简称 DP）是一种有效的算法设计思想，用于解决具有<code>最优子结构</code>和<code>重叠子问题</code>的复杂问题。其核心思想是通过<code>记录已解决子问题的结果</code>来避免重复计算，从而优化效率。关键在于<code>定义问题的状态和状态转移方程</code>。<br>​以下是一道关于DP的简单例题，并通过集合视角一步步推导状态和转移方程的详细过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">小明正在爬楼梯。楼梯总共有 n 级台阶，小明每次可以选择爬 1 级或 2 级台阶。请问小明爬到第 n 级台阶的不同方法有多少种。</span><br><span class="line">注意：假设小明从地面（第 0 级台阶）开始爬楼梯，每次可以从当前台阶选择爬 1 级或 2 级台阶，直到到达第 n 级台阶。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">输入一个整数 n（1 ≤ n ≤ 40），表示楼梯的总级数。</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">输出一个整数，表示爬到第 n 级台阶的不同方法数。</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>讨论 n &#x3D; 4 的情况：</strong><br>对于 (n &#x3D; 4)，所有可能的爬楼方式如下(5种)：</li>
</ol>
<ul>
<li>0→1→2→3→4</li>
<li>0→1→2→4</li>
<li>0→1→3→4</li>
<li>0→2→3→4</li>
<li>0→2→4<br>将这些方案的集合定义为 D4 ，那么集合的大小∣D4∣&#x3D;5 就是问题的答案。</li>
</ul>
<ol start="2">
<li><strong>情况分类：</strong><br>考虑到达第 4 级楼梯的方式，可以从两种途径到达：</li>
</ol>
<ul>
<li>最后一步从第 3 级到达第 4 级，即 3→4</li>
<li>最后一步从第 2 级到达第 4 级，即 2→4<br>根据这两种情况，我们可以将集合 D4 分为两部分:<br><img src="/images/cpp_11_1.png" alt=" "></li>
</ul>
<ol start="3">
<li><strong>等价映射：</strong><br>从集合划分可以观察到：</li>
</ol>
<ul>
<li>将上图中的第一个式子中最后的(4)去掉，得到的方案等价于从(0)到(3)的所有方案，即1式等价于D3；  </li>
<li>将上图中的第二个式子中最后的(4)去掉，得到的方案等价于从(0)到(2)的所有方案，即1式等价于D2；</li>
</ul>
<ol start="4">
<li><strong>递推方程:</strong><br>通过上述分析，可以得出递推关系：</li>
</ol>
<ul>
<li><strong>|D4| &#x3D; |D2| + |D3|</strong></li>
</ul>
<ol start="5">
<li><strong>推广情况:</strong><br>我们可以用相同的思路分析任意 (n)：<br>要到达第 n 级楼梯，最后一步只能是从 n−1 或 n−2 到达。因此，所有从 0 到 n 的方案可以表示为：</li>
</ol>
<ul>
<li><strong>|D_n| &#x3D; |D_n-1| + |D_n-2|</strong><br>这就是爬楼梯问题的<code>核心状态转移方程</code>。</li>
</ul>
<ol start="6">
<li><strong>边界条件：</strong><br>在动态规划中，需要明确边界条件来初始化状态转移：</li>
</ol>
<ul>
<li>从 (0) 到 (1) 的方案：只能 0→1，因此：∣D1∣&#x3D;1;</li>
<li>从 (0) 到 (2) 的方案：可以是 0→1→2或0→2，因此：∣D2∣&#x3D;2;</li>
</ul>
<ol start="7">
<li><strong>总结：</strong></li>
</ol>
<ul>
<li>状态定义：D_n为从第 (0) 级楼梯到第 (n) 级楼梯的所有方案数。</li>
<li>状态转移方程：|D_n| &#x3D; |D_n-1| + |D_n-2|；</li>
<li>边界条件：∣D1∣&#x3D;1 ，∣D2∣&#x3D;2;<br>通过上述递推公式，可以高效地计算任意 (n) 的爬楼方案数。</li>
</ul>
<p><strong>上述例题的代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里第 i 个元素对应第 i+1 级台阶</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; D[n];</span><br><span class="line"></span><br><span class="line">    D[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    D[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        D[i] = D[i<span class="number">-1</span>] + D[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; D[n<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>DP例题2 （二维状态转移）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述</span></span><br><span class="line"><span class="comment">给定一个大小为 n×n 的二维矩阵，计算从起点 (1,1) 到终点 (n,n) 的所有可能路径的数量。</span></span><br><span class="line"><span class="comment">每一步可以向右或向下移动一个格子。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">输入包含一个整数 n，表示矩阵的大小。 1&lt;=n&lt;=17</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">输出一个整数，表示从 (1,1) 到 (n,n) 的路径总数。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*思路：</span></span><br><span class="line"><span class="comment">1.状态定义：dp[i][j]表示从起点 (0,0) 到达位置 (i,j) 的路径总数;</span></span><br><span class="line"><span class="comment">2.状态转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1];</span></span><br><span class="line"><span class="comment">3.边界条件：dp[0][0] = 1 ，dp[i][0] = 1 ，dp[0][j] = 1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果不是起点 (0, 0)，则计算当前点的路径数</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>) dp[i][j]+=dp[i - <span class="number">1</span>][j];<span class="comment">//从上方来（前提不是第一行）</span></span><br><span class="line">            <span class="keyword">if</span> (j&gt;<span class="number">0</span>) dp[i][j]+=dp[i][j - <span class="number">1</span>];<span class="comment">//从左方来（前提不是第一列）</span></span><br><span class="line">            <span class="comment">// 若既不是第一行，也不是第一列，则dp[i][j]=dp[i-1][j]+dp[i][j-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>DP例题3：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目内容：</span></span><br><span class="line"><span class="comment">圣诞节到了，小塔的妈妈准备了很多圣诞礼盒，礼盒大小不同，小塔在玩堆盒子的游戏，妈妈问小塔，怎么堆</span></span><br><span class="line"><span class="comment">盒子使得堆出的高度最高，每个礼盒的大小由长、宽、高表示，堆盒子的时候要求下面的盒子长、宽、高都必</span></span><br><span class="line"><span class="comment">须大于上面的盒子，不包含等于。请你帮助小塔一起堆出最高的一堆礼盒，高度为堆出的礼盒的所有高度的总和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">输入的第一行是礼盒的个数N，接下来输入N行，每行表示每个礼盒的长、宽、高。</span></span><br><span class="line"><span class="comment">礼盒的数量不超过1000个，每个盒子的长、宽、高取值范围为1~10。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">输出一行，输出能堆出盒子的最高高度*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*思路：</span></span><br><span class="line"><span class="comment">1.排序：首先，将所有盒子按照长、宽、高三个维度进行从小到大的排序。由于后面的盒子在长、宽、高方面</span></span><br><span class="line"><span class="comment">  都大于前面的盒子，因此可以确保后一个盒子不会被放在前一个盒子上面，从而简化了问题。</span></span><br><span class="line"><span class="comment">2.动态规划：接下来，使用动态规划来解决问题。定义 dp[i] 表示以第 i 个盒子为底部盒子时，所能达到的</span></span><br><span class="line"><span class="comment">  最大堆叠高度。我们需要考虑所有之前的盒子，如果一个盒子可以放在另一个盒子上面，就更新 dp[i] 的值。</span></span><br><span class="line"><span class="comment">3.结果计算：最终，结果为所有 dp[i] 中的最大值，即为我们能够堆叠的最高高度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l, w, h;</span><br><span class="line">&#125;box[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">    	cin&gt;&gt;box[i].l&gt;&gt;box[i].w&gt;&gt;box[i].h;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长、宽、高的三个优先级进行从小到大的排序</span></span><br><span class="line">    <span class="built_in">sort</span>(box<span class="number">+1</span>, box+n<span class="number">+1</span>, [&amp;](node a, node b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.l!=b.l)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.l&lt;b.l;   </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a.w!=b.w)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[i]表示第i个盒子作为底部时所能达到的最大高度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=box[i].h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (box[i].h &gt; box[j].h &amp;&amp; box[i].l &gt; box[j].l &amp;&amp; box[i].w &gt; box[j].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+box[i].h); <span class="comment">//尝试匹配前面所有的“前最大高度”dp[j]，取最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong><br>如下所示，上述代码中的此部分是一种C++中使用sort函数对一个结构体数组（数组或容器）进行自定义排序，其形式为<code>sort(box+1, box+n+1, lambda);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(box<span class="number">+1</span>, box+n<span class="number">+1</span>, [&amp;](node a, node b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.l!=b.l)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.l&lt;b.l;   </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a.w!=b.w)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<ul>
<li>前两个参数表示对从box[1]到box[n]（左闭右开区间，实际包含box[1]到box[n]）的元素进行排序；</li>
<li>第三个参数是一个 lambda 表达式，定义了排序的比较规则：<ul>
<li>[&amp;]表示按引用捕获外部变量；</li>
<li>参数a和b是node类型的对象，代表要比较的两个元素；</li>
<li>比较逻辑采用优先级排序：先比较l，l相等再比较w，前两者都相等最后比较h；</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" data-id="cmfva0tth0000wo960zhockdy" data-title="算法笔记(C++) ——动态规划" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——广度优先搜索" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="article-date">
  <time class="dt-published" datetime="2025-09-20T08:36:45.000Z" itemprop="datePublished">2025-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">算法笔记(C++) ——广度优先搜索</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>广度优先搜索（Breadth-First Search，简称 BFS）是一种图或树的遍历或搜索算法。它从起始节点开始，首先访问所有相邻节点，然后对这些相邻节点的未访问邻居进行同样的操作，逐层向外扩展，直到遍历完所有节点或找到目标节点。BFS的特点就是：层次遍历（按照节点与起始节点的距离逐层遍历）与最短路径（在无权图中，BFS可以找到起始节点到目标节点的最短路径）  </p>
<p><strong>算法步骤：</strong></p>
<ol>
<li>初始化队列：创建一个空队列，用于存储待访问的节点。</li>
<li>起始节点入队：将起始节点入队。</li>
<li>循环以下操作，直到队列为空：<ul>
<li>从队列中出队一个节点作为当前节点，并标记它为已访问。</li>
<li>访问当前节点的所有未被访问的邻居节点：<ul>
<li>将这些邻居节点标记为已访问。</li>
<li>将这些邻居节点入队。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>队列的种类决定了BFS的使用范围，例如普通队列（先进先出）适用于层次遍历，优先队列（大根堆或小根堆）适用于最短路算法。以下先来看普通队列的BFS。</li>
</ul>
<p>如下所示的是一个BFS的简单例子，需要从节点1开始使用BFS标记整个图，我们通过图示来逐步拆解这个过程：  </p>
<ol>
<li>创建一个空的普通队列，把节点1作为起始节点，标记节点1，先让它进入队列。<br><img src="/images/cpp_10_1.png" alt=" ">  </li>
<li>接着开始执行BFS，从队列头部取出节点1，访问节点1的所有未被访问的邻居节点（2，3），然后将节点2和节点3入队，并标记它们。<br><img src="/images/cpp_10_2.png" alt=" ">  </li>
<li>从队列头部取出节点2，标记节点2，访问节点2的所有未被访问的邻居节点（4，5），然后将节点4和节点5入队，并标记它们。<br><img src="/images/cpp_10_3.png" alt=" ">  </li>
<li>重复上述步骤，直到队列为空，退出循环，到这里BFS就执行结束了。<br><img src="/images/cpp_10_4.png" alt=" "></li>
</ol>
<br>





<h2 id="队列queue的使用"><a href="#队列queue的使用" class="headerlink" title="队列queue的使用"></a>队列queue的使用</h2><p>C++ 中的 queue 是一个基于 FIFO（先进先出）原则的容器适配器。它通常用于需要按顺序处理元素的场景。queue 适配器是基于底层容器（通常是 deque 或 list）实现的，它提供了简单的接口来进行数据的插入和删除操作。</p>
<p><strong>基本使用：</strong><br>首先，需要包含头文件queue，然后可以通过以下几种基本操作来使用 queue。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">//必要头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的队列</span></span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作：push</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">10</span>);  <span class="comment">// 向队列中添加元素 10</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">20</span>);  <span class="comment">// 向队列中添加元素 20</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">30</span>);  <span class="comment">// 向队列中添加元素 30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队列大小: &quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看队列的前端元素：front</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队列头部元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作：pop</span></span><br><span class="line">    q.<span class="built_in">pop</span>();  <span class="comment">// 移除队列中的第一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次查看队列的前端元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;新的队列头部元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空：empty</span></span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;队列不为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用方法：</strong></p>
<ul>
<li>push(value)：将元素添加到队列的末尾。</li>
<li>pop()：移除队列的头部元素。</li>
<li>front()：获取队列的头部元素（但不移除它）。</li>
<li>back()：获取队列的尾部元素（但不移除它）。</li>
<li>size()：返回队列中元素的数量。</li>
<li>empty()：检查队列是否为空。</li>
</ul>
<p><strong>特点与注意事项：</strong></p>
<ul>
<li>queue 是一个容器适配器，只能进行插入和删除操作，不能随机访问元素。</li>
<li>queue 默认使用 deque 作为底层容器，因此具有高效的插入和删除操作，尤其是在队列两端。</li>
<li>不能通过下标访问队列中的元素，因为 queue 是一个先进先出（FIFO）结构。</li>
</ul>
<p><strong>队列实现BFS例题 1：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">给定一个二维矩阵，表示一个迷宫，其中 1 表示墙壁，0 表示可以通行的道路。你有两个点，起点和终点，问是否存在</span></span><br><span class="line"><span class="comment">一条从起点到终点的路径，使得你可以从起点走到终点。你可以上下左右四个方向移动，但不能穿过墙壁，也不能离开迷</span></span><br><span class="line"><span class="comment">宫范围。坐标以行和列表示，均从0开始，左上角坐标是 (0,0) ，右下角坐标是 (n-1,m-1) 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">第一行输入两个整数 n 和 m，表示迷宫的行数和列数(1≤n,m≤100)。</span></span><br><span class="line"><span class="comment">接下来 n 行，每行包含 m 个整数，表示迷宫的地图，其中 0 表示通路，1 表示墙壁。</span></span><br><span class="line"><span class="comment">最后输入两个整数 x_1, y_1 和 x_2, y_2，表示起点和终点的坐标。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">输出一个字符串，若从起点到终点存在路径，输出 &quot;YES&quot;，否则输出 &quot;NO&quot;。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">maze</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; maze[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查起点和终点是否在迷宫范围内，并且不是墙壁</span></span><br><span class="line">    <span class="keyword">if</span>(x1 &lt; <span class="number">0</span> || x1 &gt;= n || y1 &lt; <span class="number">0</span> || y1 &gt;= m || </span><br><span class="line">       x2 &lt; <span class="number">0</span> || x2 &gt;= n || y2 &lt; <span class="number">0</span> || y2 &gt;= m ||</span><br><span class="line">       maze[x1][y1] == <span class="number">1</span> || maze[x2][y2] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化访问数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 定义四个移动方向：左，右，上，下</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用队列进行BFS</span></span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x1, y1&#125;);</span><br><span class="line">    visited[x1][y1] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; current = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前点是终点，设置 found 为 true 并跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(current.first == x2 &amp;&amp; current.second == y2)</span><br><span class="line">        &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试四个方向移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> newX = current.first + dx[i];</span><br><span class="line">            <span class="type">int</span> newY = current.second + dy[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查新位置是否在迷宫范围内，且是通路，且未被访问过</span></span><br><span class="line">            <span class="keyword">if</span>(newX &gt;=<span class="number">0</span> &amp;&amp; newX &lt; n &amp;&amp; newY &gt;=<span class="number">0</span> &amp;&amp; newY &lt; m &amp;&amp;</span><br><span class="line">               maze[newX][newY] == <span class="number">0</span> &amp;&amp; !visited[newX][newY])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;newX, newY&#125;);</span><br><span class="line">                visited[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据是否找到终点输出结果</span></span><br><span class="line">    <span class="keyword">if</span>(found)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>队列实现BFS例题 2：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">给定一个无向图，该图通过邻接表的方式存储。请你使用广度优先搜索（BFS）算法计算该图的连通块数量。</span></span><br><span class="line"><span class="comment">在无向图中，一个连通块是指图中所有节点之间有路径相连的最大子图。你需要输出图中连通块的数量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">第一行包含两个整数 n 和 m（2≤n≤10^4 ，1≤m≤10^5 ），表示图中有 n 个节点和 m 条边。</span></span><br><span class="line"><span class="comment">接下来的 m 行，每行包含两个整数 u 和 v（1≤u,v≤n），表示存在一条从节点 u 到节点 v 的无向边。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">输出一个整数，表示图中连通块的数量。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        adj[u<span class="number">-1</span>].<span class="built_in">push_back</span>(v<span class="number">-1</span>);</span><br><span class="line">        adj[v<span class="number">-1</span>].<span class="built_in">push_back</span>(u<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> allvisited = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!allvisited)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            visited[cur]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;adj[cur].<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[adj[cur][i]]!=<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(adj[cur][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                allvisited=<span class="literal">false</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            allvisited=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>队列实现BFS例题 3：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目内容：</span></span><br><span class="line"><span class="comment">每天早晨，环卫工人需要处理各个小区的生活垃圾，每个小区的生活垃圾由一队坏卫工人负责运送到最近的垃圾回收站</span></span><br><span class="line"><span class="comment">进行处理，求将所有小区垃圾送到垃圾回收站的最小距离和.假设小区和垃圾回收站都在都在一个m行n列的区域矩阵上，</span></span><br><span class="line"><span class="comment">相邻点的距离为1，只能上下左右移动;其中0表示垃圾处理站，1表示小区，2表示空白区域，−1表示障碍区域不可通行。</span></span><br><span class="line"><span class="comment">区域内如果没有小区或者没有垃圾回收站，则最小距离和返回0。</span></span><br><span class="line"><span class="comment">无法到达垃圾回收站的小区不计入本次距离和中。</span></span><br><span class="line"><span class="comment">计算所有小区垃圾送到垃圾回收站的最小距离和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">第一行为两个数字m和n的和，表示区域矩阵的行数和列数，中间使用空格分隔，m和n的范围均为[1,300]。</span></span><br><span class="line"><span class="comment">接下来的m行表示一个m×n的区域矩阵数组，每行的元素间以空格分隔，其中元素取值仅为−1(障碍)、0(垃圾处理站)、</span></span><br><span class="line"><span class="comment">1(小区)、2(空白区域)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">一个整数，表示所计算的最小距离和。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> hasXiaoqu = <span class="literal">false</span>,hasLajizhan=<span class="literal">false</span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; xiaoqu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="comment">//判断是否有小区和垃圾站并记录小区</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>) hasLajizhan=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j]==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hasXiaoqu=<span class="literal">true</span>;</span><br><span class="line">                xiaoqu.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dx=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dy=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!hasLajizhan||!hasXiaoqu)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    queue&lt;pair&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt;&gt; q; <span class="comment">//定义队列，元素为坐标绑定步数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> xq : xiaoqu) <span class="comment">//每个小区各进行一轮BFS</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) <span class="comment">//把上一个小区所遗留的队列清空</span></span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;&#123;xq.first,xq.second&#125;,<span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> step=cur.second; <span class="comment">//步数迭代</span></span><br><span class="line">            visited[cur.first.first][cur.first.second]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map[cur.first.first][cur.first.second]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=step;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> newX = cur.first.first+dx[i];</span><br><span class="line">                <span class="type">int</span> newY = cur.first.second+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> </span><br><span class="line">                    &amp;&amp; newY &lt; n &amp;&amp; map[newX][newY]!=<span class="number">-1</span> </span><br><span class="line">                    &amp;&amp; visited[newX][newY]!=<span class="number">1</span>) <span class="comment">//不越界，不调头，不是墙</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;&#123;newX,newY&#125;,step<span class="number">+1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<br>





      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" data-id="cmfva0ttp0006wo96453g5dbh" data-title="算法笔记(C++) ——广度优先搜索" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——深度优先搜索" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="article-date">
  <time class="dt-published" datetime="2025-09-10T14:06:32.000Z" itemprop="datePublished">2025-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">算法笔记(C++) ——深度优先搜索</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>深度优先搜索(Depth First Search , DFS)是一种用于遍历或搜索图（图可以是树、无向图、有向图等）的算法。它按照深度优先的策略，优先访问当前节点的下一层邻接节点，直到无法继续为止，再回溯到上一层。可以粗略的理解为：DFS就是在图上做特定的递归，DFS⊂递归。  </p>
<h2 id="树的存储和遍历"><a href="#树的存储和遍历" class="headerlink" title="树的存储和遍历"></a>树的存储和遍历</h2><p><strong>树的两种读入方式：</strong></p>
<ol>
<li>边形式:</li>
</ol>
<ul>
<li>存储：这种读入形式将树看成一张图进行读入，本质就是上一篇中的的读入形式，所以可以使用邻接表（记录对应节点的相邻节点信息的表格）直接存储。但特别要注意的是，虽然树在定义上是有向图，但有时读入的数据可能会不符合其定义。例如，树中的一条有向边从节点 1 指向节点 2，但在输入时可能会以 2 1 的形式读入，所以为了能够正确进行遍历，就需要使用无向图的存储方式(也就是对于读入进来的边，正反都存储一遍)。  </li>
<li>遍历:由于存储结构被迫变成了无向图(虽然它本应该是有向图的结构)，那么在递归遍历的时候(或者说在深度优先搜索的过程中)，我们需要注意由于返祖边的存在导致的无限递归（返祖边:假设树里存在一条从节点 1 指向节点 2的有向边1 2。那么1是2的父亲，也是2的祖先。但在实际的存储中又存在从2指向1的边2 1。那么2 1 就是一条返祖边）。<br>解决方法: 增加父亲参数father，禁止由子节点访问父节点。</li>
</ul>
<ol start="2">
<li>父亲数组：</li>
</ol>
<ul>
<li>存储：树中的每个节点都有唯一的父节点，这种唯一性使得我们可以通过数组来存储父节点信息。所以树可以用父亲数组（father[]）来表示树的结构。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：一棵简单的树  </span><br><span class="line"></span><br><span class="line">树的结构：</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">父亲数组表示：</span><br><span class="line">father[1] = 0  （根节点无父节点，约定为 0）</span><br><span class="line">father[2] = 1  （节点 2 的父亲是 1）</span><br><span class="line">father[3] = 1  （节点 3 的父亲是 1）</span><br><span class="line">father[4] = 3  （节点 4 的父亲是 3）</span><br><span class="line">father[5] = 3  （节点 5 的父亲是 3）</span><br><span class="line"></span><br><span class="line">父亲数组：father = [0, 1, 1, 3, 3]</span><br></pre></td></tr></table></figure>
<p>但由于我们访问的顺序是从父亲到儿子，而父亲数组存储的是每个儿子的父亲。所以我们无法直接利用父亲数组进行DFS。我们还是将父亲数组转化为邻接表进行存储：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adjList[father[i]].<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历：<br>在这种读入形式下，不再存在第一种形式所提及的无限递归问题。可以直接进行遍历。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">sort</span>(adjList[i].<span class="built_in">begin</span>(), adjList[i].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> parent)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	traversalResult.<span class="built_in">push_back</span>(node); <span class="comment">// 访问当前节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;child : adjList[node]) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span>(child != parent) </span><br><span class="line">        &#123; <span class="comment">// 避免回到父节点</span></span><br><span class="line">			<span class="built_in">DFS</span>(child, node); <span class="comment">// 递归访问子节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong><br><code>vector&lt;int&gt; matrix(MAX);</code>和<code>vector&lt;int&gt; arr[MAX];</code>的区别：<br>在 C++ 中，二者是两种完全不同的定义方式，核心区别在于数据结构的类型和用途：  </p>
<ul>
<li><code>vector&lt;int&gt; tree(MAX);</code><br>本质：定义一个单个 vector<int> 对象，其元素为int类型，并指定其初始大小为 MAX。<br>这个 vector 会预先分配能容纳 MAX 个 int 元素的内存，且每个元素会被默认初始化（int 类型默认值为 0）。<br>用途：需要一个初始大小固定的动态数组时使用，例如需要存储 MAX 个元素的序列。</li>
<li><code>vector&lt;int&gt; tree[MAX];</code><br>本质：定义一个数组，数组的每个元素都是一个 vector<int> 对象。<br>其中 MAX 是数组的大小（必须是编译期常量），表示这个数组包含 MAX 个 vector<int> 容器。<br>用途：通常用于表示邻接表（如树、图的存储），例如 tree[i] 表示第 i 个节点的所有邻接节点。</li>
</ul>
<br>





<h2 id="DFS的核心思想与实现方式"><a href="#DFS的核心思想与实现方式" class="headerlink" title="DFS的核心思想与实现方式"></a>DFS的核心思想与实现方式</h2><p><strong>核心思想：</strong>  </p>
<ul>
<li>DFS 的本质是 “不撞南墙不回头”，其关键在于 “回溯”（Backtracking）—— 当当前路径无法继续探索时，撤销上一步的选择，回到之前的状态并尝试新的可能性。可以用一个生活化的例子理解：假设你走进一个迷宫，面前有 3 条岔路（A、B、C）。DFS 会先选择岔路 A，一直走到尽头（可能是出口，也可能是死胡同）；如果是死胡同，就退回到岔路口，再选择岔路 B，重复探索；最后再探索岔路 C。整个过程中，“退回岔路口” 就是回溯，“走到底” 就是深度优先。</li>
</ul>
<p><strong>实现方式：</strong></p>
<ul>
<li>根据其“走到底”的特性，DFS可以看作是一种特殊的递归算法，同时树又是DFS的典型应用场景。以下是一道运用递归对树的各节点&#x2F;子树进行深度优先搜索的例题：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">有一棵有n个节点的树，根节点为1号节点，树的每个节点是红色或者黑色，想知道有多少节点的子树中同时包含红点和黑点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">第一行输入一个整数n表示节点数量</span></span><br><span class="line"><span class="comment">第二行输入一个长度为n的字符串s表示节点的颜色，第i个节点的颜色为si ，若si为&#x27;B&#x27;表示节点的颜色为黑色，若si为&#x27;R&#x27; 则表示节点的颜色为红色。 接下来n−1行，每行输入两个整数 u,v(1≤u,v≤n)表示树上的边.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">输出一个整数表示答案。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量邻接表、颜色信息向量、结果值</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; colors;</span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 标记当前子树是否包含红色和黑色</span></span><br><span class="line">    <span class="type">bool</span> hasRed = <span class="literal">false</span>, hasBlack = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (colors[node] == <span class="string">&#x27;R&#x27;</span>) hasRed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> hasBlack = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj[node]) <span class="comment">//遍历每一个孩子节点，探索每一种可能性（回溯）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (neighbor != parent) <span class="comment">//邻接表是无向的，应确保搜索的是子树而不是父节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">bool</span>&gt; child = <span class="built_in">dfs</span>(neighbor, node);</span><br><span class="line">            <span class="comment">//针对每一个孩子节点，递归调用进行深度优先搜索（DFS）</span></span><br><span class="line">            <span class="keyword">if</span>(child[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                hasRed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(child[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                hasBlack = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前子树既有红色又有黑色节点，则满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (hasRed &amp;&amp; hasBlack)</span><br><span class="line">    &#123;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;hasRed, hasBlack&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//根据输入的n对全局变量resize</span></span><br><span class="line">    colors.<span class="built_in">resize</span>(n);</span><br><span class="line">    adj.<span class="built_in">resize</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; colors[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        adj[u<span class="number">-1</span>].<span class="built_in">push_back</span>(v<span class="number">-1</span>); <span class="comment">//由于题目中的根节点是从1开始标号</span></span><br><span class="line">        adj[v<span class="number">-1</span>].<span class="built_in">push_back</span>(u<span class="number">-1</span>); <span class="comment">//故而实际代码中应先-1后再存入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" data-id="cmfva0ttq0007wo96hym90yw3" data-title="算法笔记(C++) ——深度优先搜索" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——图的存储" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/" class="article-date">
  <time class="dt-published" datetime="2025-09-10T10:11:36.000Z" itemprop="datePublished">2025-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/">算法笔记(C++) ——图的存储</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul>
<li>稀疏图：边的数量远小于顶点数的平方。  </li>
<li>稠密图：边的数量接近顶点数的平方。  </li>
<li>有向图：边具有方向性。  </li>
<li>无向图：边没有方向，可以视作双向边。  </li>
<li>有权图与无权图：有权图的边具有权值，无权图的边没有权值。</li>
</ul>
<p><br><br></p>
<h2 id="邻接矩阵（Adjacency-Matrix）"><a href="#邻接矩阵（Adjacency-Matrix）" class="headerlink" title="邻接矩阵（Adjacency Matrix）"></a>邻接矩阵（Adjacency Matrix）</h2><p>邻接矩阵用一个二维数组表示图，matrix[i][j] 表示从顶点 i 到 j 的边的信息（例如 1 代表有边，0 代表无边），适用于稠密图。<br><img src="/images/cpp_8_1.png" alt=" ">  </p>
<p><strong>实现：</strong>  </p>
<ol>
<li>建表操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立一张具有n个节点的图，此时这张图没有任何一条边</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjMatrix</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>加边操作<br>有时，一张图的读入通常以给定若干条边u v w 的形式给出，其中u代表这条边的起点,v代表这条边的终点,w代表这条边的权值。如果不含w，则读入的是无权图。<br>对于邻接矩阵而言，需要了解如何对一张图进行加边操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    adjMatrix[u][v] = <span class="number">1</span>;</span><br><span class="line">    adjMatrix[v][u] = <span class="number">1</span>; <span class="comment">// 无向图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>输出邻接矩阵</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        cout &lt;&lt; (adjMatrix[i][j] ? <span class="string">&quot;有边&quot;</span> : <span class="string">&quot;无边&quot;</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h2 id="邻接表（Adjacency-List）"><a href="#邻接表（Adjacency-List）" class="headerlink" title="邻接表（Adjacency List）"></a>邻接表（Adjacency List）</h2><p>对于稀疏图，邻接表是一种更高效的存储方式，只存储实际存在的边，使用数组或 vector 存储每个顶点的邻居列表。<br><img src="/images/cpp_8_1.png" alt=" "> </p>
<p><strong>实现：</strong>  </p>
<ol>
<li>建表操作<br>使用结构体表示边信息，如果是无权图，可以直接使用 vector<int> adjList[n + 1]：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjList</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或定义边的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">adjList</span>(n + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>加边操作<br>无向图的加边操作：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    adjList[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">    adjList[v].<span class="built_in">push_back</span>(&#123;u, w&#125;); <span class="comment">// 无向图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>遍历操作<br>遍历邻接表的示例：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot; connects to &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> edge : adjList[u]) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; edge.to &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; edge.weight &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/" data-id="cmfva0tto0004wo9659srbyig" data-title="算法笔记(C++) ——图的存储" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——双指针" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88/" class="article-date">
  <time class="dt-published" datetime="2025-08-31T13:37:05.000Z" itemprop="datePublished">2025-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88/">算法笔记(C++) ——双指针</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="双指针算法概述"><a href="#双指针算法概述" class="headerlink" title="双指针算法概述:"></a>双指针算法概述:</h2><p>双指针算法（双指针技术）是一种在处理线性数据结构（如数组、链表）时常用的算法策略。它通过同时使用两个指针，以不同的方式遍历数据结构，从而优化时间复杂度或简化问题的解决过程。双指针算法广泛应用于各种经典问题，如数组排序、链表操作、字符串处理等。  </p>
<ul>
<li>双指针的常见类型</li>
</ul>
<ol>
<li><p>快慢指针（快指针与慢指针）:  </p>
<ul>
<li>用途：常用于检测链表中的环、找到链表的中间节点等。</li>
<li>原理：设定两个指针，快指针一次移动两步，慢指针一次移动一步。如果链表中存在环，快指针最终会与慢指针相遇；如果不存在环，快指针会先到达链表末尾。</li>
</ul>
</li>
<li><p>左右指针（双端指针）:  </p>
<ul>
<li>用途：常用于处理有序数组中的问题，如两数之和、三数之和、四数之和等。</li>
<li>原理：设定一个指针指向数组的起始位置，另一个指针指向数组的末尾，根据当前指针对应的值与目标值的关系来移动指针，以缩小搜索范围。</li>
</ul>
</li>
<li><p>滑动窗口:  </p>
<ul>
<li>用途：用于解决字符串或数组中满足特定条件的子串或子数组问题，如最长不重复子串、最小覆盖子串等。</li>
<li>原理：通过维护一个“窗口”区间（左右边界通常由两个指针left和right表示），动态调整窗口的范围来高效地解决问题。窗口扩展：通常通过固定左指针left、右移（枚举）右指针right来扩大窗口，纳入新的元素；窗口收缩：当窗口内不满足条件时，通过固定右指针right、右移左指针left来缩小窗口，排除不需要的元素；动态调整：根据题目要求，动态调整窗口的大小和位置，直到找到满足条件的解。</li>
</ul>
</li>
</ol>
<p><br><br></p>
<h2 id="例题：互相嘲笑的两个人"><a href="#例题：互相嘲笑的两个人" class="headerlink" title="例题：互相嘲笑的两个人"></a>例题：互相嘲笑的两个人</h2><ul>
<li><p>题目描述：<br>小红和小堡正在玩一个游戏，每一关都有一个分数。如果某人某一关分数比上一关高，但另一个人这一关分数比上一关低，那么他就可以嘲笑对方。如果两个人这一关游戏的分数都比上一关多，则增量更多的可以嘲笑对方;如果两个人这一关游戏的分数都比上一关少，则减量更少的可以嘲笑对方。只有当他们的增量相同或者减量相同时，才不会互相嘲笑。<br>例如，假设小红第一关的分数为2，第二关的分数为8;小堡第一关的分数为5，第二关的分数为10，显然小红增加的比小堡多，那么小红就可以嘲笑小堡。<br>现在给定了小红和小堡每一关的分数，你可以选择一段连续的关卡，使得一段关卡中两个人都不会互相嘲笑，问最多可以选择多少个关卡。特别的一段连续关卡中的第一关两人不会互相嘲笑。</p>
</li>
<li><p>输入：</p>
<ul>
<li>第一行输入一个正整数n,代表关卡数。</li>
<li>第二行输入n个整数a_i,代表小红每一关的分数。</li>
<li>第三行输入n个整数b_i,代表小堡每一关的分数。</li>
</ul>
</li>
<li><p>输出：  </p>
<ul>
<li>输出可以选择最多的关卡数。</li>
</ul>
</li>
<li><p>题解代码：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>,<span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算差分数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diff_a</span><span class="params">(n - <span class="number">1</span>)</span>, <span class="title">diff_b</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        diff_a[i] = a[i + <span class="number">1</span>] - a[i];</span><br><span class="line">        diff_b[i] = b[i + <span class="number">1</span>] - b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = diff_a.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; m &amp;&amp; diff_a[r] == diff_b[r]) &#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算该区间的长度</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 左指针移动到右指针的位置，开始新的检查</span></span><br><span class="line">        l = r + <span class="number">1</span>;</span><br><span class="line">        r = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88/" data-id="cmfva0ttp0005wo96a5rb8pl5" data-title="算法笔记(C++) ——双指针" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——递归" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/" class="article-date">
  <time class="dt-published" datetime="2025-08-25T10:16:14.000Z" itemprop="datePublished">2025-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/">算法笔记(C++) ——递归</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h2><p>递归是一种函数调用自己的编程技巧。递归的基本思想是将一个复杂的问题分解为更简单的子问题，直到子问题的规模足够小，能够直接解决。递归通常由两个部分组成：</p>
<ol>
<li>终止条件：递归的终止条件，防止无限递归。</li>
<li>递归调用：将当前问题转化为更小规模的同类问题，并在其上进行求解。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数计算斐波那契数列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 斐波那契数列的第0项</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 斐波那契数列的第1项</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n - <span class="number">1</span>) + <span class="built_in">fibonacci</span>(n - <span class="number">2</span>); <span class="comment">// 递归计算F(n)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n; <span class="comment">// 输入整数n</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">fibonacci</span>(n) &lt;&lt; endl; <span class="comment">// 输出斐波那契数列的第n项</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h2 id="树以及二叉树的概念"><a href="#树以及二叉树的概念" class="headerlink" title="树以及二叉树的概念"></a>树以及二叉树的概念</h2><ol>
<li>树（Tree）：<br>树是一种由节点（Node）组成的非线性数据结构，其中的每个节点可以有零个或多个子节点。树通常用来表示层次结构的数据关系，比如文件系统、家谱等。<br><code>根节点（Root）</code>：树中的第一个节点，根节点没有父节点。<br><code>父节点（Parent）</code>：一个节点的直接上级节点。<br><code>子节点（Child）</code>：一个节点的直接下级节点。<br><code>叶子节点（Leaf）</code>：没有任何子节点的节点。<br><code>深度（Depth）</code>：从根节点到当前节点的路径长度。<br><code>高度（Height）</code>：从当前节点到叶子节点的最长路径长度。<br><code>度（Degree）</code>：节点的子节点数目。</li>
</ol>
<ul>
<li>树的常见类型有：  <ul>
<li>二叉树：每个节点最多有两个子节点。</li>
<li>平衡树：比如AVL树，二叉搜索树（BST）等，它们有一些特定的规则来保证树的平衡性。</li>
</ul>
</li>
</ul>
<br>
2. 二叉树（Binary Tree）：  
二叉树是一种特殊的树结构，它的每个节点最多有两个子节点，通常称为左子节点和右子节点。二叉树是最常见的一种树结构，广泛应用于各种算法和数据结构中。  

<ul>
<li><p>二叉树的性质：  </p>
<ol>
<li>每个节点最多有两个子节点。  </li>
<li>每个节点有两个指针，一个指向左子节点，另一个指向右子节点。</li>
</ol>
</li>
<li><p>二叉树的类型：  </p>
<ol>
<li>满二叉树：所有的非叶子节点都有两个子节点，且所有叶子节点都在同一层。  </li>
<li>完全二叉树：除了最后一层外，其他每一层的节点都达到最大节点数，且最后一层的节点从左到右连续排列。  </li>
<li>二叉搜索树（BST）：对于每一个节点，其左子树的所有节点值都小于该节点的值，右子树的所有节点值都大于该节点的值。  </li>
<li>平衡二叉树（AVL树、红黑树）：为了保持高效的查询、插入和删除操作，这些树会自动保持平衡，即左右子树的高度差不超过某个阈值。</li>
</ol>
</li>
<li><p>二叉树的遍历：  </p>
<ol>
<li>前序遍历（Pre-order）：访问根节点，再访问左子树，最后访问右子树。</li>
<li>中序遍历（In-order）：访问左子树，再访问根节点，最后访问右子树。 </li>
<li>后序遍历（Post-order）：访问左子树，再访问右子树，最后访问根节点。</li>
<li>层序遍历（Level-order）：从上到下、从左到右按层次遍历。</li>
</ol>
</li>
</ul>
<p><br><br></p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树是一种特殊的二叉树，它具有以下特点：</p>
<ol>
<li>每一层节点都要填满：除了最后一层外，完全二叉树的每一层都必须是满的，也就是说，除了最底层，其他层的节点数都达到最大值。  </li>
<li>最后一层的节点尽量靠左：最后一层的节点从左到右依次排列，不能有空缺。也就是说，最后一层的节点虽然可以不满，但必须尽量靠左对齐。</li>
</ol>
<p>完全二叉树的一个重要特点是，它是非常紧凑的结构，不像普通二叉树那样可能会出现大量的空白位置。由于这一特性，完全二叉树通常用于堆数据结构（例如最大堆或最小堆）中，因为在这种树形结构下，插入和删除节点的操作效率较高。</p>
<p>举例说明：<br>假设有7个节点，它们按顺序排列构建成完全二叉树，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   / </span><br><span class="line">4   5 6   </span><br></pre></td></tr></table></figure>
<ol>
<li>这棵树的第1层有1个节点，第2层有2个节点，第3层有3个节点。</li>
<li>最后一层的节点是从左到右依次排列的，没有空缺。</li>
</ol>
<p><br><br></p>
<h2 id="例题：路径统计"><a href="#例题：路径统计" class="headerlink" title="例题：路径统计"></a>例题：路径统计</h2><ul>
<li><p>题目描述：<br>给定一个大小为 n * n 的二维网格。你从坐标 (sx, sy) 出发，允许你每次移动到上下左右四个方向之一。每次移动的步数记为 1 步。现在给定一个目标坐标 (ex, ey)，请问在最多  k  步以内，你可以到达目标位置 (ex, ey) 的不同路径数。<br>请注意，你可以在任何时刻选择停止，不一定要在刚好  k  步时到达目标。</p>
</li>
<li><p>输入：</p>
<ul>
<li>第一行输入一个整数  n ，表示网格的大小（ 1 \leq n \leq 10 ）。</li>
<li>第二行输入四个整数  sx, sy, ex, ey ，表示起点 (sx, sy) 和终点 (ex, ey) 的坐标。</li>
<li>第三行输入一个整数  k ，表示最多的步数（ 1 \leq k \leq 10 ）。</li>
</ul>
</li>
<li><p>输出：  </p>
<ul>
<li>输出一个整数，表示在最多  k  步以内从 (sx, sy) 到达 (ex, ey) 的不同路径数。</li>
</ul>
</li>
<li><p>题解代码：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, sx, sy, ex, ey, k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> countPaths = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 四个方向：上，下，左，右</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数，当前坐标 (x, y)，已经走的步数 steps</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> steps)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前坐标是终点，则计数加一</span></span><br><span class="line">    <span class="keyword">if</span> (x == ex &amp;&amp; y == ey) </span><br><span class="line">    &#123;</span><br><span class="line">        countPaths++;</span><br><span class="line">        <span class="comment">// 注意：即使达到终点，也可以选择继续移动，直到步数达到 k</span></span><br><span class="line">        <span class="comment">// 所以不在此处 return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经达到最大步数，停止递归</span></span><br><span class="line">    <span class="keyword">if</span> (steps == k)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试四个方向移动</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++) &#123;</span><br><span class="line">        <span class="type">int</span> newX = x + dx[dir];</span><br><span class="line">        <span class="type">int</span> newY = y + dy[dir];</span><br><span class="line">        <span class="comment">// 检查新位置是否在网格内</span></span><br><span class="line">        <span class="keyword">if</span>(newX &gt;= <span class="number">1</span> &amp;&amp; newX &lt;= n &amp;&amp; newY &gt;=<span class="number">1</span> &amp;&amp; newY &lt;=n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(newX, newY, steps + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(sx, sy, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; countPaths;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/25/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/" data-id="cmfva0ttr0009wo96grvscgf2" data-title="算法笔记(C++) ——递归" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——二分法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-08-23T11:40:53.000Z" itemprop="datePublished">2025-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%B3%95/">算法笔记(C++) ——二分法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="查询是否存在某个数"><a href="#查询是否存在某个数" class="headerlink" title="查询是否存在某个数"></a>查询是否存在某个数</h2><p>二分算法是一种高效的查找算法，适用于<code>已经排好序</code>的数组或集合。其基本思想是通过每次将待查找的区间分成两半来逐步缩小查找范围，从而快速定位目标元素。与线性查找不同，二分查找能够大大减少查找次数，时间复杂度为<code>O(log n)</code>，其中n为数组的长度，效率远高于线性查找（<code>O(n)</code>）。<br><strong>查找过程：</strong>   </p>
<ol>
<li>设定一个查找范围的左右边界（双指针），通常用两个变量表示，low 和 high。</li>
<li>计算当前区间的中间元素：mid &#x3D; (low + high) &#x2F; 2  </li>
<li>将中间元素与目标值进行比较（指针迭代）：<ul>
<li>如果中间元素等于目标值，查找成功，返回该元素的位置。</li>
<li>如果中间元素大于目标值，说明目标值在左半部分，更新high &#x3D; mid - 1。</li>
<li>如果中间元素小于目标值，说明目标值在右半部分，更新low &#x3D; mid + 1。</li>
</ul>
</li>
<li>重复上述过程，直到查找范围为空（low &gt; high），即目标值不存在。<br><strong>二分法例题：</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*给定一个升序排列的整数数组 A 和一个整数 Q，表示接下来有 Q 次查询。</span></span><br><span class="line"><span class="comment">  对于每次查询，您需要判断给定的整数 x 是否存在于数组 A 中。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binarySearch</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)  <span class="comment">//限定条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 找到元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt; x) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 查找右半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 查找左半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 没有找到元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, Q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; Q;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">A</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; A[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对每个查询进行二分查找</span></span><br><span class="line">    <span class="keyword">while</span> (Q--)   <span class="comment">//共有 Q 次询问</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用手写的二分查找函数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">binarySearch</span>(A, x)) </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h2 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort()函数"></a>sort()函数</h2><p><code>sort(arr.begin(),arr.end());</code><br>对数组进行从小到大排序。</p>
<p><br><br></p>
<h2 id="lower-bound函数与upper-bound函数"><a href="#lower-bound函数与upper-bound函数" class="headerlink" title="lower_bound函数与upper_bound函数"></a>lower_bound函数与upper_bound函数</h2><p>在C++中，<code>lower_bound</code>和<code>upper_bound</code>是两个常用的标准库函数，位于<code>&lt;algorithm&gt;</code>头文件中。这两个函数主要用于在<code>已排序好的</code>范围内进行二分查找，帮助快速定位元素的位置。  </p>
<ol>
<li><strong>lower_bound:</strong><br><code>lower_bound</code>函数返回一个指向第一个不小于（&gt;&#x3D;）给定值的元素的迭代器。如果所有元素都小于该值，则返回范围的结束迭代器（arr.end()）。<br>示例：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">3</span>);  <span class="comment">//用auto定义</span></span><br><span class="line">    <span class="keyword">if</span> (p != v.<span class="built_in">end</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;lower_bound of 3 is at position: &quot;</span> &lt;&lt; (p - arr.<span class="built_in">begin</span>()) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：lower_bound of 3 is at position: 1</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>upper_bound:</strong><br><code>upper_bound</code>函数返回一个指向第一个大于（&gt;）给定值的元素的迭代器。如果所有元素都小于该值，则返回范围的结束迭代器（arr.end()）。<br>示例：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="number">3</span>);  <span class="comment">//用auto定义</span></span><br><span class="line">    <span class="keyword">if</span> (p != v.<span class="built_in">end</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;upper_bound of 3 is at position: &quot;</span> &lt;&lt; (p - arr.<span class="built_in">begin</span>()) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：upper_bound of 3 is at position: 3</span></span><br></pre></td></tr></table></figure>
<p>特别地：<br><code>count = upper_bound(arr.begin(),arr.end(),x)-lower_bound(arr.begin(),arr.end(),x);</code><br>即为x在数组arr中出现的次数。  </p>
<ul>
<li>为什么要使用<code>(p - arr.begin())</code>?<br>在上述示例中，p 是一个迭代器，指向容器中某个元素的位置。为了输出该元素在容器中的索引位置，需要将迭代器转换为整数索引。这时，使用 <code>(p - arr.begin())</code>进行迭代器的减法运算，其意义如下：<ol>
<li>迭代器的减法：在C++中，随机访问迭代器（如 std::vector 的迭代器）支持直接的减法运算。<code>p - arr.begin()</code>计算的是 p 距离 arr.begin() 的距离，即 p 所指向元素的索引。</li>
<li>得到索引：通过<code>(p - arr.begin())</code>，可以将迭代器位置转换为具体的索引值，方便在输出或后续操作中使用。例如：<br>  <code>cout &lt;&lt; &quot;lower_bound of 3 is at position: &quot; &lt;&lt; (p - arr.begin()) &lt;&lt; endl;</code><br>  这行代码输出的是 3 在向量 arr 中第一次出现的位置索引 1。</li>
<li>通用性：这种方法不仅适用于<code>std::vector</code>，对于任何支持随机访问的容器（如<code>std::deque</code>、<code>std::array</code>），都可以使用迭代器减法来获取元素的索引。</li>
</ol>
</li>
</ul>
<p><strong>注解：</strong><br>在上述向量 arr 共有 5 个元素，索引分别为0，1，2，3，4，<code>arr.begin()</code>指代的是 0 号索引，<code>arr.end()</code>指代的是5号索引（不存在，其对应元素值记为 0 ），p所指代的是某个元素的位置，通过加减符可以转化为整数索引用于输出，而可以用<code>*p</code>指代p所指的元素，例如在upper_bound示例中，<code>*p</code>即为 5 。  </p>
<p><br><br></p>
<h2 id="ios-sync-with-stdio-false-cin-tie-0"><a href="#ios-sync-with-stdio-false-cin-tie-0" class="headerlink" title="ios::sync_with_stdio(false); &amp; cin.tie(0);"></a>ios::sync_with_stdio(false); &amp; cin.tie(0);</h2><ol>
<li><code>ios::sync_with_stdio(false);</code><br>C++ 标准库的输入输出（cin&#x2F;cout）默认会与 C 语言的输入输出（scanf&#x2F;printf）同步，目的是保证混用两种 I&#x2F;O 方式时的安全性（避免输出顺序混乱）。<br>但这种同步会带来性能开销，导致cin&#x2F;cout的速度变慢。<br>这行代码的作用是关闭同步，使cin&#x2F;cout不再与 C 语言的 I&#x2F;O 绑定，从而提高效率。</li>
<li><code>cin.tie(0);</code><br>tie()是一个函数，用于关联输入流（cin）和输出流（cout）。默认情况下，cin会与cout绑定，即每次执行cin前会自动刷新cout的缓冲区（确保输出内容先显示）。<br>这行代码的作用是解除cin与cout的绑定（参数0表示不关联任何流），减少不必要的缓冲区刷新操作，进一步提升输入效率。</li>
</ol>
<ul>
<li>注意：  <ul>
<li>关闭同步后，不能混用cin&#x2F;cout与scanf&#x2F;printf，否则可能导致输出顺序错误。</li>
<li>这两行代码通常成对出现，且需放在所有 I&#x2F;O 操作之前（如main函数开头），才能发挥优化效果。</li>
<li>对于需要大量输入输出的场景（如算法竞赛），这两行代码能显著提升程序运行速度。</li>
</ul>
</li>
<li>示例代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">给定一个升序排列的数组 arr，长度为 n，以及 Q 次询问。每次询问</span></span><br><span class="line"><span class="comment">都会给出一个目标值 target。对于每个目标值，请找出数组中比目标</span></span><br><span class="line"><span class="comment">值小的最大值 max_val 和比目标值大的最小值 min_val。</span></span><br><span class="line"><span class="comment">具体而言，要求对于每个询问：</span></span><br><span class="line"><span class="comment">从arr 所有小于 target 的元素中找到最大值 max_val。</span></span><br><span class="line"><span class="comment">从arr 所有大于 target 的元素中找到最小值 min_val。</span></span><br><span class="line"><span class="comment">如果不存在比 target 小的值，则 max_val 输出为 -1；</span></span><br><span class="line"><span class="comment">如果不存在比 target 大的值，则 min_val 输出为 -1。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);  <span class="comment">//&lt;--</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);  <span class="comment">//&lt;--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n,q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pos_max = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), num) - arr.<span class="built_in">begin</span>() <span class="number">-1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> max_val = (pos_max &gt;=<span class="number">0</span>) ? arr[pos_max] : <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> pos_min = <span class="built_in">upper_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), num) - arr.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> min_val = (pos_min &lt; n) ? arr[pos_min] : <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; max_val &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; min_val &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%B3%95/" data-id="cmfva0tto0003wo963y9jchql" data-title="算法笔记(C++) ——二分法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——哈希表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2025-08-22T14:13:28.000Z" itemprop="datePublished">2025-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/">算法笔记(C++) ——哈希表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="哈希表的概念"><a href="#哈希表的概念" class="headerlink" title="哈希表的概念"></a>哈希表的概念</h2><p>哈希表是一种基于哈希函数（Hash Function）的数据结构，用于实现键值对的快速存储和查找。它的主要特点是：</p>
<ol>
<li><p>快速查找：平均情况下，<strong>哈希表的查找、插入和删除操作的时间复杂度都是<code>O(1)</code></strong>。</p>
</li>
<li><p>键值对存储：哈希表存储的是键值对，每个键（Key）唯一对应一个值（Value）。</p>
</li>
<li><p>哈希函数：通过哈希函数将键映射到哈希表中的位置，从而实现快速存取。</p>
</li>
</ol>
<p><strong>C++ 中的哈希表 ——<code>unordered_map</code>：</strong>   </p>
<p>在 C++ 中，<code>unordered_map</code>是标准库提供的哈希表实现。它具有以下特点：</p>
<ol>
<li><p>键值对存储：unordered_map&lt;Key, T&gt; 存储的是键为 Key，值为 T 的键值对。</p>
</li>
<li><p>快速访问：提供了常数时间复杂度的查找、插入和删除操作。</p>
</li>
</ol>
<p><strong>主要操作：</strong>   </p>
<ol>
<li>插入元素：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash_map;  <span class="comment">//定义哈希表</span></span><br><span class="line">hash_map[key] = value;  <span class="comment">// 插入或更新键为 key 的值为 value</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查找元素： 在C++的<code>unordered_map</code>（或<code>map</code>）中，<code>find(key)</code>方法用于查找关键字<code>key</code>是否存在。<code>find(key)</code>返回一个迭代器，如果<code>key</code>存在，迭代器指向元素，否则指向<code>end()</code>。使用<code>find(key)</code>可以高效检查<code>key</code>的存在。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hash_map.<span class="built_in">find</span>(key) != hash_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 找到了 key</span></span><br><span class="line">    <span class="type">int</span> value = hash_map[key];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没找到 key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>获取某键key的键值：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = hash_map[key];  <span class="comment">// 如果key不存在，会自动插入key并初始化值为0</span></span><br></pre></td></tr></table></figure>
<p><strong>示例代码（有一个包含n个整数的口袋，同时提出q个问题，每个问题询问特定的数字在口袋中出现了多少次。）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,q,num;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;  <span class="comment">//定义哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        map[num]++;   </span><br><span class="line">        <span class="comment">//如果key不存在，会自动插入key并初始化值为0，遇到相应key键时对应的键值自增</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        <span class="keyword">if</span>(map.<span class="built_in">find</span>(num)!=map.<span class="built_in">end</span>())  <span class="comment">//如果能找到对应键值的话</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; map[num] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;   <span class="comment">//如果找不到对应键值，则输出0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>在编写程序时，时间复杂度（Time Complexity）是一个重要指标。时间复杂度描述了程序运行时间与输入规模之间的关系。<br>OJ 一般 C++ 1秒大概能跑1e8量级。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;x;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; i++) &#123;</span><br><span class="line">		ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于这个简单的代码，x &lt; 1e8，运行不会超时；x &gt; 1e8，运行超时。</span></span><br></pre></td></tr></table></figure>

<p><strong>常见的时间复杂度包括（从小到大）：</strong></p>
<p><code>O(1)</code>：常数时间，无论输入规模多大，执行时间保持不变。</p>
<p><code>O(log n)</code>：对数时间，随着输入规模增加，执行时间按对数增长。例如二分操作。</p>
<p><code>O(n)</code>：线性时间，执行时间与输入规模成正比。</p>
<p><code>O(n log n)</code>：线性对数时间，常见于高效排序算法如快速排序、归并排序。</p>
<p><code>O(n^2)</code>：平方时间，常见于简单的嵌套循环，如冒泡排序。</p>
<p><code>O(n^3)</code>：立方时间。</p>
<p><code>O(2^n)</code>：指数时间。</p>
<p><code>O(n!)</code>：阶乘时间。</p>
<p><code>O(n^n)</code>：幂指时间。</p>
<p><strong>如何计算时间复杂度：</strong></p>
<ol>
<li><p>识别基本操作：确定算法中最频繁执行的操作，如循环中的语句、递归调用等。</p>
</li>
<li><p>计算基本操作的执行次数：根据输入规模，计算这些操作随着输入增长的次数。</p>
</li>
<li><p>忽略低阶项和常数系数：在大O表示法中，只保留增长最快的项，忽略常数和低阶项。</p>
</li>
</ol>
<br>  

<p>对于上述口袋问题题目而言，<code>q=n=10^5</code>，如果考虑对于每次查询去遍历一遍所有数，复杂度为<code>O(n*Q)=10^10</code>，根据上面的<code>1e8定理</code>，显然1秒钟是跑不完的，可能会被反馈超时（Time Exceeded），因此可以选用哈希表（Hash Table）的方式来统计每个数字出现的次数，使用C++提供的<code>unordered_map</code>来实现哈希表，因其具有平均<code>O(1)</code>的查找和插入时间复杂度，故能够高效地回答每个查询。    </p>
<p><br><br></p>
<h2 id="STL容器的嵌套使用"><a href="#STL容器的嵌套使用" class="headerlink" title="STL容器的嵌套使用"></a>STL容器的嵌套使用</h2><p>STL（Standard Template Library）容器的嵌套是指在一个容器中存储另一个容器作为其元素。例如，可以用<code>vector&lt;vector&gt;</code>表示一个二维数组，或用<code>map&lt;int, vector&gt;</code>表示一种键值对的映射。通过容器的嵌套，可以灵活地表示复杂的数据结构，如树、图、矩阵等。<br>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">给定一个长度为 n 的数组 a 和 q 个询问。每个询问包含一个数 x 和一个整数 k 。</span></span><br><span class="line"><span class="comment">对于每个询问，求数 x 在数组中第 k 次出现的位置（位置从 1 开始）。</span></span><br><span class="line"><span class="comment">如果 x 在数组中出现次数不足 k 次，则输出 −1。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(q)</span></span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; pos; </span><br><span class="line">    <span class="comment">//嵌套定义：键为整数，键值为一维数组的哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">        pos[arr[i]].<span class="built_in">push_back</span>(i<span class="number">+1</span>); <span class="comment">//向键为arr[i]的对应键值（数组）压入元素 i+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,k;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span> (pos[x].<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">            res[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[i]=pos[x][k - <span class="number">1</span>];<span class="comment">//pos[x]是键为x所对应的键值（数组），相当于arr[k-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ; i&lt;q ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; res[i] &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>






<h2 id="哈希表例题-——严格递增三元组"><a href="#哈希表例题-——严格递增三元组" class="headerlink" title="哈希表例题 ——严格递增三元组"></a>哈希表例题 ——严格递增三元组</h2><p><strong>题目描述：</strong><br>给定一个大小为n的数组，找出所有的严格递增三元组(0 ≤ i &lt; j &lt; k &lt; n) , 使得 a[i] &#x3D; a[k] &#x3D; a[j]+1 , 输出其数量<code>（有算法运行时间限制TL）</code>。</p>
<p><strong>输入描述：</strong><br>第一行输入一个正整数 n（3 ≤ n ≤ 10^5）。<br>第二行输入数组元素（1 ≤ a[i] ≤ 10^9）。  </p>
<p><strong>输出描述：</strong><br>一个正整数，代表符合条件的三元组数量。  </p>
<p><strong>题目分析：</strong><br>我们需要找出所有符合条件的严格递增三元组 (i, j, k)，使得：<br><code>1 &lt;= i &lt; j &lt; k &lt;= n</code><br><code>a[i] = a[k] = a[j] + 1</code><br>换句话说，给定一个数 a[j] ，我们希望找到两个 i 和 k，使得 a[i] &#x3D; a[k] &#x3D; a[j] + 1 且 i &lt; j &lt; k。这可以形象地看作寻找形如 (x+1 , x , x+1) 的三元组。将求和过程先聚焦于中间的这个 x ，那么最终的答案等价于：</p>
<ol>
<li>对于位置 i 的数 a[i] , 寻找它前缀中 a[i]+1 的个数和后缀中 a[i]+1 的个数 , 根据乘法原理，答案是个数相乘</li>
<li>对每个位置的个数进行求和。</li>
</ol>
<p><strong>示例代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用哈希表存储频率</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; countLeft;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; countRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 countRight</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        countRight[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每个元素，计算符合条件的三元组数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = a[i] + <span class="number">1</span>;  <span class="comment">// 计算 t = a[j] + 1</span></span><br><span class="line">        res += countLeft[t] * countRight[t];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 countLeft 和 countRight</span></span><br><span class="line">        countLeft[a[i]]++;</span><br><span class="line">        countRight[a[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h2 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h2><p>哈希表（Hash Table）和哈希集合（Hash Set）都是基于哈希表数据结构实现的，但它们在存储内容和用途上有明显区别：  </p>
<ul>
<li>核心区别：<ul>
<li>存储内容不同<br>  哈希表：存储键值对（Key-Value），例如 {key1: value1, key2: value2}；<br>  哈希集合：仅存储单一元素（Value），相当于只存储键值对中的键（Key），例如 {value1, value2, value3}；  </li>
<li>主要用途不同<br>  哈希表：用于通过键快速查找对应的值，适合需要键值映射关系的场景（如字典、缓存）；<br>  哈希集合：用于快速判断某个元素是否存在，适合去重、 membership 检查等场景；  </li>
<li>元素特性<br>  两者都不允许重复的 “键”（哈希集合中元素本身就是键）；<br>  哈希表可以通过键关联额外数据，哈希集合仅关注元素本身是否存在。</li>
</ul>
</li>
<li>举例：  <ul>
<li>哈希表：<code>unordered_map&lt;int, string&gt;</code>存储 {1: “a”, 2: “b”}；</li>
<li>哈希集合：<code>unordered_set&lt;int&gt;</code>存储 {1, 2, 3}。</li>
</ul>
</li>
</ul>
<p>简单来说，哈希集合可以看作是哈希表的一种特殊形式（只存键不存值），两者都提供 O (1) 平均时间复杂度的插入、删除和查找操作。  </p>
<br>






      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%93%88%E5%B8%8C%E8%A1%A8/" data-id="cmfva0ttq0008wo9699et3h9z" data-title="算法笔记(C++) ——哈希表" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%A0%88/" class="article-date">
  <time class="dt-published" datetime="2025-08-15T09:36:38.000Z" itemprop="datePublished">2025-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%A0%88/">算法笔记(C++) ——栈</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="栈的特性："><a href="#栈的特性：" class="headerlink" title="栈的特性："></a>栈的特性：</h2><p><code>LIFO（后进先出）原则</code>：栈中的元素是从栈顶添加和移除的，栈顶的元素是最先被访问的。<br><code>只能在一端操作</code>：栈的操作只能在栈顶进行。  </p>
<p><br><br></p>
<h2 id="栈的应用："><a href="#栈的应用：" class="headerlink" title="栈的应用："></a>栈的应用：</h2><p><code>函数调用管理</code>：在程序运行过程中，函数调用的顺序和返回都由栈来管理。每次函数调用时，程序会把当前函数的信息压入栈中，函数执行完成后会从栈中弹出，返回到调用函数的位置。<br><code>表达式求值</code>：栈常用于数学表达式的求值，尤其是处理括号匹配和运算符优先级时。<br><code>浏览器的历史记录</code>：浏览器在你浏览网页时会将每个页面的链接压入栈中，这样你按回退按钮时就可以弹出最近访问的页面。  </p>
<p><br><br></p>
<h2 id="栈的实现："><a href="#栈的实现：" class="headerlink" title="栈的实现："></a>栈的实现：</h2><p>栈可以通过数组或链表来实现。常见的实现方式有：<br><code>数组实现</code>：使用数组来存储栈的元素，栈顶指针记录栈顶元素的位置。<br><code>链表实现</code>：通过链表的头结点来表示栈顶，头结点指向栈顶元素。<br>栈的操作时间复杂度通常是<code>O(1)</code>，即每次操作的时间是常数级别的，因为它只涉及栈顶元素.  </p>
<p><br><br></p>
<h2 id="栈的C-实现和操作"><a href="#栈的C-实现和操作" class="headerlink" title="栈的C++实现和操作"></a>栈的C++实现和操作</h2><p><strong>C++自带的<code>stack</code>容器：</strong><br>C++中的<code>stack</code>是一个标准库容器，用来实现栈（Stack）数据结构。栈是一种后进先出（LIFO，Last In, First Out）的数据结构，意味着最后加入的元素会最先被移除。C++的stack容器是基于其他容器（例如deque或vector）实现的，但提供了一个简化的接口，专注于栈的基本操作。</p>
<p><strong>stack的主要操作:</strong>  </p>
<ol>
<li><code>push()</code>： 向栈顶添加一个元素。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">10</span>);  <span class="comment">// 栈顶添加元素10</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">20</span>);  <span class="comment">// 栈顶添加元素20</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">30</span>);  <span class="comment">// 栈顶添加元素30</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>pop()</code>： 移除栈顶的元素，但并不返回该元素。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">pop</span>();  <span class="comment">// 移除栈顶元素30</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>top()</code>： 返回栈顶的元素，但不移除它。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; s.<span class="built_in">top</span>();  <span class="comment">// 输出栈顶元素20</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>empty()</code>： 检查栈是否为空。如果栈为空，返回true，否则返回false。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;栈是空的&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;栈不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><code>size()</code>： 返回栈中元素的数量。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;栈的大小：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 输出栈中的元素数量</span></span><br></pre></td></tr></table></figure>
<p><strong>示例代码（合法括号判断）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;  <span class="comment">// 输入括号字符串</span></span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; stk;  <span class="comment">// 创建一个栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(ch);  <span class="comment">// 遇到左括号，压入栈中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;  <span class="comment">// 栈为空，说明没有匹配的左括号</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">pop</span>();  <span class="comment">// 弹出栈顶元素，匹配对应的左括号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果栈为空，说明所有左括号都有匹配</span></span><br><span class="line">    cout &lt;&lt; (stk.<span class="built_in">empty</span>() ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; endl;  <span class="comment">// 输出结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，C++中的stack是一个非常简单且高效的数据结构，适合处理“先进后出”类型的需求。  </p>
<p><br><br></p>
<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>auto 是 C++11 引入的一个关键字，主要用于自动推导变量的类型。它使得编程变得更加简洁，减少了显式指定类型的需求，特别是当类型复杂或不容易记住时。  </p>
<p><strong>使用场景：</strong></p>
<ol>
<li>变量声明：在声明变量时，可以使用 auto 来代替显式的类型声明，编译器会根据右边的表达式自动推导出变量的类型。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;  <span class="comment">// x的类型是int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.14</span>;  <span class="comment">// y的类型是double</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>容器迭代器：在使用 STL 容器（如 vector）时，容器的迭代器类型通常比较复杂。使用 auto 可以让代码更加简洁和易读。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>函数返回类型：如果函数返回一个复杂的类型或是模板类型，使用 auto 可以减少繁琐的类型声明。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">// 返回值类型为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>范围 for 循环：在范围 for 循环中，auto 用来推导容器中元素的类型。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;  <span class="comment">// num 的类型是int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%A0%88/" data-id="cmfva0tts000bwo96fy4899v3" data-title="算法笔记(C++) ——栈" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——字符串" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
  <time class="dt-published" datetime="2025-08-15T08:51:38.000Z" itemprop="datePublished">2025-08-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/">算法笔记(C++) ——字符串</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="常用的string成员函数"><a href="#常用的string成员函数" class="headerlink" title="常用的string成员函数"></a>常用的string成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">string s1;                <span class="comment">// 默认构造，创建一个空字符串</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;Hello, C++!&quot;</span>)</span></span>; <span class="comment">// 用常量字符串构造</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>;            <span class="comment">// 用另一个字符串构造（拷贝构造）</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;       <span class="comment">// 创建一个长度为 10 的字符串，每个字符为 &#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;World&quot;</span>;  <span class="comment">// 赋新值，原有的内容会被释放并替换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串拼接（连接）</span></span><br><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">string s3 = s1 + <span class="string">&quot; &quot;</span> + s2;  <span class="comment">// 拼接两个字符串</span></span><br><span class="line">s<span class="number">1.</span><span class="built_in">append</span>(<span class="string">&quot; C++&quot;</span>);               <span class="comment">// 使用 append() 进行拼接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取长度</span></span><br><span class="line">string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> length = s.<span class="built_in">length</span>();   <span class="comment">// 获取字符串的长度</span></span><br><span class="line"><span class="type">size_t</span> size = s.<span class="built_in">size</span>();       <span class="comment">// 等价于 length()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符访问</span></span><br><span class="line">string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> c = s[<span class="number">1</span>];    <span class="comment">// 访问字符串中索引为 1 的字符，结果是 &#x27;e&#x27;</span></span><br><span class="line"><span class="type">char</span> c2 = s.<span class="built_in">at</span>(<span class="number">1</span>); <span class="comment">// 等价于 s[1]，但如果索引越界，会抛出异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找字符或子字符串</span></span><br><span class="line">string s = <span class="string">&quot;Hello, C++!&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> pos = s.<span class="built_in">find</span>(<span class="string">&quot;C++&quot;</span>);  <span class="comment">// 返回第一次出现 &quot;C++&quot; 的位置，如果没找到返回string::npos</span></span><br><span class="line"><span class="keyword">if</span> (pos != string::npos) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Found at position &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换字符或子字符串</span></span><br><span class="line">string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">7</span>, <span class="number">5</span>, <span class="string">&quot;C++&quot;</span>);  <span class="comment">// 从位置 7 开始替换 5 个字符，替换为 &quot;C++&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除字符</span></span><br><span class="line">string s = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">5</span>, <span class="number">7</span>);  <span class="comment">// 从位置 5 开始，删除 7 个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//子字符串</span></span><br><span class="line">string s = <span class="string">&quot;Hello, C++!&quot;</span>;</span><br><span class="line">string x = <span class="string">&quot;my &quot;</span>;</span><br><span class="line">string sub1 = s.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">3</span>);  <span class="comment">// 获取从位置 7 开始，长度为 3 的子字符串 &quot;C++&quot;</span></span><br><span class="line">string sub2 = s.<span class="built_in">substr</span>(<span class="number">7</span>, <span class="number">3</span>);  <span class="comment">// 获取从位置 7 开始往后的整个子字符串 &quot;C++!&quot;</span></span><br><span class="line">string newString = s.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">7</span>) + x + s.<span class="built_in">substr</span>(<span class="number">7</span>);  <span class="comment">// 将字符串x插入到位置7，形成一个新的字符串&quot;Hello, my C++!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较字符串</span></span><br><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Strings are equal.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Strings are not equal.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br>  </p>
<h2 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h2><p>回文字符串是指正着读和反着读都一样的字符串。换句话说，回文字符串从左到右和从右到左的字符顺序完全相同。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查字符串是否是回文示例（非函数形式）</span></span><br><span class="line"><span class="type">bool</span> is_palindrome = <span class="literal">true</span>; <span class="comment">//先假定其是回文串</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; c.<span class="built_in">length</span>() / <span class="number">2</span>; j++) &#123;</span><br><span class="line">    <span class="comment">// 对称位置字符不相等，不是回文</span></span><br><span class="line">    <span class="keyword">if</span> (c[j] != c[c.<span class="built_in">length</span>() - <span class="number">1</span> - j]) &#123;</span><br><span class="line">        is_palindrome = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">//不执行则is_palindrome 仍为 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查字符串是否是回文示例（函数形式）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = str.<span class="built_in">length</span>() - <span class="number">1</span>; <span class="comment">//双指针</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[left] != str[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果不相等，返回 false</span></span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 全部字符都匹配，返回 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <br><br>  </p>
<h2 id="for循环的另一种用法"><a href="#for循环的另一种用法" class="headerlink" title="for循环的另一种用法"></a>for循环的另一种用法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : s) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个基于范围的 for 循环（C++11 及以上支持），用于遍历字符串s中的每个字符，<code>char ch</code>表示每次循环中获取的字符串元素（单个字符）<br>  <br><br>  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2/" data-id="cmfva0tts000awo961pcoc9vb" data-title="算法笔记(C++) ——字符串" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">九月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">八月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">六月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">算法笔记(C++) ——动态规划</a>
          </li>
        
          <li>
            <a href="/2025/09/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">算法笔记(C++) ——广度优先搜索</a>
          </li>
        
          <li>
            <a href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">算法笔记(C++) ——深度优先搜索</a>
          </li>
        
          <li>
            <a href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/">算法笔记(C++) ——图的存储</a>
          </li>
        
          <li>
            <a href="/2025/08/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88/">算法笔记(C++) ——双指针</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 ShenKeyang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>