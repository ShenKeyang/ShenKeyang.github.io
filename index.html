<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>YOLO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="YOLO的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="YOLO">
<meta property="og:url" content="https://shenkeyang.github.io/index.html">
<meta property="og:site_name" content="YOLO">
<meta property="og:description" content="YOLO的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ShenKeyang">
<meta property="article:tag" content="sky">
<meta property="article:tag" content="shenkeyang">
<meta property="article:tag" content="YOLO">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="YOLO" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">YOLO</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">You Only Live Once.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shenkeyang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-面经笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/28/%E9%9D%A2%E7%BB%8F%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2025-09-28T15:12:50.000Z" itemprop="datePublished">2025-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/28/%E9%9D%A2%E7%BB%8F%E7%AC%94%E8%AE%B0/">面经笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Redis-有哪些数据结构？"><a href="#Redis-有哪些数据结构？" class="headerlink" title="Redis 有哪些数据结构？"></a>Redis 有哪些数据结构？</h2><p>Redis 提供了 5 种基础数据结构，以及基于这些扩展的高级结构：</p>
<ul>
<li>字符串（String）：最基础的键值对，可存储文本、数字（支持自增自减），最大容量 512MB。</li>
<li>哈希（Hash）：键值对的集合，适合存储对象（如用户信息），每个哈希可包含最多 2^32-1 个字段。</li>
<li>列表（List）：有序字符串集合，支持两端插入 &#x2F; 删除，底层是双向链表，适合实现消息队列。</li>
<li>集合（Set）：无序且唯一的字符串集合，支持交集、并集、差集等运算，适合存储标签、共同好友。</li>
<li>有序集合（ZSet&#x2F;Sorted Set）：带分数（score）的有序集合，分数决定排序，适合排行榜、优先级队列。<br>此外还有 Bitmap（位图）、HyperLogLog（基数统计）、Geospatial（地理位置） 等扩展结构。</li>
</ul>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>C++ 因无自动垃圾回收（GC）机制，内存需手动管理（new 分配内存、delete 释放内存），若分配的内存未正确释放，就会导致内存泄漏 —— 这部分内存无法被系统回收，长期积累会耗尽可用内存，引发程序卡顿、崩溃。常见场景包括：使用 new 动态分配对象 &#x2F; 数组后未调用 delete&#x2F;delete[]；函数中动态分配内存后，因提前返回、异常抛出等分支未执行释放逻辑；类的构造函数中分配内存，但析构函数未实现释放（如未重写析构函数或析构函数未调用 delete）；容器（如 vector 存储动态指针）销毁时，仅释放容器本身，未遍历释放指针指向的内存等。<br>解决 C++ 内存泄漏需从 “规范管理” 和 “工具检测” 两方面入手。规范上，优先使用智能指针（std::unique_ptr、std::shared_ptr）自动管理内存，其会在对象生命周期结束时自动调用 delete，避免手动释放遗漏；动态数组建议用 std::vector 等容器替代，减少 new[]&#x2F;delete[] 的直接使用；类中若有动态内存成员，必须在析构函数中实现释放逻辑，且避免浅拷贝。检测上，可借助专业工具（如 Valgrind 的 Memcheck、Visual Studio 的内存诊断工具），这些工具能跟踪内存分配 &#x2F; 释放过程，定位未释放的内存地址、分配位置，帮助快速排查泄漏点。</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针是 C++ 标准库提供的自动内存管理工具，核心作用是替代手动 new&#x2F;delete，通过 “对象生命周期管理” 自动释放动态分配的内存，从源头避免内存泄漏。其本质是 “封装了原始指针的类对象”，利用 C++ 类的析构函数（对象销毁时自动调用）实现内存自动释放，无需开发者手动操作。<br>C++ 标准库中常用的智能指针有三种：std::unique_ptr 是 “独占所有权” 指针，同一时间只能有一个指针指向内存，适合管理无需共享的资源；std::shared_ptr 是 “共享所有权” 指针，通过引用计数跟踪指向内存的指针数量，所有指针都销毁后才释放内存，适合资源共享场景；std::weak_ptr 是 “弱引用” 指针，不增加引用计数，仅用于观察 std::shared_ptr 管理的资源，避免循环引用导致的内存泄漏。使用时只需包含 memory 头文件，通过构造函数或 std::make_unique&#x2F;std::make_shared 函数创建，即可像普通指针一样使用，无需手动调用 delete。</p>
<h2 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h2><p>在 C++ 中，指针和引用都是用于间接访问变量的工具，但本质和用法有显著区别：<br>指针是一个变量，它存储另一个变量的内存地址，自身有独立的内存空间。指针可以被赋值为 nullptr（表示空指针），也可以通过 * 运算符解引用访问目标变量，还能通过 &amp; 运算符获取变量地址。指针本身可以被重新赋值，指向不同的变量，例如 int* p &#x3D; &a; p &#x3D; &b; 是合法的。<br>引用是变量的别名，它没有独立的内存空间，必须在定义时初始化且绑定到一个变量，之后无法再绑定到其他变量（从一而终）。引用不存在空引用，也不能通过引用自身修改其绑定的目标，使用时无需解引用，直接操作引用就等同于操作被绑定的变量，例如 int&amp; r &#x3D; a; r &#x3D; 5; 会直接修改 a 的值。<br>简单说，指针是 “指向变量的变量”，灵活但需手动管理；引用是 “变量的别名”，更安全但缺乏指针的灵活性。</p>
<h2 id="缓存穿透、缓存击穿和缓存雪崩"><a href="#缓存穿透、缓存击穿和缓存雪崩" class="headerlink" title="缓存穿透、缓存击穿和缓存雪崩"></a>缓存穿透、缓存击穿和缓存雪崩</h2><ul>
<li>缓存穿透：请求查询不存在的数据（如 ID&#x3D;-1），缓存和数据库都无结果，导致请求一直穿透到数据库。解决：缓存空值（短期有效）；布隆过滤器提前拦截不存在的 key。</li>
<li>缓存击穿：某一个热点 key 过期瞬间，大量请求同时访问该 key，直接穿透到数据库。解决：热点 key 永不过期；互斥锁（如 Redis 的 SETNX）控制并发访问。</li>
<li>缓存雪崩：大量缓存 key 在同一时间过期，或缓存服务宕机，导致所有请求直接冲击数据库，造成数据库崩溃。解决：key 过期时间加随机值避免同时过期；缓存集群部署；降级熔断机制。</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池是管理线程的容器，避免频繁创建 &#x2F; 销毁线程的开销，提高资源利用率。核心思想是复用线程：  </p>
<ul>
<li>初始化时创建一定数量的线程，放入 “线程池”。</li>
<li>任务提交时，从池中取空闲线程执行；无空闲线程则按策略处理（如排队、拒绝）。</li>
<li>任务执行完后，线程不销毁，放回池中等待下一个任务。<br>核心作用：控制并发线程数、降低资源消耗、提高响应速度。</li>
</ul>
<h2 id="线程池哪些参数设置不当会造成-OOM？"><a href="#线程池哪些参数设置不当会造成-OOM？" class="headerlink" title="线程池哪些参数设置不当会造成 OOM？"></a>线程池哪些参数设置不当会造成 OOM？</h2><p>Java 线程池（ThreadPoolExecutor）的以下参数设置不当可能导致 OOM（内存溢出）：  </p>
<ul>
<li>corePoolSize 和 maximumPoolSize：设置过大，导致创建过多线程，占用大量内存。  </li>
<li>workQueue（任务队列）：使用无界队列（如 LinkedBlockingQueue 不指定容量），当任务提交速度远快于处理速度时，队列无限膨胀，耗尽内存。  </li>
<li>任务本身：任务执行时创建大量对象（如大集合），若线程池并发高，可能导致内存占用激增。<br>建议：根据业务场景合理设置队列容量（如用有界队列 ArrayBlockingQueue），控制最大线程数。</li>
</ul>
<h2 id="数据库的四大特性ACID"><a href="#数据库的四大特性ACID" class="headerlink" title="数据库的四大特性ACID"></a>数据库的四大特性ACID</h2><ul>
<li>原子性（Atomicity）：事务是不可分割的最小单位，要么全部执行成功，要么全部失败回滚。例如转账操作中，扣款和收款必须同时完成，若中间出错则恢复到初始状态，避免资金不一致。</li>
<li>一致性（Consistency）：事务执行前后，数据库从一个合法状态转换到另一个合法状态，满足预设的业务规则。比如转账后双方账户总金额不变，库存不会出现负数等。</li>
<li>隔离性（Isolation）：多个并发事务同时执行时，彼此的操作互不干扰，仿佛各自独立运行。数据库通过隔离级别（如读未提交、读已提交、可重复读、串行化）控制隔离程度，平衡并发效率和数据正确性。</li>
<li>持久性（Durability）：事务一旦提交，其修改会永久保存到数据库中，即使系统崩溃也不会丢失。通常通过事务日志（如 redo log）实现，确保数据在提交后能被持久化存储。</li>
</ul>
<h2 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h2><p>数据库的隔离级别用于控制多个并发事务之间的相互影响，平衡并发效率与数据一致性，SQL 标准定义了 4 种基础隔离级别（由低到高）：</p>
<ul>
<li>读未提交（Read Uncommitted）：事务可读取其他未提交事务的修改。可能导致脏读（读取到未提交的无效数据），但并发性能最高，实际中很少使用。</li>
<li>读已提交（Read Committed）：事务只能读取其他已提交事务的修改，避免脏读，但可能出现不可重复读（同一事务内两次读取同一数据结果不同）。多数数据库默认采用此级别（如 Oracle、SQL Server）。</li>
<li>可重复读（Repeatable Read）：保证同一事务内多次读取同一数据结果一致，避免不可重复读，但可能产生幻读（事务期间新增符合查询条件的记录）。MySQL 默认为此级别，且通过 MVCC 机制进一步避免了幻读。</li>
<li>串行化（Serializable）：最高隔离级别，强制事务串行执行，完全避免脏读、不可重复读和幻读，但并发性能极差，仅适合数据一致性要求极高的场景。<br>隔离级别越高，数据一致性越好，但并发能力越弱，实际应用需根据业务场景选择（如金融场景常用可重复读或串行化，互联网高并发场景常用读已提交）。</li>
</ul>
<h2 id="数据库是怎么保证事务的原子性的？"><a href="#数据库是怎么保证事务的原子性的？" class="headerlink" title="数据库是怎么保证事务的原子性的？"></a>数据库是怎么保证事务的原子性的？</h2><p>数据库通过事务日志（Undo Log + Redo Log）保证原子性：  </p>
<ul>
<li>Undo Log：记录事务执行前的数据状态。若事务失败（如异常），通过 Undo Log 回滚到事务开始前的状态，确保 “要么全做，要么全不做”。  </li>
<li>Redo Log：记录事务执行的修改操作。若数据库崩溃，重启后通过 Redo Log 重新执行未完成的事务，避免数据丢失。<br>例如：银行转账时，若扣款后系统崩溃，Undo Log 会回滚扣款操作，保证原子性。</li>
</ul>
<h2 id="二叉树右视图"><a href="#二叉树右视图" class="headerlink" title="二叉树右视图"></a>二叉树右视图</h2><p>二叉树的右视图是指从右侧观察二叉树时能看到的节点，即每一层最右侧的节点。<br>实现思路：  </p>
<ul>
<li>使用层序遍历（BFS），记录每一层的最后一个节点。</li>
<li>或使用深度优先遍历（DFS），优先访问右子树，确保每层第一个访问的节点是最右侧节点。</li>
</ul>
<h2 id="数据库连接池了解吗"><a href="#数据库连接池了解吗" class="headerlink" title="数据库连接池了解吗"></a>数据库连接池了解吗</h2><p>数据库连接池本质上是一个缓存和管理数据库连接的容器。应用程序启动时，连接池会预先创建一定数量的数据库连接并维护起来。当应用程序需要操作数据库时，它不再是自己新建一个连接，而是从连接池‘借用’一个现成的连接；用完后，也不是真正关<br>闭连接，而是‘归还’给连接池。<br>如果没有连接池，每次数据库请求都要经历一次完整的 TCP 三次握手、数据库认证、连接分配等过程，操作完毕后又要断开连接。这个过程非常耗时耗资源。<br>连接池通过复用连接 避免了频繁的创建和销毁，极大地节约了系统开销，显著提升了应用程序的响应速度 和整体的并发处理能力。同时，它还能统一管理连接资源，防止因程序漏洞导致连接无法关闭而引起的数据库连接耗尽（内存泄漏）。<br>核心参数：  </p>
<ul>
<li>初始连接数 (initialSize): 池启动时创建的初始连接数量。</li>
<li>最大连接数 (maxTotal): 池中能同时存在的最大活动连接数。这取决于数据库和系统的负载能力。</li>
<li>最小空闲连接数 (minIdle): 保证池中至少维持的空闲连接数，用于快速响应请<br>求。</li>
<li>最大空闲连接数 (maxIdle): 防止空闲连接过多浪费资源。</li>
<li>最大等待时间 (maxWaitMillis): 当池中无可用连接时，新的请求等待多长时间，超时则抛出异常。这是防止请求被无限挂起的重要参数。</li>
</ul>
<p>常用连接池：</p>
<ul>
<li>HikariCP: 以其高性能、轻量级 著称，是 Spring Boot 2.x 以后的默认连接池。</li>
<li>Druid (德鲁伊): 阿里开源的产品，功能全面，提供强大的监控和扩展功能，在国内非常流行</li>
</ul>
<h2 id="C-基本数据类型及字节数（32-位-64-位平台通用参考）"><a href="#C-基本数据类型及字节数（32-位-64-位平台通用参考）" class="headerlink" title="C++ 基本数据类型及字节数（32 位 &#x2F; 64 位平台通用参考）"></a>C++ 基本数据类型及字节数（32 位 &#x2F; 64 位平台通用参考）</h2><ul>
<li>布尔型：bool，1 字节</li>
<li>字符型：char（1 字节）、wchar_t（2&#x2F;4 字节，取决于编译器）</li>
<li>整数型：short（2 字节）、int（4 字节）、long（4 字节 &#x2F; 8 字节，32 位平台 4 字节，64 位平台 8 字节）、long long（8 字节）</li>
<li>浮点型：float（4 字节）、double（8 字节）、long double（8&#x2F;16 字节，依平台而定）<br>注：int 与处理器字长相关，long 与操作系统位数相关，具体以编译器和平台为准。</li>
</ul>
<h2 id="不同平台类型字节数差异的原因"><a href="#不同平台类型字节数差异的原因" class="headerlink" title="不同平台类型字节数差异的原因"></a>不同平台类型字节数差异的原因</h2><p>核心是平台架构和编译器实现的差异：  </p>
<ul>
<li>硬件层面：32 位处理器地址总线为 32 位，寄存器宽度 32 位，long 等类型通常适配为 4 字节；64 位处理器则适配为 8 字节以提高效率。</li>
<li>编译器层面：C++ 标准仅规定类型的 “最小字节数” 和 “相对大小”（如 int ≥ short），具体字节数由编译器厂商根据平台特性（如内存对齐、性能优化）决定。  </li>
<li>历史兼容：部分平台为兼容旧代码，保留了传统字节数定义（如某些系统 long 仍为 4 字节）。</li>
</ul>
<h2 id="死锁的产生及必要条件"><a href="#死锁的产生及必要条件" class="headerlink" title="死锁的产生及必要条件"></a>死锁的产生及必要条件</h2><p>产生原因：多线程（或进程）因竞争资源而相互等待，且彼此持有对方所需资源，导致所有线程无法继续执行。<br>四个必要条件（缺一不可）：</p>
<ul>
<li>互斥条件：资源只能被一个线程持有（如独占锁）。</li>
<li>持有并等待：线程持有部分资源，同时等待其他资源。</li>
<li>不可剥夺：资源不能被强制从持有者手中夺走。</li>
<li>循环等待：线程间形成环形等待链（如 A 等 B 的资源，B 等 A 的资源）。</li>
</ul>
<h2 id="规避死锁的方法"><a href="#规避死锁的方法" class="headerlink" title="规避死锁的方法"></a>规避死锁的方法</h2><ul>
<li>破坏循环等待：按固定顺序申请资源（如所有线程均先申请资源 1，再申请资源 2）。</li>
<li>破坏持有并等待：一次性申请所有所需资源，未获取全部则释放已持有的资源。</li>
<li>超时释放：申请资源时设置超时时间，超时则释放已持有资源并重试。</li>
<li>使用 try_lock：尝试获取锁失败时主动释放已持有的锁，避免阻塞。</li>
<li>定期检测：通过算法检测死锁（如资源分配图），发现后主动释放部分资源。</li>
</ul>
<h2 id="超时释放锁是否会导致业务逻辑出错？"><a href="#超时释放锁是否会导致业务逻辑出错？" class="headerlink" title="超时释放锁是否会导致业务逻辑出错？"></a>超时释放锁是否会导致业务逻辑出错？</h2><p>可能会，但可通过设计规避：</p>
<ul>
<li>若超时释放后，原线程仍在执行任务，新线程可能重复执行，导致数据不一致（如重复扣款）。</li>
<li>解决方式：结合 “业务幂等性设计”（确保重复执行结果一致）、“锁标识校验”（任务执行前验证锁是否仍有效）、“超时时间合理设置”（大于业务最大执行时间）。</li>
</ul>
<h2 id="设计简单线程池需考虑的方面"><a href="#设计简单线程池需考虑的方面" class="headerlink" title="设计简单线程池需考虑的方面"></a>设计简单线程池需考虑的方面</h2><ul>
<li>核心参数：核心线程数（常驻线程）、最大线程数（允许的临时线程上限）、任务队列（缓冲待执行任务）、拒绝策略（队列满时如何处理新任务）。</li>
<li>线程管理：线程池中的线程没有任务可执行时进入阻塞状态，直到有新任务到来才被唤醒继续工作，任务队列空且超过空闲时间则销毁临时线程。</li>
<li>同步机制：用互斥锁保护任务队列的读写，条件变量通知线程有新任务。</li>
<li>优雅关闭：停止接收新任务，等待队列中任务执行完毕后销毁所有线程。</li>
</ul>
<h2 id="线程池里的锁的作用"><a href="#线程池里的锁的作用" class="headerlink" title="线程池里的锁的作用"></a>线程池里的锁的作用</h2><ul>
<li>保护任务队列：多个线程（生产者提交任务、消费者线程取任务）并发操作队列时，通过锁保证队列操作的原子性（如避免同时添加 &#x2F; 删除任务导致数据错乱）。  </li>
<li>同步线程状态：结合条件变量，实现线程的阻塞等待（队列空时线程休眠）和唤醒（有新任务时唤醒线程），减少无效轮询。</li>
</ul>
<h2 id="线程-A-B-交替执行，C-最后执行的实现"><a href="#线程-A-B-交替执行，C-最后执行的实现" class="headerlink" title="线程 A&#x2F;B 交替执行，C 最后执行的实现"></a>线程 A&#x2F;B 交替执行，C 最后执行的实现</h2><ul>
<li>用两个互斥锁（lockA、lockB）控制 A 和 B 的交替：<ul>
<li>初始化时 lockA 解锁，lockB 锁定，确保 A 先执行。</li>
<li>A 打印完一个数字后，解锁 lockB 并锁定自己，等待 B 执行。</li>
<li>B 打印完后，解锁 lockA 并锁定自己，循环直至所有数字打印完毕。</li>
</ul>
</li>
<li>用线程 join 确保 C 在 A、B 结束后执行：A 和 B 启动后，主线程调用 A.join() 和 B.join()，再启动 C。</li>
</ul>
<h2 id="红黑树的底层原理"><a href="#红黑树的底层原理" class="headerlink" title="红黑树的底层原理"></a>红黑树的底层原理</h2><p>红黑树是一种自平衡的二叉搜索树（BST），通过维持特定规则保证树的高度始终为 O (log n)，从而确保插入、删除、查找等操作的时间复杂度稳定在 O (log n)。其核心原理是通过颜色规则和旋转操作平衡树结构，避免出现普通 BST 因极端插入顺序导致的 “斜树”（退化为链表）问题。  </p>
<p>红黑树的 5 条核心规则（维持平衡的关键）  </p>
<ul>
<li>节点颜色：每个节点要么是红色，要么是黑色。</li>
<li>根节点：根节点必须是黑色。</li>
<li>叶节点：所有叶子节点（NIL 节点，空节点）都是黑色。</li>
<li>红节点限制：红色节点的两个子节点必须是黑色（即不允许连续两个红色节点）。</li>
<li>路径规则：从任意节点到其所有叶子节点的路径中，包含的黑色节点数量相同（称为 “黑高” 相等）。</li>
</ul>
<p>插入与删除后的平衡调整：<br>当插入或删除节点打破上述规则时，红黑树会通过以下两种操作恢复平衡：</p>
<ol>
<li>变色：修改节点的颜色（红→黑或黑→红），通常用于解决 “连续红节点” 问题。</li>
<li>旋转：通过调整节点的位置关系改变树的结构，分为左旋和右旋，用于调整树的倾斜方向，避免单侧深度过大。</li>
</ol>
<ul>
<li>插入场景：新节点默认设为红色（减少对黑高的影响），若插入后违反规则（如父节点也是红色），则通过 “变色→旋转” 修复（具体步骤取决于叔叔节点的颜色）。</li>
<li>删除场景：删除黑色节点可能破坏 “黑高” 规则，需通过 “兄弟节点调整”“旋转” 等操作恢复，过程比插入更复杂。</li>
</ul>
<p>核心优势：<br>红黑树通过严格的颜色规则和高效的旋转操作，在最坏情况下仍能保持 O (log n) 的高度，兼顾了平衡性能和实现复杂度（相比 AVL 树，旋转操作更少，插入删除效率更高），因此被广泛应用于 C++ STL 的 map&#x2F;set、Linux 内核的进程调度等场景。</p>
<h2 id="一把锁会产生死锁吗"><a href="#一把锁会产生死锁吗" class="headerlink" title="一把锁会产生死锁吗"></a>一把锁会产生死锁吗</h2><p>绝对不会。 这是理解死锁的关键。</p>
<ul>
<li>如果整个系统只有一把锁，那么所有线程都在竞争这同一把锁。</li>
<li>当一个线程持有这把锁时，其他线程会在这把锁上等待。这是一种简单的竞争和串行化，不存在循环等待。</li>
<li>持有锁的线程释放锁后，等待的线程中的一个会成功获取并继续执行。这是正常的同步，不是死锁。</li>
</ul>
<h2 id="OSI-七层模型的分层与功能（从下到上）"><a href="#OSI-七层模型的分层与功能（从下到上）" class="headerlink" title="OSI 七层模型的分层与功能（从下到上）"></a>OSI 七层模型的分层与功能（从下到上）</h2><ol>
<li>物理层（Physical Layer，第 1 层）</li>
</ol>
<ul>
<li>核心功能：负责物理介质上的信号传输，将数据转换为电 &#x2F; 光 &#x2F; 无线电信号（如以太网的电信号、光纤的光信号）；</li>
<li>关键技术：<ul>
<li>物理介质（网线、光纤、无线电波）；</li>
<li>信号编码（如曼彻斯特编码、差分曼彻斯特编码）；</li>
<li>接口标准（如 RJ45 网线接口、USB 接口、光纤 LC 接口）；</li>
<li>传输速率（如 100Mbps、10Gbps）、双工模式（半双工 &#x2F; 全双工）；</li>
</ul>
</li>
<li>典型设备：网卡、网线、光纤、集线器（Hub）、中继器。</li>
</ul>
<ol start="2">
<li>数据链路层（Data Link Layer，第 2 层）</li>
</ol>
<ul>
<li>核心功能：负责相邻设备间的可靠数据传输，解决物理层的 “信号错误” 问题，将物理层的 “信号流” 封装为 “帧（Frame）”；</li>
<li>关键技术：<ul>
<li>帧封装（添加帧头：源 &#x2F; 目的 MAC 地址；帧尾：CRC 校验码）；</li>
<li>MAC 地址（设备的物理地址，如网卡的 6 字节地址，用于局域网内寻址）；</li>
<li>差错控制（CRC 校验，检测帧是否损坏，损坏则要求重发）；</li>
<li>流量控制（避免发送方速度过快导致接收方拥塞）；</li>
<li>介质访问控制（MAC 协议，如以太网的 CSMA&#x2F;CD、无线的 CSMA&#x2F;CA，解决多设备争用物理介质的问题）；</li>
</ul>
</li>
<li>典型设备：交换机（Layer 2 交换机，基于 MAC 地址转发帧）、网桥。</li>
</ul>
<ol start="3">
<li>网络层（Network Layer，第 3 层）</li>
</ol>
<ul>
<li>核心功能：负责跨网络的端到端寻址与路由，解决 “不同局域网间如何通信” 的问题，将数据链路层的 “帧” 封装为 “数据包（Packet）”；</li>
<li>关键技术：<ul>
<li>IP 地址（逻辑地址，如 IPv4 的 32 位地址、IPv6 的 128 位地址，用于跨网络寻址）；</li>
<li>路由选择（通过路由协议如 RIP、OSPF、BGP，选择从源网络到目的网络的最佳路径）；</li>
<li>拥塞控制（检测网络拥塞并调整发送速率，避免数据包丢失）；</li>
<li>分片与重组（当数据包超过物理介质的 MTU（最大传输单元）时，拆分成分片，接收端重组）；</li>
</ul>
</li>
<li>典型设备：路由器（基于 IP 地址转发数据包）、三层交换机。</li>
</ul>
<ol start="4">
<li>传输层（Transport Layer，第 4 层）</li>
</ol>
<ul>
<li>核心功能：负责端到端的可靠数据传输，连接 “应用程序” 与 “网络层”，为上层应用提供 “面向连接” 或 “无连接” 的传输服务，将网络层的 “数据包” 封装为 “段（Segment，TCP）” 或 “数据报（Datagram，UDP）”；</li>
<li>关键技术：<ul>
<li>端口号（如 HTTP 的 80、HTTPS 的 443、SSH 的 22，用于标识主机上的应用程序）；</li>
<li>面向连接（TCP 协议）：三次握手建立连接、四次挥手关闭连接，通过序列号、确认号、重传机制保证可靠性；</li>
<li>无连接（UDP 协议）：无需建立连接，速度快但不可靠，适合实时场景（如视频通话、DNS 查询）；</li>
<li>流量控制（TCP 滑动窗口机制，避免接收方缓冲区溢出）；</li>
<li>拥塞控制（TCP 慢启动、拥塞避免机制，适应网络负载）；</li>
</ul>
</li>
<li>典型协议：TCP（传输控制协议）、UDP（用户数据报协议）。</li>
</ul>
<ol start="5">
<li>会话层（Session Layer，第 5 层）</li>
</ol>
<ul>
<li>核心功能：负责建立、管理和终止应用程序间的 “会话”（如用户登录、文件传输的会话），解决 “应用程序如何维持通信状态” 的问题；</li>
<li>关键技术：<ul>
<li>会话建立（如通过认证机制验证双方身份，建立会话标识）；</li>
<li>会话管理（维持会话状态，如断点续传时记录传输进度）；</li>
<li>会话终止（正常关闭会话或异常中断后的资源释放）；</li>
</ul>
</li>
<li>典型场景：FTP 的文件传输会话、Telnet 的远程登录会话、数据库连接会话。</li>
</ul>
<ol start="6">
<li>表示层（Presentation Layer，第 6 层）<br>-核心功能：负责数据的 “格式转换” 与 “安全处理”，确保发送方的应用数据能被接收方的应用程序正确解析；</li>
</ol>
<ul>
<li>关键技术：<ul>
<li>数据编码（如 ASCII、UTF-8、Unicode，统一字符编码格式）；</li>
<li>数据压缩（如 ZIP、GZIP，减少数据传输量）；</li>
<li>数据加密（如 TLS&#x2F;SSL 的加密、SM4 国密算法，保护数据机密性）；</li>
<li>格式转换（如将二进制数据转换为 XML&#x2F;JSON 格式，或不同应用的自定义数据格式转换）；</li>
</ul>
</li>
<li>典型场景：HTTPS 的 TLS 加密（表示层 + 传输层结合）、文件压缩传输、跨平台数据格式适配。</li>
</ul>
<ol start="7">
<li>应用层（Application Layer，第 7 层）</li>
</ol>
<ul>
<li>核心功能：直接为应用程序提供网络服务，是用户与网络的 “接口”，定义应用程序间通信的协议规范；</li>
<li>关键协议：<ul>
<li>HTTP&#x2F;HTTPS（网页浏览、API 通信）；</li>
<li>FTP（文件传输）、SMTP&#x2F;POP3&#x2F;IMAP（电子邮件）；</li>
<li>DNS（域名解析，将域名转换为 IP 地址）；</li>
<li>Telnet&#x2F;SSH（远程登录）、SNMP（网络设备管理）；</li>
</ul>
</li>
<li>典型应用：浏览器（Chrome、Edge）、邮件客户端（Outlook）、文件传输工具（FileZilla）。</li>
</ul>
<h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><ol>
<li>连接方式：TCP 是面向连接的，传输前需通过 “三次握手” 建立连接，结束后需 “四次挥手” 释放连接；UDP 是无连接的，直接封装数据发送，无需建立 &#x2F; 释放连接。</li>
<li>可靠性：TCP 能保证数据不丢失、不重复、按序到达，靠确认机制（ACK）、序号校验、超时重传实现；UDP 不保证可靠性，数据可能丢失或乱序，仅 “尽力传输”。</li>
<li>数据边界：TCP 面向字节流，数据无固定边界，需应用层自行划分；UDP 面向数据报，每个数据报是独立单元，接收方按数据报完整接收。</li>
<li>传输效率：TCP 效率低，因握手、确认、重传等额外开销；UDP 效率高，无多余流程，首部仅 8 字节（TCP 固定 20 字节），适合高速传输。</li>
<li>拥塞控制：TCP 支持拥塞控制（滑动窗口、慢启动等），能根据网络状态调整传输速率，避免网络过载；UDP 无拥塞控制，会持续发送数据，可能加剧网络拥堵。</li>
<li>适用场景：TCP 用于需可靠性的场景（文件传输、网页加载、转账支付）；UDP 用于需实时性的场景（视频通话、语音聊天、游戏数据、DNS 查询）。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/28/%E9%9D%A2%E7%BB%8F%E7%AC%94%E8%AE%B0/" data-id="cmg3x8c2x000f6k96h3hyedup" data-title="面经笔记" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Python-——基本数据类型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2025-09-28T09:49:20.000Z" itemprop="datePublished">2025-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Python ——基本数据类型</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p>
<p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p>
<p>等号（&#x3D;）用来给变量赋值。</p>
<p>等号（&#x3D;）运算符左边是一个变量名,等号（&#x3D;）运算符右边是存储在变量中的值。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">100</span>          <span class="comment"># 整型变量</span></span><br><span class="line">miles   = <span class="number">1000.0</span>       <span class="comment"># 浮点型变量</span></span><br><span class="line">name    = <span class="string">&quot;nowcoder&quot;</span>     <span class="comment"># 字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (counter)</span><br><span class="line"><span class="built_in">print</span> (miles)</span><br><span class="line"><span class="built_in">print</span> (name)</span><br></pre></td></tr></table></figure>
<p>执行以上程序会输出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">1000.0</span><br><span class="line">nowcoder</span><br></pre></td></tr></table></figure>

<h2 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h2><p>Python允许你同时为多个变量赋值。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。</p>
<p>也可以为多个对象指定多个变量。例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;nowcoder&quot;</span></span><br></pre></td></tr></table></figure>
<p>以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 “nowcoder” 分配给变量 c。</p>
<h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><p>Python3 中有六个标准的数据类型：</p>
<ul>
<li>Number（数字）</li>
<li>String（字符串）</li>
<li>Tuple（元组）</li>
<li>List（列表）</li>
<li>Set（集合）</li>
<li>Dictionary（字典）</li>
</ul>
<p>Python3 的六个标准数据类型中：</p>
<ul>
<li>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</li>
<li>可变数据（3 个）：List（列表）、Set（集合）、Dictionary（字典）。</li>
</ul>
<h2 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h2><p>Python3 支持 int、float、bool、complex（复数）。</p>
<p>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p>
<p>像大多数语言一样，数值类型的赋值和计算都是很直观的。</p>
<p>内置的 type() 函数可以用来查询变量所指的对象类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j</span><br><span class="line">&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))</span><br><span class="line">&lt;class &#x27;int&#x27;&gt; &lt;class &#x27;float&#x27;&gt; &lt;class &#x27;bool&#x27;&gt; &lt;class &#x27;complex&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>此外还可以用 isinstance 来判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = 111</span><br><span class="line">&gt;&gt;&gt; isinstance(a, int)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>isinstance 和 type 的区别在于：</p>
<ul>
<li>type()不会认为子类是一种父类类型。</li>
<li>isinstance()会认为子类是一种父类类型。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B(A):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; isinstance(A(), A)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(A()) == A</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(B(), A)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(B()) == A</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>当指定一个值时，Number 对象就会被创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 = 1</span><br><span class="line">var2 = 10</span><br></pre></td></tr></table></figure>
<p>也可以使用del语句删除一些对象引用。</p>
<p>del语句的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del var1[,var2[,var3[....,varN]]]</span><br></pre></td></tr></table></figure>
<p>可以通过使用del语句删除单个或多个对象。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del var</span><br><span class="line">del var_a, var_b</span><br></pre></td></tr></table></figure>

<h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;5 + 4  # 加法</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; 4.3 - 2 # 减法</span><br><span class="line">2.3</span><br><span class="line">&gt;&gt;&gt; 3 * 7  # 乘法</span><br><span class="line">21</span><br><span class="line">&gt;&gt;&gt; 2 / 4  # 除法，得到一个浮点数</span><br><span class="line">0.5</span><br><span class="line">&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; 17 % 3 # 取余</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 2 ** 5 # 乘方</span><br><span class="line">32</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li><p>Python可以同时为多个变量赋值，如a, b &#x3D; 1, 2。</p>
</li>
<li><p>一个变量可以通过赋值指向不同类型的对象。</p>
</li>
<li><p>数值的除法包含两个运算符：&#x2F; 返回一个浮点数，&#x2F;&#x2F; 返回一个整数。</p>
</li>
<li><p>在混合计算时，Python会把整型转换成为浮点数。</p>
</li>
</ol>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><p>Python中的字符串用单引号 ‘ 或双引号 “ 括起来，同时使用反斜杠 \ 转义特殊字符。</p>
<p>字符串的截取的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量[头下标:尾下标]</span><br></pre></td></tr></table></figure>
<p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<p>加号 + 是字符串的连接符， 星号 ***** 表示复制当前字符串，紧跟的数字为复制的次数。实例如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;Nowocder&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>)          <span class="comment"># 输出字符串</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])    <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">0</span>])       <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])     <span class="comment"># 输出从第三个开始到第五个的字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span>[<span class="number">2</span>:])      <span class="comment"># 输出从第三个开始的后的所有字符</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span> * <span class="number">2</span>)      <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">str</span> + <span class="string">&quot;TEST&quot;</span>) <span class="comment"># 连接字符串</span></span><br></pre></td></tr></table></figure>
<p>执行以上程序会输出如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Nowcoder</span><br><span class="line">Nowcode</span><br><span class="line">N</span><br><span class="line">wco</span><br><span class="line">wcoder</span><br><span class="line">NowcoderNowcoder</span><br><span class="line">NowcoderTEST</span><br></pre></td></tr></table></figure>
<p>Python 使用反斜杠()转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r，表示原始字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&#x27;Now\ncoder&#x27;)</span><br><span class="line">Now</span><br><span class="line">coder</span><br><span class="line">&gt;&gt;&gt; print(r&#x27;Now\ncoder&#x27;)</span><br><span class="line">Now\ncoder</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>另外，反斜杠()可以作为续行符，表示下一行是上一行的延续。也可以使用 “””…””” 或者 ‘’’…’’’ 跨越多行。</p>
<p>注意，Python 没有单独的字符类型，一个字符就是长度为1的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;word = &#x27;Python&#x27;</span><br><span class="line">&gt;&gt;&gt; print(word[0], word[5])</span><br><span class="line">P n</span><br><span class="line">&gt;&gt;&gt; print(word[-1], word[-6])</span><br><span class="line">n P</span><br></pre></td></tr></table></figure>
<p>与 C 字符串不同的是，Python 字符串不能被改变。向一个索引位置赋值，比如word[0] &#x3D; ‘m’会导致错误。</p>
<p>注意：</p>
<ol>
<li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。</li>
<li>字符串可以用+运算符连接在一起，用*运算符重复。</li>
<li>Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li>
<li>Python中的字符串不能改变。</li>
</ol>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><p>List（列表） 是 Python 中使用最频繁的数据类型。</p>
<p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p>
<p>列表是写在方括号 [] 之间、用逗号分隔开的元素列表。</p>
<p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p>
<p>列表截取的语法格式如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量[头下标:尾下标+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p>
<p>加号 + 是列表连接运算符，星号 ***** 是重复操作。如下实例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [ <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;nowcoder&#x27;</span>, <span class="number">70.2</span> ]</span><br><span class="line">tinylist = [<span class="number">123</span>, <span class="string">&#x27;nowcoder&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>)            <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">0</span>])         <span class="comment"># 输出列表第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">1</span>:<span class="number">3</span>])       <span class="comment"># 从第二个开始输出到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span>[<span class="number">2</span>:])        <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinylist * <span class="number">2</span>)    <span class="comment"># 输出两次列表</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">list</span> + tinylist) <span class="comment"># 连接列表</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;abcd&#x27;, 786, 2.23, &#x27;nowcoder&#x27;, 70.2]</span><br><span class="line">abcd</span><br><span class="line">[786, 2.23]</span><br><span class="line">[2.23, &#x27;nowcoder&#x27;, 70.2]</span><br><span class="line">[123, &#x27;nowcoder&#x27;, 123, &#x27;nowcoder&#x27;]</span><br><span class="line">[&#x27;abcd&#x27;, 786, 2.23, &#x27;nowcoder&#x27;, 70.2, 123, &#x27;nowcoder&#x27;]</span><br></pre></td></tr></table></figure>
<p>与Python字符串不一样的是，列表中的元素是可以改变的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; a[0] = 9</span><br><span class="line">&gt;&gt;&gt; a[2:5] = [13, 14, 15]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[9, 2, 13, 14, 15, 6]</span><br><span class="line">&gt;&gt;&gt; a[2:5] = []   # 将对应的元素值设置为 []</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[9, 2, 6]</span><br></pre></td></tr></table></figure>
<p>List 内置了有很多方法，例如 append()、pop() 等等。</p>
<p>注意：</p>
<ol>
<li>List写在方括号之间，元素用逗号隔开。</li>
<li>和字符串一样，list可以被索引和切片。</li>
<li>List可以使用+操作符进行拼接。</li>
<li>List中的元素是可以改变的。</li>
</ol>
<p>Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串.</p>
<p>如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverseWords</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span></span><br><span class="line">    inputWords = <span class="built_in">input</span>.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 翻转字符串</span></span><br><span class="line">    <span class="comment"># 假设列表 list = [1,2,3,4], </span></span><br><span class="line">    <span class="comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span></span><br><span class="line">    <span class="comment"># inputWords[-1::-1] 有三个参数</span></span><br><span class="line">    <span class="comment"># 第一个参数 -1 表示最后一个元素</span></span><br><span class="line">    <span class="comment"># 第二个参数为空，表示移动到列表末尾</span></span><br><span class="line">    <span class="comment"># 第三个参数为步长，-1 表示逆向</span></span><br><span class="line">    inputWords=inputWords[-<span class="number">1</span>::-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重新组合字符串</span></span><br><span class="line">    output = <span class="string">&#x27; &#x27;</span>.join(inputWords)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">input</span> = <span class="string">&#x27;I like nowcoder&#x27;</span></span><br><span class="line">    rw = reverseWords(<span class="built_in">input</span>)</span><br><span class="line">    <span class="built_in">print</span>(rw)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nowcoder like I</span><br></pre></td></tr></table></figure>

<h2 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h2><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。</p>
<p>元组中的元素类型也可以不相同：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = ( <span class="string">&#x27;abcd&#x27;</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">&#x27;nowcoder&#x27;</span>, <span class="number">70.2</span>  )</span><br><span class="line">tinytuple = (<span class="number">123</span>, <span class="string">&#x27;nowcoder&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>)             <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">0</span>])          <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">1</span>:<span class="number">3</span>])        <span class="comment"># 输出从第二个元素开始到第三个元素</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span>[<span class="number">2</span>:])         <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span> (tinytuple * <span class="number">2</span>)     <span class="comment"># 输出两次元组</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">tuple</span> + tinytuple) <span class="comment"># 连接元组</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;abcd&#x27;, 786, 2.23, &#x27;nowcoder&#x27;, 70.2)</span><br><span class="line">abcd</span><br><span class="line">(786, 2.23)</span><br><span class="line">(2.23, &#x27;nowcoder&#x27;, 70.2)</span><br><span class="line">(123, &#x27;nowcoder&#x27;, 123, &#x27;nowcoder&#x27;)</span><br><span class="line">(&#x27;abcd&#x27;, 786, 2.23, &#x27;nowcoder&#x27;, 70.2, 123, &#x27;nowcoder&#x27;)</span><br></pre></td></tr></table></figure>
<p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。其实，可以把字符串看作一种特殊的元组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;tup = (1, 2, 3, 4, 5, 6)</span><br><span class="line">&gt;&gt;&gt; print(tup[0])</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; print(tup[1:5])</span><br><span class="line">(2, 3, 4, 5)</span><br><span class="line">&gt;&gt;&gt; tup[0] = 11  # 修改元组元素的操作是非法的</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#x27;tuple&#x27; object does not support item assignment</span><br></pre></td></tr></table></figure>
<p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p>
<p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()    # 空元组</span><br><span class="line">tup2 = (20,) # 一个元素，需要在元素后添加逗号</span><br><span class="line">string、list 和 tuple 都属于 sequence（序列）。</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>与字符串一样，元组的元素不能修改。</li>
<li>元组也可以被索引和切片，方法一样。</li>
<li>注意构造包含 0 或 1 个元素的元组的特殊语法规则。</li>
<li>元组也可以使用+操作符进行拼接。</li>
</ol>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p>
<p>基本功能是进行成员关系测试和删除重复元素。</p>
<p>可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
<p>创建格式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parame = &#123;value01,value02,...&#125;</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">set</span>(value)</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">student = &#123;<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jim&#x27;</span>, <span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="string">&#x27;Rose&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(student)   <span class="comment"># 输出集合，重复的元素被自动去掉</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;Rose&#x27;</span> <span class="keyword">in</span> student :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Rose 在集合中&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Rose 不在集合中&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a - b)     <span class="comment"># a 和 b 的差集</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a | b)     <span class="comment"># a 和 b 的并集</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a &amp; b)     <span class="comment"># a 和 b 的交集</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(a ^ b)     <span class="comment"># a 和 b 中不同时存在的元素</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;Mary&#x27;, &#x27;Jim&#x27;, &#x27;Rose&#x27;, &#x27;Jack&#x27;, &#x27;Tom&#x27;&#125;</span><br><span class="line">Rose 在集合中</span><br><span class="line">&#123;&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;r&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&#123;&#x27;b&#x27;, &#x27;d&#x27;, &#x27;r&#x27;&#125;</span><br><span class="line">&#123;&#x27;l&#x27;, &#x27;r&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;z&#x27;, &#x27;m&#x27;, &#x27;b&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">&#123;&#x27;a&#x27;, &#x27;c&#x27;&#125;</span><br><span class="line">&#123;&#x27;l&#x27;, &#x27;r&#x27;, &#x27;z&#x27;, &#x27;m&#x27;, &#x27;b&#x27;, &#x27;d&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h2><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p>
<p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。</p>
<p>键(key)必须使用不可变类型。</p>
<p>在同一个字典中，键(key)必须是唯一的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;1 - 脚本&quot;</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="number">2</span>]     = <span class="string">&quot;2 - 工具&quot;</span></span><br><span class="line"> </span><br><span class="line">tinydict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;coder&#x27;</span>,<span class="string">&#x27;code&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;site&#x27;</span>: <span class="string">&#x27;www.coder.com&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="string">&#x27;one&#x27;</span>])       <span class="comment"># 输出键为 &#x27;one&#x27; 的值</span></span><br><span class="line"><span class="built_in">print</span> (<span class="built_in">dict</span>[<span class="number">2</span>])           <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span> (tinydict)          <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.keys())   <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span> (tinydict.values()) <span class="comment"># 输出所有值</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;name&#x27;: &#x27;coder&#x27;, &#x27;code&#x27;: 1, &#x27;site&#x27;: &#x27;www.coder.com&#x27;&#125;</span><br><span class="line">dict_keys([&#x27;name&#x27;, &#x27;code&#x27;, &#x27;site&#x27;])</span><br><span class="line">dict_values([&#x27;coder&#x27;, 1, &#x27;www.coder.com&#x27;])</span><br></pre></td></tr></table></figure>
<p>构造函数 dict() 可以直接从键值对序列中构建字典如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;dict([(&#x27;coder&#x27;, 1), (&#x27;Google&#x27;, 2), (&#x27;Taobao&#x27;, 3)])</span><br><span class="line">&#123;&#x27;Taobao&#x27;: 3, &#x27;coder&#x27;: 1, &#x27;Google&#x27;: 2&#125;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;</span><br><span class="line">&#123;2: 4, 4: 16, 6: 36&#125;</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; dict(coder=1, Google=2, Taobao=3)</span><br><span class="line">&#123;&#x27;coder&#x27;: 1, &#x27;Google&#x27;: 2, &#x27;Taobao&#x27;: 3&#125;</span><br></pre></td></tr></table></figure>
<p>另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。</p>
<p>注意：</p>
<ol>
<li>字典是一种映射类型，它的元素是键值对。</li>
<li>字典的关键字必须为不可变类型，且不能重复。</li>
<li>创建空字典使用 { }。</li>
</ol>
<h2 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h2><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p>
<p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    函数	                描述</span><br><span class="line">int(x [,base])	        将x转换为一个整数</span><br><span class="line">float(x)	            将x转换到一个浮点数</span><br><span class="line">complex(real [,imag])   创建一个复数</span><br><span class="line">str(x)	                将对象 x 转换为字符串</span><br><span class="line">repr(x)	                将对象 x 转换为表达式字符串</span><br><span class="line">eval(str)	            用来计算在字符串中的有效Python表达式,并返回一个对象</span><br><span class="line">tuple(s)	            将序列 s 转换为一个元组</span><br><span class="line">list(s)	                将序列 s 转换为一个列表</span><br><span class="line">set(s)	                转换为可变集合</span><br><span class="line">dict(d)	                创建一个字典。d 必须是一个 (key, value)元组序列。</span><br><span class="line">frozenset(s)	        转换为不可变集合</span><br><span class="line">chr(x)	                将一个整数转换为一个字符</span><br><span class="line">ord(x)	                将一个字符转换为它的整数值</span><br><span class="line">hex(x)	                将一个整数转换为一个十六进制字符串</span><br><span class="line">oct(x)	                将一个整数转换为一个八进制字符串</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" data-id="cmg3x8c2q00026k96fdl7hakt" data-title="Python ——基本数据类型" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Python-——基础语法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-09-28T09:04:43.000Z" itemprop="datePublished">2025-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Python ——基础语法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp-1252 -*-</span></span><br></pre></td></tr></table></figure>
<p>上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码，对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>第一个字符必须是字母表中字母或下划线 _ 。<br>标识符的其他的部分由字母、数字和下划线组成。<br>标识符对大小写敏感。<br>在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。  </p>
<h2 id="python保留字"><a href="#python保留字" class="headerlink" title="python保留字"></a>python保留字</h2><p>保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import keyword</span><br><span class="line">&gt;&gt;&gt; keyword.kwlist</span><br><span class="line">[&#x27;False&#x27;, &#x27;None&#x27;, &#x27;True&#x27;, &#x27;and&#x27;, &#x27;as&#x27;, &#x27;assert&#x27;, &#x27;break&#x27;, &#x27;class&#x27;, &#x27;continue&#x27;, &#x27;def&#x27;, &#x27;del&#x27;, &#x27;elif&#x27;, &#x27;else&#x27;, &#x27;except&#x27;, &#x27;finally&#x27;, &#x27;for&#x27;, &#x27;from&#x27;, &#x27;global&#x27;, &#x27;if&#x27;, &#x27;import&#x27;, &#x27;in&#x27;, &#x27;is&#x27;, &#x27;lambda&#x27;, &#x27;nonlocal&#x27;, &#x27;not&#x27;, &#x27;or&#x27;, &#x27;pass&#x27;, &#x27;raise&#x27;, &#x27;return&#x27;, &#x27;try&#x27;, &#x27;while&#x27;, &#x27;with&#x27;, &#x27;yield&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Python中单行注释以 # 开头，实例如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个注释</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Hello, Python!&quot;</span>) <span class="comment"># 第二个注释</span></span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Python!</span><br></pre></td></tr></table></figure>
<p>多行注释可以用多个 # 号，还有 ‘’’ 和 “””：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个注释</span></span><br><span class="line"><span class="comment"># 第二个注释</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">第三注释</span></span><br><span class="line"><span class="string">第四注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">第五注释</span></span><br><span class="line"><span class="string">第六注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Hello, Python!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Python!</span><br></pre></td></tr></table></figure>

<h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。</p>
<p>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。实例如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;False&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>以下代码最后一行语句缩进数的空格数不一致，会导致运行错误：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;Answer&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span> (<span class="string">&quot;False&quot;</span>)    <span class="comment"># 缩进不一致，会导致运行错误</span></span><br></pre></td></tr></table></figure>
<p>以上程序由于缩进不一致，执行后会出现类似以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File &quot;test.py&quot;, line 6</span><br><span class="line">    print (&quot;False&quot;)    # 缩进不一致，会导致运行错误</span><br><span class="line">                                      ^</span><br><span class="line">IndentationError: unindent does not match any outer indentation level</span><br></pre></td></tr></table></figure>

<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure>
<p>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠()，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="数字-Number-类型"><a href="#数字-Number-类型" class="headerlink" title="数字(Number)类型"></a>数字(Number)类型</h2><p>python中数字有四种类型：整数、布尔型、浮点数和复数。</p>
<ul>
<li>int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</li>
<li>bool (布尔), 如 True。</li>
<li>float (浮点数), 如 1.23、3E-2</li>
<li>complex (复数), 如 1 + 2j、 1.1 + 2.2j</li>
</ul>
<h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串(String)"></a>字符串(String)</h2><ul>
<li>python中单引号和双引号使用完全相同。</li>
<li>使用三引号(‘’’或”””)可以指定一个多行字符串。</li>
<li>转义符 ‘’</li>
<li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \n” 则\n会显示，并不是换行。</li>
<li>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</li>
<li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li>
<li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li>
<li>Python中的字符串不能改变。</li>
<li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li>
<li>字符串的截取的语法格式如下：变量[头下标:尾下标:步长]</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;字符串&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;这是一个句子。&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一个段落，</span></span><br><span class="line"><span class="string">可以由多行组成&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>实例</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>=<span class="string">&#x27;Nowcoder&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>)                 <span class="comment"># 输出字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>:-<span class="number">1</span>])           <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">0</span>])              <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:<span class="number">5</span>])            <span class="comment"># 输出从第三个开始到第五个的字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>[<span class="number">2</span>:])             <span class="comment"># 输出从第三个开始的后的所有字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> * <span class="number">2</span>)             <span class="comment"># 输出字符串两次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span> + <span class="string">&#x27;你好&#x27;</span>)        <span class="comment"># 连接字符串</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;------------------------------&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello\nowcoder&#x27;</span>)      <span class="comment"># 使用反斜杠(\)+n转义特殊字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;hello\nowcoder&#x27;</span>)     <span class="comment"># 在字符串前面添加一个 r，表示原始字符串，不会发生转义</span></span><br></pre></td></tr></table></figure>
<p>这里的 r 指 raw，即 raw string。<br>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Nowcoder</span><br><span class="line">Nowcode</span><br><span class="line">N</span><br><span class="line">wco</span><br><span class="line">wcoder</span><br><span class="line">NowcoderNowcoder</span><br><span class="line">Nowcoder你好</span><br><span class="line">------------------------------</span><br><span class="line">hello</span><br><span class="line">nowcoder</span><br><span class="line">hello\nowcoder</span><br></pre></td></tr></table></figure>

<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。</p>
<p>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。</p>
<p>空行也是程序代码的一部分。</p>
<h2 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h2><p>执行下面的程序在按回车键后就会等待用户输入：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&quot;\n\n按下 enter 键后退出。&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>以上代码中 ，”\n\n”在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。</p>
<h2 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h2><p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;nowcoder&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>使用脚本执行以上代码，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nowcoder</span><br></pre></td></tr></table></figure>
<p>使用交互式命令行执行，输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys; x = &#x27;nowcoder&#x27;; sys.stdout.write(x + &#x27;\n&#x27;)</span><br><span class="line">nowcoder</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>此处的 9 表示字符数。</p>
<h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p>
<p>我们将首行及后面的代码组称为一个子句(clause)。</p>
<p>如下实例：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression :</span><br><span class="line">   suite</span><br><span class="line"><span class="keyword">elif</span> expression :</span><br><span class="line">   suite</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">   suite</span><br></pre></td></tr></table></figure>

<h2 id="Print-输出"><a href="#Print-输出" class="headerlink" title="Print 输出"></a>Print 输出</h2><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end&#x3D;””：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="string">&quot;a&quot;</span></span><br><span class="line">y=<span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="comment"># 换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x )</span><br><span class="line"><span class="built_in">print</span>( y )</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;---------&#x27;</span>)</span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>( y, end=<span class="string">&quot; &quot;</span> )</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>以上实例执行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">---------</span><br><span class="line">a b</span><br></pre></td></tr></table></figure>

<h2 id="import-与-from…import"><a href="#import-与-from…import" class="headerlink" title="import 与 from…import"></a>import 与 from…import</h2><p>在 python 用 import 或者 from…import 来导入相应的模块。</p>
<p>将整个模块(somemodule)导入，格式为： import somemodule</p>
<p>从某个模块中导入某个函数,格式为： from somemodule import somefunction</p>
<p>从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc</p>
<p>将某个模块中的全部函数导入，格式为： from somemodule import *</p>
<p><strong>导入 sys 模块</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;================Python import mode==========================&#x27;</span>);</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;命令行参数为:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="built_in">print</span> (i)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n python 路径为&#x27;</span>,sys.path)</span><br></pre></td></tr></table></figure>
<p><strong>导入 sys 模块的 argv,path 成员</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv,path  <span class="comment">#  导入特定的成员</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;================python from import===================================&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;path:&#x27;</span>,path) <span class="comment"># 因为已经导入path成员，所以此处引用时不需要加sys.path</span></span><br></pre></td></tr></table></figure>

<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>很多程序可以执行一些操作来查看一些基本信息，Python可以使用-h参数查看各参数帮助信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python -h</span><br><span class="line">usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...</span><br><span class="line">Options and arguments (and corresponding environment variables):</span><br><span class="line">-c cmd : program passed in as string (terminates option list)</span><br><span class="line">-d     : debug output from parser (also PYTHONDEBUG=x)</span><br><span class="line">-E     : ignore environment variables (such as PYTHONPATH)</span><br><span class="line">-h     : print this help message and exit</span><br><span class="line"> </span><br><span class="line">[ etc. ]</span><br></pre></td></tr></table></figure>
<p>我们在使用脚本形式执行 Python 时，可以接收命令行输入的参数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" data-id="cmg3x8c2p00016k96560dfj0b" data-title="Python ——基础语法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——并查集" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="article-date">
  <time class="dt-published" datetime="2025-09-23T08:58:49.000Z" itemprop="datePublished">2025-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86/">算法笔记(C++) ——并查集</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="并查集的概念"><a href="#并查集的概念" class="headerlink" title="并查集的概念"></a>并查集的概念</h2><p>并查集（Union-Find）是一种树型数据结构，它的作用是管理元素所属集合的数据结构，主要支持两种操作：</p>
<ul>
<li>合并（Union）：将两个不同的集合合并成一个集合。</li>
<li>查询（Find）：查询某个元素属于哪个集合。</li>
</ul>
<p>从代码实现来说：  </p>
<ul>
<li>并查集是一个森林，每一棵树是一个集合。</li>
<li>查询是找元素所在树的根节点。</li>
<li>合并是把一个树的根节点成为另一个树的根节点的子节点。</li>
</ul>
<br>



<h2 id="数据结构实现原理："><a href="#数据结构实现原理：" class="headerlink" title="数据结构实现原理："></a>数据结构实现原理：</h2><p>并查集通常使用数组实现：</p>
<ul>
<li>使用一个数组parent来表示每个元素的父节点。每个集合由一个代表（根节点）表示。</li>
<li>如果某个元素的父节点是自身（即parent[i] &#x3D; i），则该元素是集合的代表（根节点）。</li>
</ul>
<p>例如，初始情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">元素：1 2 3 4</span><br><span class="line">父亲：1 2 3 4</span><br></pre></td></tr></table></figure>

<br>



<h2 id="代码结合说明："><a href="#代码结合说明：" class="headerlink" title="代码结合说明："></a>代码结合说明：</h2><ol>
<li>初始化：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始parent数组为：[0, 1, 2, 3, 4,…] (下标0未用，元素1-4为独立集合)<br>2. 查找操作（路径压缩）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>路径压缩的作用：</strong><br>当查找某个节点的根节点时，直接将该节点挂在根节点下面，这样能减少后续查询的复杂度。<br>示例说明：<br>x → y 表示 parent[x] &#x3D; y<br>假设集合结构：1→2→3，此时查询1的根，路径压缩前是1→2→3，路径压缩后变为：<br>1 → 3<br>2 → 3<br>查询效率明显提升。<br>3. 合并操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> xRoot = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> yRoot = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (xRoot != yRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[xRoot] = yRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例说明：<br>假设集合结构：1→1，2→2，3→1，执行union(2,3)后集合变为：<br>1 → 1<br>2 → 1<br>3 → 1  </p>
<br>



<h2 id="并查集的优势和适用场景："><a href="#并查集的优势和适用场景：" class="headerlink" title="并查集的优势和适用场景："></a>并查集的优势和适用场景：</h2><ul>
<li><p>优势：</p>
<ul>
<li>路径压缩优化：在查询(find)过程中，让树的结构更加扁平化，大大提升了查询和合并的效率。</li>
<li>并查集的平均复杂度为O(log2 N)，性能优秀。</li>
</ul>
</li>
<li><p>适用场景：</p>
<ul>
<li>判断两个元素是否属于同一集合或群组（如好友关系、网络连接性等）。</li>
<li>动态计算图中联通块数量。</li>
<li>快速实现“分组”操作，如“好友圈”问题。</li>
</ul>
</li>
</ul>
<p><strong>并查集例题1：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">如题，现在有一个并查集，你需要完成合并和查询操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入格式：</span></span><br><span class="line"><span class="comment">第一行包含两个整数n,m表示共有 n 个元素和 m 个操作。接下来 m 行，每行包含三个整数 zi,xi,yi.</span></span><br><span class="line"><span class="comment">当 zi = 1 时，将 xi 与 yi 所在的集合合并。</span></span><br><span class="line"><span class="comment">当 zi = 2 时，输出 xi 与 yi 是否在同一集合内，是的输出Y，否则输出N。</span></span><br><span class="line"><span class="comment">（1&lt;=N,M&lt;=10^5）</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">输出格式：</span></span><br><span class="line"><span class="comment">对于每一个 zi =2 的操作，都有一行输出，每行包含一个大写字母，为 Y 或者 N 。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找（路径压缩）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y))</span><br><span class="line">    &#123;</span><br><span class="line">        parent[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, z, x, y;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    parent.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; z &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (z == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unionSet</span>(x, y);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y))</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Y\n&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;N\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>并查集例题2：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述</span></span><br><span class="line"><span class="comment">小红想要处理一批图片，将相似的图片分类。他首先对图片的特征采样，得到图片之间的相似度，然后按照以下规则判断</span></span><br><span class="line"><span class="comment">图片是否可以归为一类:</span></span><br><span class="line"><span class="comment">1.相似度&gt;0表示两张图片相似；</span></span><br><span class="line"><span class="comment">2.如果A和B相似，B和C相似，但A和C不相似。那么认为A和C间接相似，可以把ABC归为一类，但不计算AC的相似度；</span></span><br><span class="line"><span class="comment">3.如果A和所有其他图片都不相似，则A自己归为一类，相似度为0。给定一个大小为N×N的矩阵 M 存储任意两张图片的相</span></span><br><span class="line"><span class="comment">  似度，M[i][j]即为第i个图片和第j个图片的相似度，请按照&quot;从大到小&quot;的顺序返回每个相似类中所有图片的相似度之和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">第一行一个数N(1≤N≤900)，代表矩阵M中有N个图片。下面跟着N行，每行有N列数据，空格分隔，代表N个图片之间的相似度。</span></span><br><span class="line"><span class="comment">其中 0≤M[i][j]≤100，输入保证 M[i][j] = M[j][i]；</span></span><br><span class="line"><span class="comment">输入的矩阵分隔符为1个或多个连续空格。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">每个相似类的相似度之和。格式为:一行数字，分隔符为1个空格。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != parent[x])</span><br><span class="line">    &#123;</span><br><span class="line">        parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionSet</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y))</span><br><span class="line">    &#123;</span><br><span class="line">        parent[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    parent.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j]&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">unionSet</span>(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res[<span class="number">905</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 计算每个相似类的相似度之和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j= i ;j&lt;n;j++) <span class="comment">// 矩阵是对称的，只用得到半个矩阵</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j] &amp;&amp; <span class="built_in">find</span>(i)==<span class="built_in">find</span>(j))</span><br><span class="line">            &#123;</span><br><span class="line">                res[<span class="built_in">find</span>(i)]+=map[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(res<span class="number">+1</span>,res+n<span class="number">+1</span>);</span><br><span class="line">    <span class="comment">// 先排序，再倒序输出，遇到0则说明输出结束</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(res[i]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cout &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86/" data-id="cmg3x8c2v000a6k960oe27y5l" data-title="算法笔记(C++) ——并查集" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——贪心" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/" class="article-date">
  <time class="dt-published" datetime="2025-09-23T07:44:25.000Z" itemprop="datePublished">2025-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/">算法笔记(C++) ——贪心</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在解决一些优化问题时，我们通常需要找出最优解（例如：最大化、最小化）。而<code>贪心算法（Greedy Algorithm）</code>是一种常用的求解方法，它的基本思想是：在每一步选择中都采取<code>当前最优的选择</code>，以期得到全局的最优解。  </p>
<p><strong>具体来说，贪心算法有以下特点：</strong></p>
<ol>
<li>局部最优选择：在每个阶段或步骤中，选择当前最优的解决方案，通常是选择那个“最好”的选项。</li>
<li>不考虑全局情况：在每一步的决策中，贪心算法并不考虑未来的步骤，也不关心当前选择对后续的影响。它只专注于当前问题的最优解，而不是全局最优解。</li>
<li>贪心策略的正确性：有时候，贪心算法能给出最优解，但<code>并不是所有的优化问题都能通过贪心算法找到全局最优解</code>。在能通过贪心算法找到最优解的情况下，这种算法非常高效。</li>
</ol>
<p><strong>贪心正确性的证明：</strong></p>
<ol>
<li>交换法（Exchange Argument）：假设在某个最优解中，某些选择的顺序与贪心算法的选择顺序不一致。通过交换这些选择，证明交换后的解并不比原解差，或者至少能得到相同的最优解，从而证明贪心算法能得到全局最优解。</li>
<li>归纳法（Inductive Proof）：在贪心算法中，归纳法常用于证明每一步选择的局部最优性能够导致全局最优解。在归纳步骤中，我们假设贪心算法对于较小规模问题的正确性，然后证明它对较大规模问题也能成立。</li>
</ol>
<p><strong>贪心算法的实现步骤：</strong></p>
<ol>
<li>选择标准：确定每一步选择的标准，即选择当前最优的选项。</li>
<li>选择过程：通过选择当前的最优解，逐步逼近问题的全局最优解。</li>
<li>可行性检查：在选择过程中，要随时检查当前选择是否符合问题的约束条件。</li>
<li>问题的最终解：在所有步骤完成后，得出最终的解。</li>
</ol>
<p><strong>贪心算法例题1：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：有一堆商品，每个商品有一个重量和价值。你有一个背包，背包的最大承重为 C，你需要从商品中选择</span></span><br><span class="line"><span class="comment">一部分商品放入背包，使得总价值最大化。商品可以被分割，即你可以选择一部分商品放入背包。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入格式：</span></span><br><span class="line"><span class="comment">第一行包含两个整数 </span></span><br><span class="line"><span class="comment">n 和 C，分别表示商品的数量和背包的最大承重。(2&lt;=n&lt;=10^5),(1&lt;=C&lt;=10^5)接下来的n行，每行包含 2 个整数，</span></span><br><span class="line"><span class="comment">格式为 (w1,v1),(w2,v2),...,(wn,vn),其中 wi表示商品的重量，vi表示商品的价值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出格式：</span></span><br><span class="line"><span class="comment">输出一个浮点值，表示背包中放入商品后能得到的最大价值。结果保留 2 位小数。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span>&#123; <span class="comment">// 定义结构体存储每件商品的重量、价值、价重比</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">double</span> ratio;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> Item &amp;a, <span class="type">const</span> Item &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// 为后续的依照价重比降序排序作准备</span></span><br><span class="line">    <span class="keyword">return</span> a.ratio &gt; b.ratio;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> c, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; &amp;items)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Item&gt; itemsWithRatio;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> weight = items[i].first;</span><br><span class="line">        <span class="type">int</span> value = items[i].second;</span><br><span class="line">        <span class="type">double</span> ratio = (<span class="type">double</span>)value / weight;</span><br><span class="line">        itemsWithRatio.<span class="built_in">push_back</span>(&#123;weight, value, ratio&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按照价重比降序排序（用到第三个参数，自定义排序办法）</span></span><br><span class="line">    <span class="built_in">sort</span>(itemsWithRatio.<span class="built_in">begin</span>(),itemsWithRatio.<span class="built_in">end</span>(),compare);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> totalValue = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> remainingCapacity = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;item : itemsWithRatio)</span><br><span class="line">    &#123;   <span class="comment">// 贪心：每次选取当前未装入背包的商品中价重比最高的</span></span><br><span class="line">        <span class="keyword">if</span>(remainingCapacity == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (item.weight &lt;= remainingCapacity)</span><br><span class="line">        &#123;   <span class="comment">// 商品能完全放入背包</span></span><br><span class="line">            totalValue += item.value;</span><br><span class="line">            remainingCapacity -= item.weight;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 注意本题中提到“商品可分割”，可以部分放入，到最后背包肯定是满的</span></span><br><span class="line">            totalValue += item.value * ((<span class="type">double</span>)remainingCapacity / item.weight);</span><br><span class="line">            remainingCapacity = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> totalValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">items</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; items[i].first &gt;&gt; items[i].second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> res = <span class="built_in">func</span>(n,c,items);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 依照题目要求格式化输出</span></span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>贪心算法例题2：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目内容：</span></span><br><span class="line"><span class="comment">小塔正在给自己的物品贴标签。她一共有m种不同的标签，每种标签只有一个。 对于第i个物品，如果贴上ai号标签，</span></span><br><span class="line"><span class="comment">那么它的美观值为bi;如果没有贴上ai号标签，则其美观值为ci。小美想知道在合理的分配下，所有物品的美观值之</span></span><br><span class="line"><span class="comment">和最大为多少。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">第一行输入两个整数n和m代表小美的物品个数和标签种类。第二行输入n个整数ai代表每个物品适合的标签种类. 第</span></span><br><span class="line"><span class="comment">三行输入n个整数bi代表每个物品贴上适合的标签后的美观值。第四行输入n个整数ci代表每个物品未贴上适合标签时</span></span><br><span class="line"><span class="comment">的美观值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">在一行上输出一个整数，代表所有物品美观值之和的最大值。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*思路：</span></span><br><span class="line"><span class="comment">1.标签分配：我们首先将物品根据它们适合的标签进行分组，记录每个标签所对应的物品索引。</span></span><br><span class="line"><span class="comment">2.优先选择贴标签：对于每个标签所对应的物品，优先选择能够带来更高美观值的物品贴标签。如果物品不能贴标签，</span></span><br><span class="line"><span class="comment">  就选择不贴标签的美观值。</span></span><br><span class="line"><span class="comment">3.排序策略：每个标签所对应的物品排序时，应该根据 bi - ci（即贴上标签和不贴标签的美观值差）来排序。这样</span></span><br><span class="line"><span class="comment">  可以优先选择那些能够通过贴标签获得更大美观值的物品。*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">greedy</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">idx</span>(m<span class="number">+1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        idx[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll total_value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; lst : idx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (lst.<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sorted_lst = lst;</span><br><span class="line">        <span class="built_in">sort</span>(sorted_lst.<span class="built_in">begin</span>(), sorted_lst.<span class="built_in">end</span>(), [&amp;c, &amp;b](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">                <span class="keyword">return</span> b[x] - c[x] &gt; b[y] - c[y];</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        total_value += <span class="built_in">max</span>(b[sorted_lst[<span class="number">0</span>]], c[sorted_lst[<span class="number">0</span>]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; sorted_lst.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            total_value += c[sorted_lst[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ll res = <span class="built_in">greedy</span>(n, m, a, b, c);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/" data-id="cmg3x8c2x000e6k96cfu067vo" data-title="算法笔记(C++) ——贪心" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——动态规划" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="article-date">
  <time class="dt-published" datetime="2025-09-21T16:03:16.000Z" itemprop="datePublished">2025-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">算法笔记(C++) ——动态规划</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>动态规划（Dynamic Programming，简称 DP）是一种有效的算法设计思想，用于解决具有<code>最优子结构</code>和<code>重叠子问题</code>的复杂问题。其核心思想是通过<code>记录已解决子问题的结果</code>来避免重复计算，从而优化效率。关键在于<code>定义问题的状态和状态转移方程</code>。<br>​以下是一道关于DP的简单例题，并通过集合视角一步步推导状态和转移方程的详细过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">小明正在爬楼梯。楼梯总共有n级台阶，小明每次可以选择爬1级或2级台阶。请问小明爬到第n级台阶的不同方法有多少种。</span><br><span class="line">注意：假设小明从地面（第 0 级台阶）开始爬楼梯，每次可以从当前台阶选择爬1级或2级台阶，直到到达第n级台阶。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">输入一个整数 n（1 ≤ n ≤ 40），表示楼梯的总级数。</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">输出一个整数，表示爬到第 n 级台阶的不同方法数。</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>讨论 n &#x3D; 4 的情况：</strong><br>对于 (n &#x3D; 4)，所有可能的爬楼方式如下(5种)：<ul>
<li>0→1→2→3→4</li>
<li>0→1→2→4</li>
<li>0→1→3→4</li>
<li>0→2→3→4</li>
<li>0→2→4<br>将这些方案的集合定义为 D4 ，那么集合的大小∣D4∣&#x3D;5 就是问题的答案。</li>
</ul>
</li>
<li><strong>情况分类：</strong><br>考虑到达第 4 级楼梯的方式，可以从两种途径到达：<ul>
<li>最后一步从第 3 级到达第 4 级，即 3→4；</li>
<li>最后一步从第 2 级到达第 4 级，即 2→4；<br>根据这两种情况，我们可以将集合 D4 分为两部分:<br><img src="/images/cpp_11_1.png" alt=" "></li>
</ul>
</li>
<li><strong>等价映射：</strong><br>从集合划分可以观察到：  <ul>
<li>将上图中的第一个式子中最后的(4)去掉，得到的方案等价于从(0)到(3)的所有方案，即1式等价于D3；  </li>
<li>将上图中的第二个式子中最后的(4)去掉，得到的方案等价于从(0)到(2)的所有方案，即1式等价于D2；</li>
</ul>
</li>
<li><strong>递推方程:</strong><br>通过上述分析，可以得出递推关系：  <ul>
<li><strong>|D4| &#x3D; |D2| + |D3|</strong></li>
</ul>
</li>
<li><strong>推广情况:</strong><br>我们可以用相同的思路分析任意 (n)：<br>要到达第 n 级楼梯，最后一步只能是从 n−1 或 n−2 到达。因此，所有从 0 到 n 的方案可以表示为：  <ul>
<li><strong>|D_n| &#x3D; |D_n-1| + |D_n-2|</strong><br>这就是爬楼梯问题的<code>核心状态转移方程</code>。</li>
</ul>
</li>
<li><strong>边界条件：</strong><br>在动态规划中，需要明确边界条件来初始化状态转移：<ul>
<li>从 (0) 到 (1) 的方案：只能 0→1，因此：∣D1∣&#x3D;1;</li>
<li>从 (0) 到 (2) 的方案：可以是 0→1→2或0→2，因此：∣D2∣&#x3D;2;</li>
</ul>
</li>
<li><strong>总结：</strong>  <ul>
<li>状态定义：D_n为从第 (0) 级楼梯到第 (n) 级楼梯的所有方案数。</li>
<li>状态转移方程：|D_n| &#x3D; |D_n-1| + |D_n-2|；</li>
<li>边界条件：∣D1∣&#x3D;1 ，∣D2∣&#x3D;2;<br>通过上述递推公式，可以高效地计算任意 (n) 的爬楼方案数。</li>
</ul>
</li>
</ol>
<p><strong>上述例题的代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里第 i 个元素对应第 i+1 级台阶</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; D[n];</span><br><span class="line"></span><br><span class="line">    D[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    D[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        D[i] = D[i<span class="number">-1</span>] + D[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; D[n<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>DP例题2 （二维状态转移）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述</span></span><br><span class="line"><span class="comment">给定一个大小为 n×n 的二维矩阵，计算从起点 (1,1) 到终点 (n,n) 的所有可能路径的数量。</span></span><br><span class="line"><span class="comment">每一步可以向右或向下移动一个格子。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">输入包含一个整数 n，表示矩阵的大小。 1&lt;=n&lt;=17</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">输出一个整数，表示从 (1,1) 到 (n,n) 的路径总数。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*思路：</span></span><br><span class="line"><span class="comment">1.状态定义：dp[i][j]表示从起点 (0,0) 到达位置 (i,j) 的路径总数;</span></span><br><span class="line"><span class="comment">2.状态转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1];</span></span><br><span class="line"><span class="comment">3.边界条件：dp[0][0] = 1 ，dp[i][0] = 1 ，dp[0][j] = 1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果不是起点 (0, 0)，则计算当前点的路径数</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>) dp[i][j]+=dp[i - <span class="number">1</span>][j];<span class="comment">//从上方来（前提不是第一行）</span></span><br><span class="line">            <span class="keyword">if</span> (j&gt;<span class="number">0</span>) dp[i][j]+=dp[i][j - <span class="number">1</span>];<span class="comment">//从左方来（前提不是第一列）</span></span><br><span class="line">            <span class="comment">// 若既不是第一行，也不是第一列，则dp[i][j]=dp[i-1][j]+dp[i][j-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>DP例题3：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目内容：</span></span><br><span class="line"><span class="comment">圣诞节到了，小塔的妈妈准备了很多圣诞礼盒，礼盒大小不同，小塔在玩堆盒子的游戏，妈妈问小塔，怎么堆</span></span><br><span class="line"><span class="comment">盒子使得堆出的高度最高，每个礼盒的大小由长、宽、高表示，堆盒子的时候要求下面的盒子长、宽、高都必</span></span><br><span class="line"><span class="comment">须大于上面的盒子，不包含等于。请你帮助小塔一起堆出最高的一堆礼盒，高度为堆出的礼盒的所有高度的总和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">输入的第一行是礼盒的个数N，接下来输入N行，每行表示每个礼盒的长、宽、高。</span></span><br><span class="line"><span class="comment">礼盒的数量不超过1000个，每个盒子的长、宽、高取值范围为1~10。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">输出一行，输出能堆出盒子的最高高度*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*思路：</span></span><br><span class="line"><span class="comment">1.排序：首先，将所有盒子按照长、宽、高三个维度进行从小到大的排序。由于后面的盒子在长、宽、高方面</span></span><br><span class="line"><span class="comment">  都大于前面的盒子，因此可以确保后一个盒子不会被放在前一个盒子上面，从而简化了问题。</span></span><br><span class="line"><span class="comment">2.动态规划：接下来，使用动态规划来解决问题。定义 dp[i] 表示以第 i 个盒子为底部盒子时，所能达到的</span></span><br><span class="line"><span class="comment">  最大堆叠高度。我们需要考虑所有之前的盒子，如果一个盒子可以放在另一个盒子上面，就更新 dp[i] 的值。</span></span><br><span class="line"><span class="comment">3.结果计算：最终，结果为所有 dp[i] 中的最大值，即为我们能够堆叠的最高高度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l, w, h;</span><br><span class="line">&#125;box[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">    	cin&gt;&gt;box[i].l&gt;&gt;box[i].w&gt;&gt;box[i].h;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长、宽、高的三个优先级进行从小到大的排序</span></span><br><span class="line">    <span class="built_in">sort</span>(box<span class="number">+1</span>, box+n<span class="number">+1</span>, [&amp;](node a, node b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.l!=b.l)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.l&lt;b.l;   </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a.w!=b.w)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[i]表示第i个盒子作为底部时所能达到的最大高度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=box[i].h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (box[i].h &gt; box[j].h &amp;&amp; box[i].l &gt; box[j].l &amp;&amp; box[i].w &gt; box[j].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+box[i].h); <span class="comment">//尝试匹配前面所有的“前最大高度”dp[j]，取最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong><br>如下所示，上述代码中的此部分是一种C++中使用sort函数对一个结构体数组（数组或容器）进行自定义排序，其形式为<code>sort(box+1, box+n+1, lambda);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(box<span class="number">+1</span>, box+n<span class="number">+1</span>, [&amp;](node a, node b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.l!=b.l)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.l&lt;b.l;   </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a.w!=b.w)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<ul>
<li>前两个参数表示对从box[1]到box[n]（左闭右开区间，实际包含box[1]到box[n]）的元素进行排序；</li>
<li>第三个参数是一个 lambda 表达式，定义了排序的比较规则：<ul>
<li>[&amp;]表示按引用捕获外部变量；</li>
<li>参数a和b是node类型的对象，代表要比较的两个元素；</li>
<li>比较逻辑采用优先级排序：先比较 l，l 相等再比较 w ，前两者都相等最后比较 h ；</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" data-id="cmg3x8c2t00076k960zcabqy7" data-title="算法笔记(C++) ——动态规划" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——广度优先搜索" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="article-date">
  <time class="dt-published" datetime="2025-09-20T08:36:45.000Z" itemprop="datePublished">2025-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">算法笔记(C++) ——广度优先搜索</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>广度优先搜索（Breadth-First Search，简称 BFS）是一种图或树的遍历或搜索算法。它从起始节点开始，首先访问所有相邻节点，然后对这些相邻节点的未访问邻居进行同样的操作，逐层向外扩展，直到遍历完所有节点或找到目标节点。BFS的特点就是：层次遍历（按照节点与起始节点的距离逐层遍历）与最短路径（在无权图中，BFS可以找到起始节点到目标节点的最短路径）  </p>
<p><strong>算法步骤：</strong></p>
<ol>
<li>初始化队列：创建一个空队列，用于存储待访问的节点。</li>
<li>起始节点入队：将起始节点入队。</li>
<li>循环以下操作，直到队列为空：<ul>
<li>从队列中出队一个节点作为当前节点，并标记它为已访问。</li>
<li>访问当前节点的所有未被访问的邻居节点：<ul>
<li>将这些邻居节点标记为已访问。</li>
<li>将这些邻居节点入队。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>队列的种类决定了BFS的使用范围，例如普通队列（先进先出）适用于层次遍历，优先队列（大根堆或小根堆）适用于最短路算法。以下先来看普通队列的BFS。</li>
</ul>
<p>如下所示的是一个BFS的简单例子，需要从节点1开始使用BFS标记整个图，我们通过图示来逐步拆解这个过程：  </p>
<ol>
<li>创建一个空的普通队列，把节点1作为起始节点，标记节点1，先让它进入队列。<br><img src="/images/cpp_10_1.png" alt=" ">  </li>
<li>接着开始执行BFS，从队列头部取出节点1，访问节点1的所有未被访问的邻居节点（2，3），然后将节点2和节点3入队，并标记它们。<br><img src="/images/cpp_10_2.png" alt=" ">  </li>
<li>从队列头部取出节点2，标记节点2，访问节点2的所有未被访问的邻居节点（4，5），然后将节点4和节点5入队，并标记它们。<br><img src="/images/cpp_10_3.png" alt=" ">  </li>
<li>重复上述步骤，直到队列为空，退出循环，到这里BFS就执行结束了。<br><img src="/images/cpp_10_4.png" alt=" "></li>
</ol>
<br>





<h2 id="队列queue的使用"><a href="#队列queue的使用" class="headerlink" title="队列queue的使用"></a>队列queue的使用</h2><p>C++ 中的 queue 是一个基于 FIFO（先进先出）原则的容器适配器。它通常用于需要按顺序处理元素的场景。queue 适配器是基于底层容器（通常是 deque 或 list）实现的，它提供了简单的接口来进行数据的插入和删除操作。</p>
<p><strong>基本使用：</strong><br>首先，需要包含头文件queue，然后可以通过以下几种基本操作来使用 queue。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span> <span class="comment">//必要头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的队列</span></span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作：push</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">10</span>);  <span class="comment">// 向队列中添加元素 10</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">20</span>);  <span class="comment">// 向队列中添加元素 20</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">30</span>);  <span class="comment">// 向队列中添加元素 30</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队列大小: &quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看队列的前端元素：front</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;队列头部元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作：pop</span></span><br><span class="line">    q.<span class="built_in">pop</span>();  <span class="comment">// 移除队列中的第一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次查看队列的前端元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;新的队列头部元素: &quot;</span> &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 20</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空：empty</span></span><br><span class="line">    <span class="keyword">if</span> (q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;队列为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;队列不为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用方法：</strong></p>
<ul>
<li>push(value)：将元素添加到队列的末尾。</li>
<li>pop()：移除队列的头部元素。</li>
<li>front()：获取队列的头部元素（但不移除它）。</li>
<li>back()：获取队列的尾部元素（但不移除它）。</li>
<li>size()：返回队列中元素的数量。</li>
<li>empty()：检查队列是否为空。</li>
</ul>
<p><strong>特点与注意事项：</strong></p>
<ul>
<li>queue 是一个容器适配器，只能进行插入和删除操作，不能随机访问元素。</li>
<li>queue 默认使用 deque 作为底层容器，因此具有高效的插入和删除操作，尤其是在队列两端。</li>
<li>不能通过下标访问队列中的元素，因为 queue 是一个先进先出（FIFO）结构。</li>
</ul>
<p><strong>队列实现BFS例题 1：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">给定一个二维矩阵，表示一个迷宫，其中 1 表示墙壁，0 表示可以通行的道路。你有两个点，起点和终点，问是否存在</span></span><br><span class="line"><span class="comment">一条从起点到终点的路径，使得你可以从起点走到终点。你可以上下左右四个方向移动，但不能穿过墙壁，也不能离开迷</span></span><br><span class="line"><span class="comment">宫范围。坐标以行和列表示，均从0开始，左上角坐标是 (0,0) ，右下角坐标是 (n-1,m-1) 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">第一行输入两个整数 n 和 m，表示迷宫的行数和列数(1≤n,m≤100)。</span></span><br><span class="line"><span class="comment">接下来 n 行，每行包含 m 个整数，表示迷宫的地图，其中 0 表示通路，1 表示墙壁。</span></span><br><span class="line"><span class="comment">最后输入两个整数 x_1, y_1 和 x_2, y_2，表示起点和终点的坐标。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">输出一个字符串，若从起点到终点存在路径，输出 &quot;YES&quot;，否则输出 &quot;NO&quot;。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">maze</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; maze[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查起点和终点是否在迷宫范围内，并且不是墙壁</span></span><br><span class="line">    <span class="keyword">if</span>(x1 &lt; <span class="number">0</span> || x1 &gt;= n || y1 &lt; <span class="number">0</span> || y1 &gt;= m || </span><br><span class="line">       x2 &lt; <span class="number">0</span> || x2 &gt;= n || y2 &lt; <span class="number">0</span> || y2 &gt;= m ||</span><br><span class="line">       maze[x1][y1] == <span class="number">1</span> || maze[x2][y2] == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化访问数组</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 定义四个移动方向：左，右，上，下</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用队列进行BFS</span></span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;x1, y1&#125;);</span><br><span class="line">    visited[x1][y1] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; current = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前点是终点，设置 found 为 true 并跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(current.first == x2 &amp;&amp; current.second == y2)</span><br><span class="line">        &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试四个方向移动</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> newX = current.first + dx[i];</span><br><span class="line">            <span class="type">int</span> newY = current.second + dy[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查新位置是否在迷宫范围内，且是通路，且未被访问过</span></span><br><span class="line">            <span class="keyword">if</span>(newX &gt;=<span class="number">0</span> &amp;&amp; newX &lt; n &amp;&amp; newY &gt;=<span class="number">0</span> &amp;&amp; newY &lt; m &amp;&amp;</span><br><span class="line">               maze[newX][newY] == <span class="number">0</span> &amp;&amp; !visited[newX][newY])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;newX, newY&#125;);</span><br><span class="line">                visited[newX][newY] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据是否找到终点输出结果</span></span><br><span class="line">    <span class="keyword">if</span>(found)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>队列实现BFS例题 2：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">给定一个无向图，该图通过邻接表的方式存储。请你使用广度优先搜索（BFS）算法计算该图的连通块数量。</span></span><br><span class="line"><span class="comment">在无向图中，一个连通块是指图中所有节点之间有路径相连的最大子图。你需要输出图中连通块的数量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">第一行包含两个整数 n 和 m（2≤n≤10^4 ，1≤m≤10^5 ），表示图中有 n 个节点和 m 条边。</span></span><br><span class="line"><span class="comment">接下来的 m 行，每行包含两个整数 u 和 v（1≤u,v≤n），表示存在一条从节点 u 到节点 v 的无向边。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">输出一个整数，表示图中连通块的数量。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        adj[u<span class="number">-1</span>].<span class="built_in">push_back</span>(v<span class="number">-1</span>);</span><br><span class="line">        adj[v<span class="number">-1</span>].<span class="built_in">push_back</span>(u<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">bool</span> allvisited = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!allvisited)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            visited[cur]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;adj[cur].<span class="built_in">size</span>();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[adj[cur][i]]!=<span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(adj[cur][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                allvisited=<span class="literal">false</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            allvisited=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>队列实现BFS例题 3：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目内容：</span></span><br><span class="line"><span class="comment">每天早晨，环卫工人需要处理各个小区的生活垃圾，每个小区的生活垃圾由一队坏卫工人负责运送到最近的垃圾回收站</span></span><br><span class="line"><span class="comment">进行处理，求将所有小区垃圾送到垃圾回收站的最小距离和.假设小区和垃圾回收站都在都在一个m行n列的区域矩阵上，</span></span><br><span class="line"><span class="comment">相邻点的距离为1，只能上下左右移动;其中0表示垃圾处理站，1表示小区，2表示空白区域，−1表示障碍区域不可通行。</span></span><br><span class="line"><span class="comment">区域内如果没有小区或者没有垃圾回收站，则最小距离和返回0。</span></span><br><span class="line"><span class="comment">无法到达垃圾回收站的小区不计入本次距离和中。</span></span><br><span class="line"><span class="comment">计算所有小区垃圾送到垃圾回收站的最小距离和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">第一行为两个数字m和n的和，表示区域矩阵的行数和列数，中间使用空格分隔，m和n的范围均为[1,300]。</span></span><br><span class="line"><span class="comment">接下来的m行表示一个m×n的区域矩阵数组，每行的元素间以空格分隔，其中元素取值仅为−1(障碍)、0(垃圾处理站)、</span></span><br><span class="line"><span class="comment">1(小区)、2(空白区域)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">一个整数，表示所计算的最小距离和。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">map</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> hasXiaoqu = <span class="literal">false</span>,hasLajizhan=<span class="literal">false</span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; xiaoqu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="comment">//判断是否有小区和垃圾站并记录小区</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>) hasLajizhan=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j]==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                hasXiaoqu=<span class="literal">true</span>;</span><br><span class="line">                xiaoqu.<span class="built_in">push_back</span>(&#123;i,j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dx=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dy=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!hasLajizhan||!hasXiaoqu)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    queue&lt;pair&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt;&gt; q; <span class="comment">//定义队列，元素为坐标绑定步数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> xq : xiaoqu) <span class="comment">//每个小区各进行一轮BFS</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) <span class="comment">//把上一个小区所遗留的队列清空</span></span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;&#123;xq.first,xq.second&#125;,<span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> step=cur.second; <span class="comment">//步数迭代</span></span><br><span class="line">            visited[cur.first.first][cur.first.second]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(map[cur.first.first][cur.first.second]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res+=step;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> newX = cur.first.first+dx[i];</span><br><span class="line">                <span class="type">int</span> newY = cur.first.second+dy[i];</span><br><span class="line">                <span class="keyword">if</span>(newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> </span><br><span class="line">                    &amp;&amp; newY &lt; n &amp;&amp; map[newX][newY]!=<span class="number">-1</span> </span><br><span class="line">                    &amp;&amp; visited[newX][newY]!=<span class="number">1</span>) <span class="comment">//不越界，不调头，不是墙</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;&#123;newX,newY&#125;,step<span class="number">+1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" data-id="cmg3x8c2w000b6k965buf2izi" data-title="算法笔记(C++) ——广度优先搜索" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——深度优先搜索" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="article-date">
  <time class="dt-published" datetime="2025-09-10T14:06:32.000Z" itemprop="datePublished">2025-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">算法笔记(C++) ——深度优先搜索</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>深度优先搜索(Depth First Search , DFS)是一种用于遍历或搜索图（图可以是树、无向图、有向图等）的算法。它按照深度优先的策略，优先访问当前节点的下一层邻接节点，直到无法继续为止，再回溯到上一层。可以粗略的理解为：DFS就是在图上做特定的递归，DFS⊂递归。  </p>
<h2 id="树的存储和遍历"><a href="#树的存储和遍历" class="headerlink" title="树的存储和遍历"></a>树的存储和遍历</h2><p><strong>树的两种读入方式：</strong></p>
<ol>
<li>边形式:</li>
</ol>
<ul>
<li>存储：这种读入形式将树看成一张图进行读入，本质就是上一篇中的的读入形式，所以可以使用邻接表（记录对应节点的相邻节点信息的表格）直接存储。但特别要注意的是，虽然树在定义上是有向图，但有时读入的数据可能会不符合其定义。例如，树中的一条有向边从节点 1 指向节点 2，但在输入时可能会以 2 1 的形式读入，所以为了能够正确进行遍历，就需要使用无向图的存储方式(也就是对于读入进来的边，正反都存储一遍)。  </li>
<li>遍历:由于存储结构被迫变成了无向图(虽然它本应该是有向图的结构)，那么在递归遍历的时候(或者说在深度优先搜索的过程中)，我们需要注意由于返祖边的存在导致的无限递归（返祖边:假设树里存在一条从节点 1 指向节点 2的有向边1 2。那么1是2的父亲，也是2的祖先。但在实际的存储中又存在从2指向1的边2 1。那么2 1 就是一条返祖边）。<br>解决方法: 增加父亲参数father，禁止由子节点访问父节点。</li>
</ul>
<ol start="2">
<li>父亲数组：</li>
</ol>
<ul>
<li>存储：树中的每个节点都有唯一的父节点，这种唯一性使得我们可以通过数组来存储父节点信息。所以树可以用父亲数组（father[]）来表示树的结构。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：一棵简单的树  </span><br><span class="line"></span><br><span class="line">树的结构：</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">     / \</span><br><span class="line">    4   5</span><br><span class="line"></span><br><span class="line">父亲数组表示：</span><br><span class="line">father[1] = 0  （根节点无父节点，约定为 0）</span><br><span class="line">father[2] = 1  （节点 2 的父亲是 1）</span><br><span class="line">father[3] = 1  （节点 3 的父亲是 1）</span><br><span class="line">father[4] = 3  （节点 4 的父亲是 3）</span><br><span class="line">father[5] = 3  （节点 5 的父亲是 3）</span><br><span class="line"></span><br><span class="line">父亲数组：father = [0, 1, 1, 3, 3]</span><br></pre></td></tr></table></figure>
<p>但由于我们访问的顺序是从父亲到儿子，而父亲数组存储的是每个儿子的父亲。所以我们无法直接利用父亲数组进行DFS。我们还是将父亲数组转化为邻接表进行存储：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adjList[father[i]].<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历：<br>在这种读入形式下，不再存在第一种形式所提及的无限递归问题。可以直接进行遍历。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">sort</span>(adjList[i].<span class="built_in">begin</span>(), adjList[i].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> parent)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	traversalResult.<span class="built_in">push_back</span>(node); <span class="comment">// 访问当前节点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;child : adjList[node]) </span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span>(child != parent) </span><br><span class="line">        &#123; <span class="comment">// 避免回到父节点</span></span><br><span class="line">			<span class="built_in">DFS</span>(child, node); <span class="comment">// 递归访问子节点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong><br><code>vector&lt;int&gt; matrix(MAX);</code>和<code>vector&lt;int&gt; arr[MAX];</code>的区别：<br>在 C++ 中，二者是两种完全不同的定义方式，核心区别在于数据结构的类型和用途：  </p>
<ul>
<li><code>vector&lt;int&gt; tree(MAX);</code><br>本质：定义一个单个 vector<int> 对象，其元素为int类型，并指定其初始大小为 MAX。<br>这个 vector 会预先分配能容纳 MAX 个 int 元素的内存，且每个元素会被默认初始化（int 类型默认值为 0）。<br>用途：需要一个初始大小固定的动态数组时使用，例如需要存储 MAX 个元素的序列。</li>
<li><code>vector&lt;int&gt; tree[MAX];</code><br>本质：定义一个数组，数组的每个元素都是一个 vector<int> 对象。<br>其中 MAX 是数组的大小（必须是编译期常量），表示这个数组包含 MAX 个 vector<int> 容器。<br>用途：通常用于表示邻接表（如树、图的存储），例如 tree[i] 表示第 i 个节点的所有邻接节点。</li>
</ul>
<br>





<h2 id="DFS的核心思想与实现方式"><a href="#DFS的核心思想与实现方式" class="headerlink" title="DFS的核心思想与实现方式"></a>DFS的核心思想与实现方式</h2><p><strong>核心思想：</strong>  </p>
<ul>
<li>DFS 的本质是 “不撞南墙不回头”，其关键在于 “回溯”（Backtracking）—— 当当前路径无法继续探索时，撤销上一步的选择，回到之前的状态并尝试新的可能性。可以用一个生活化的例子理解：假设你走进一个迷宫，面前有 3 条岔路（A、B、C）。DFS 会先选择岔路 A，一直走到尽头（可能是出口，也可能是死胡同）；如果是死胡同，就退回到岔路口，再选择岔路 B，重复探索；最后再探索岔路 C。整个过程中，“退回岔路口” 就是回溯，“走到底” 就是深度优先。</li>
</ul>
<p><strong>实现方式：</strong></p>
<ul>
<li>根据其“走到底”的特性，DFS可以看作是一种特殊的递归算法，同时树又是DFS的典型应用场景。以下是一道运用递归对树的各节点&#x2F;子树进行深度优先搜索的例题：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述：</span></span><br><span class="line"><span class="comment">有一棵有n个节点的树，根节点为1号节点，树的每个节点是红色或者黑色，想知道有多少节点的子树中同时包含红点和黑点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">第一行输入一个整数n表示节点数量</span></span><br><span class="line"><span class="comment">第二行输入一个长度为n的字符串s表示节点的颜色，第i个节点的颜色为si ，若si为&#x27;B&#x27;表示节点的颜色为黑色，若si为&#x27;R&#x27; </span></span><br><span class="line"><span class="comment">则表示节点的颜色为红色。 接下来n−1行，每行输入两个整数 u,v(1≤u,v≤n)表示树上的边.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">输出一个整数表示答案。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义全局变量邻接表、颜色信息向量、结果值</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; colors;</span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 标记当前子树是否包含红色和黑色</span></span><br><span class="line">    <span class="type">bool</span> hasRed = <span class="literal">false</span>, hasBlack = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (colors[node] == <span class="string">&#x27;R&#x27;</span>) hasRed = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> hasBlack = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> neighbor : adj[node]) <span class="comment">//遍历每一个孩子节点，探索每一种可能性（回溯）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (neighbor != parent) <span class="comment">//邻接表是无向的，应确保搜索的是子树而不是父节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">bool</span>&gt; child = <span class="built_in">dfs</span>(neighbor, node);</span><br><span class="line">            <span class="comment">//针对每一个孩子节点，递归调用进行深度优先搜索（DFS）</span></span><br><span class="line">            <span class="keyword">if</span>(child[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                hasRed = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(child[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                hasBlack = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前子树既有红色又有黑色节点，则满足条件</span></span><br><span class="line">    <span class="keyword">if</span> (hasRed &amp;&amp; hasBlack)</span><br><span class="line">    &#123;</span><br><span class="line">        result++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;hasRed, hasBlack&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//根据输入的n对全局变量resize</span></span><br><span class="line">    colors.<span class="built_in">resize</span>(n);</span><br><span class="line">    adj.<span class="built_in">resize</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; colors[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        adj[u<span class="number">-1</span>].<span class="built_in">push_back</span>(v<span class="number">-1</span>); <span class="comment">//由于题目中的根节点是从1开始标号</span></span><br><span class="line">        adj[v<span class="number">-1</span>].<span class="built_in">push_back</span>(u<span class="number">-1</span>); <span class="comment">//故而实际代码中应先-1后再存入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" data-id="cmg3x8c2x000d6k965lzt8g1w" data-title="算法笔记(C++) ——深度优先搜索" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——图的存储" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/" class="article-date">
  <time class="dt-published" datetime="2025-09-10T10:11:36.000Z" itemprop="datePublished">2025-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/">算法笔记(C++) ——图的存储</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul>
<li>稀疏图：边的数量远小于顶点数的平方。  </li>
<li>稠密图：边的数量接近顶点数的平方。  </li>
<li>有向图：边具有方向性。  </li>
<li>无向图：边没有方向，可以视作双向边。  </li>
<li>有权图与无权图：有权图的边具有权值，无权图的边没有权值。</li>
</ul>
<p><br><br></p>
<h2 id="邻接矩阵（Adjacency-Matrix）"><a href="#邻接矩阵（Adjacency-Matrix）" class="headerlink" title="邻接矩阵（Adjacency Matrix）"></a>邻接矩阵（Adjacency Matrix）</h2><p>邻接矩阵用一个二维数组表示图，matrix[i][j] 表示从顶点 i 到 j 的边的信息（例如 1 代表有边，0 代表无边），适用于稠密图。<br><img src="/images/cpp_8_1.png" alt=" ">  </p>
<p><strong>实现：</strong>  </p>
<ol>
<li>建表操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立一张具有n个节点的图，此时这张图没有任何一条边</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjMatrix</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>加边操作<br>有时，一张图的读入通常以给定若干条边u v w 的形式给出，其中u代表这条边的起点,v代表这条边的终点,w代表这条边的权值。如果不含w，则读入的是无权图。<br>对于邻接矩阵而言，需要了解如何对一张图进行加边操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    adjMatrix[u][v] = <span class="number">1</span>;</span><br><span class="line">    adjMatrix[v][u] = <span class="number">1</span>; <span class="comment">// 无向图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>输出邻接矩阵</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        cout &lt;&lt; (adjMatrix[i][j] ? <span class="string">&quot;有边&quot;</span> : <span class="string">&quot;无边&quot;</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h2 id="邻接表（Adjacency-List）"><a href="#邻接表（Adjacency-List）" class="headerlink" title="邻接表（Adjacency List）"></a>邻接表（Adjacency List）</h2><p>对于稀疏图，邻接表是一种更高效的存储方式，只存储实际存在的边，使用数组或 vector 存储每个顶点的邻居列表。<br><img src="/images/cpp_8_1.png" alt=" "> </p>
<p><strong>实现：</strong>  </p>
<ol>
<li>建表操作<br>使用结构体表示边信息，如果是无权图，可以直接使用 vector<int> adjList[n + 1]：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjList</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或定义边的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, weight;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">adjList</span>(n + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>加边操作<br>无向图的加边操作：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    adjList[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">    adjList[v].<span class="built_in">push_back</span>(&#123;u, w&#125;); <span class="comment">// 无向图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>遍历操作<br>遍历邻接表的示例：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; u &lt;&lt; <span class="string">&quot; connects to &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> edge : adjList[u]) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; edge.to &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; edge.weight &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/10/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8/" data-id="cmg3x8c2v00096k965poh8irv" data-title="算法笔记(C++) ——图的存储" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法笔记-C-——双指针" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88/" class="article-date">
  <time class="dt-published" datetime="2025-08-31T13:37:05.000Z" itemprop="datePublished">2025-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88/">算法笔记(C++) ——双指针</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="双指针算法概述"><a href="#双指针算法概述" class="headerlink" title="双指针算法概述:"></a>双指针算法概述:</h2><p>双指针算法（双指针技术）是一种在处理线性数据结构（如数组、链表）时常用的算法策略。它通过同时使用两个指针，以不同的方式遍历数据结构，从而优化时间复杂度或简化问题的解决过程。双指针算法广泛应用于各种经典问题，如数组排序、链表操作、字符串处理等。  </p>
<ul>
<li>双指针的常见类型</li>
</ul>
<ol>
<li><p>快慢指针（快指针与慢指针）:  </p>
<ul>
<li>用途：常用于检测链表中的环、找到链表的中间节点等。</li>
<li>原理：设定两个指针，快指针一次移动两步，慢指针一次移动一步。如果链表中存在环，快指针最终会与慢指针相遇；如果不存在环，快指针会先到达链表末尾。</li>
</ul>
</li>
<li><p>左右指针（双端指针）:  </p>
<ul>
<li>用途：常用于处理有序数组中的问题，如两数之和、三数之和、四数之和等。</li>
<li>原理：设定一个指针指向数组的起始位置，另一个指针指向数组的末尾，根据当前指针对应的值与目标值的关系来移动指针，以缩小搜索范围。</li>
</ul>
</li>
<li><p>滑动窗口:  </p>
<ul>
<li>用途：用于解决字符串或数组中满足特定条件的子串或子数组问题，如最长不重复子串、最小覆盖子串等。</li>
<li>原理：通过维护一个“窗口”区间（左右边界通常由两个指针left和right表示），动态调整窗口的范围来高效地解决问题。窗口扩展：通常通过固定左指针left、右移（枚举）右指针right来扩大窗口，纳入新的元素；窗口收缩：当窗口内不满足条件时，通过固定右指针right、右移左指针left来缩小窗口，排除不需要的元素；动态调整：根据题目要求，动态调整窗口的大小和位置，直到找到满足条件的解。</li>
</ul>
</li>
</ol>
<p><br><br></p>
<h2 id="例题：互相嘲笑的两个人"><a href="#例题：互相嘲笑的两个人" class="headerlink" title="例题：互相嘲笑的两个人"></a>例题：互相嘲笑的两个人</h2><ul>
<li><p>题目描述：<br>小红和小堡正在玩一个游戏，每一关都有一个分数。如果某人某一关分数比上一关高，但另一个人这一关分数比上一关低，那么他就可以嘲笑对方。如果两个人这一关游戏的分数都比上一关多，则增量更多的可以嘲笑对方;如果两个人这一关游戏的分数都比上一关少，则减量更少的可以嘲笑对方。只有当他们的增量相同或者减量相同时，才不会互相嘲笑。<br>例如，假设小红第一关的分数为2，第二关的分数为8;小堡第一关的分数为5，第二关的分数为10，显然小红增加的比小堡多，那么小红就可以嘲笑小堡。<br>现在给定了小红和小堡每一关的分数，你可以选择一段连续的关卡，使得一段关卡中两个人都不会互相嘲笑，问最多可以选择多少个关卡。特别的一段连续关卡中的第一关两人不会互相嘲笑。</p>
</li>
<li><p>输入：</p>
<ul>
<li>第一行输入一个正整数n,代表关卡数。</li>
<li>第二行输入n个整数a_i,代表小红每一关的分数。</li>
<li>第三行输入n个整数b_i,代表小堡每一关的分数。</li>
</ul>
</li>
<li><p>输出：  </p>
<ul>
<li>输出可以选择最多的关卡数。</li>
</ul>
</li>
<li><p>题解代码：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span>,<span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算差分数组</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diff_a</span><span class="params">(n - <span class="number">1</span>)</span>, <span class="title">diff_b</span><span class="params">(n - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        diff_a[i] = a[i + <span class="number">1</span>] - a[i];</span><br><span class="line">        diff_b[i] = b[i + <span class="number">1</span>] - b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m = diff_a.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; m &amp;&amp; diff_a[r] == diff_b[r]) &#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算该区间的长度</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 左指针移动到右指针的位置，开始新的检查</span></span><br><span class="line">        l = r + <span class="number">1</span>;</span><br><span class="line">        r = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/08/31/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88/" data-id="cmg3x8c2s00056k962afu7ilz" data-title="算法笔记(C++) ——双指针" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">九月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">八月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">六月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/09/28/%E9%9D%A2%E7%BB%8F%E7%AC%94%E8%AE%B0/">面经笔记</a>
          </li>
        
          <li>
            <a href="/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Python ——基本数据类型</a>
          </li>
        
          <li>
            <a href="/2025/09/28/Python-%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">Python ——基础语法</a>
          </li>
        
          <li>
            <a href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86/">算法笔记(C++) ——并查集</a>
          </li>
        
          <li>
            <a href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/">算法笔记(C++) ——贪心</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 ShenKeyang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>