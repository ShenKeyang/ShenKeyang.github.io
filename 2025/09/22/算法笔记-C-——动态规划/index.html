<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>算法笔记(C++) ——动态规划 | YOLO</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="动态规划（Dynamic Programming，简称 DP）是一种有效的算法设计思想，用于解决具有最优子结构和重叠子问题的复杂问题。其核心思想是通过记录已解决子问题的结果来避免重复计算，从而优化效率。关键在于定义问题的状态和状态转移方程。​以下是一道关于DP的简单例题，并通过集合视角一步步推导状态和转移方程的详细过程： 123456789题目描述：小明正在爬楼梯。楼梯总共有n级台阶，小明每次可以">
<meta property="og:type" content="article">
<meta property="og:title" content="算法笔记(C++) ——动态规划">
<meta property="og:url" content="https://shenkeyang.github.io/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.html">
<meta property="og:site_name" content="YOLO">
<meta property="og:description" content="动态规划（Dynamic Programming，简称 DP）是一种有效的算法设计思想，用于解决具有最优子结构和重叠子问题的复杂问题。其核心思想是通过记录已解决子问题的结果来避免重复计算，从而优化效率。关键在于定义问题的状态和状态转移方程。​以下是一道关于DP的简单例题，并通过集合视角一步步推导状态和转移方程的详细过程： 123456789题目描述：小明正在爬楼梯。楼梯总共有n级台阶，小明每次可以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shenkeyang.github.io/images/cpp_11_1.png">
<meta property="article:published_time" content="2025-09-21T16:03:16.000Z">
<meta property="article:modified_time" content="2025-09-22T15:32:29.830Z">
<meta property="article:author" content="ShenKeyang">
<meta property="article:tag" content="sky">
<meta property="article:tag" content="shenkeyang">
<meta property="article:tag" content="YOLO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shenkeyang.github.io/images/cpp_11_1.png">
  
    <link rel="alternate" href="/atom.xml" title="YOLO" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">YOLO</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">You Only Live Once.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://shenkeyang.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-算法笔记-C-——动态规划" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="article-date">
  <time class="dt-published" datetime="2025-09-21T16:03:16.000Z" itemprop="datePublished">2025-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      算法笔记(C++) ——动态规划
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>动态规划（Dynamic Programming，简称 DP）是一种有效的算法设计思想，用于解决具有<code>最优子结构</code>和<code>重叠子问题</code>的复杂问题。其核心思想是通过<code>记录已解决子问题的结果</code>来避免重复计算，从而优化效率。关键在于<code>定义问题的状态和状态转移方程</code>。<br>​以下是一道关于DP的简单例题，并通过集合视角一步步推导状态和转移方程的详细过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目描述：</span><br><span class="line">小明正在爬楼梯。楼梯总共有n级台阶，小明每次可以选择爬1级或2级台阶。请问小明爬到第n级台阶的不同方法有多少种。</span><br><span class="line">注意：假设小明从地面（第 0 级台阶）开始爬楼梯，每次可以从当前台阶选择爬1级或2级台阶，直到到达第n级台阶。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">输入一个整数 n（1 ≤ n ≤ 40），表示楼梯的总级数。</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">输出一个整数，表示爬到第 n 级台阶的不同方法数。</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>讨论 n &#x3D; 4 的情况：</strong><br>对于 (n &#x3D; 4)，所有可能的爬楼方式如下(5种)：<ul>
<li>0→1→2→3→4</li>
<li>0→1→2→4</li>
<li>0→1→3→4</li>
<li>0→2→3→4</li>
<li>0→2→4<br>将这些方案的集合定义为 D4 ，那么集合的大小∣D4∣&#x3D;5 就是问题的答案。</li>
</ul>
</li>
<li><strong>情况分类：</strong><br>考虑到达第 4 级楼梯的方式，可以从两种途径到达：<ul>
<li>最后一步从第 3 级到达第 4 级，即 3→4；</li>
<li>最后一步从第 2 级到达第 4 级，即 2→4；<br>根据这两种情况，我们可以将集合 D4 分为两部分:<br><img src="/images/cpp_11_1.png" alt=" "></li>
</ul>
</li>
<li><strong>等价映射：</strong><br>从集合划分可以观察到：  <ul>
<li>将上图中的第一个式子中最后的(4)去掉，得到的方案等价于从(0)到(3)的所有方案，即1式等价于D3；  </li>
<li>将上图中的第二个式子中最后的(4)去掉，得到的方案等价于从(0)到(2)的所有方案，即1式等价于D2；</li>
</ul>
</li>
<li><strong>递推方程:</strong><br>通过上述分析，可以得出递推关系：  <ul>
<li><strong>|D4| &#x3D; |D2| + |D3|</strong></li>
</ul>
</li>
<li><strong>推广情况:</strong><br>我们可以用相同的思路分析任意 (n)：<br>要到达第 n 级楼梯，最后一步只能是从 n−1 或 n−2 到达。因此，所有从 0 到 n 的方案可以表示为：  <ul>
<li><strong>|D_n| &#x3D; |D_n-1| + |D_n-2|</strong><br>这就是爬楼梯问题的<code>核心状态转移方程</code>。</li>
</ul>
</li>
<li><strong>边界条件：</strong><br>在动态规划中，需要明确边界条件来初始化状态转移：<ul>
<li>从 (0) 到 (1) 的方案：只能 0→1，因此：∣D1∣&#x3D;1;</li>
<li>从 (0) 到 (2) 的方案：可以是 0→1→2或0→2，因此：∣D2∣&#x3D;2;</li>
</ul>
</li>
<li><strong>总结：</strong>  <ul>
<li>状态定义：D_n为从第 (0) 级楼梯到第 (n) 级楼梯的所有方案数。</li>
<li>状态转移方程：|D_n| &#x3D; |D_n-1| + |D_n-2|；</li>
<li>边界条件：∣D1∣&#x3D;1 ，∣D2∣&#x3D;2;<br>通过上述递推公式，可以高效地计算任意 (n) 的爬楼方案数。</li>
</ul>
</li>
</ol>
<p><strong>上述例题的代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里第 i 个元素对应第 i+1 级台阶</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; D[n];</span><br><span class="line"></span><br><span class="line">    D[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    D[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        D[i] = D[i<span class="number">-1</span>] + D[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; D[n<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>DP例题2 （二维状态转移）：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目描述</span></span><br><span class="line"><span class="comment">给定一个大小为 n×n 的二维矩阵，计算从起点 (1,1) 到终点 (n,n) 的所有可能路径的数量。</span></span><br><span class="line"><span class="comment">每一步可以向右或向下移动一个格子。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入：</span></span><br><span class="line"><span class="comment">输入包含一个整数 n，表示矩阵的大小。 1&lt;=n&lt;=17</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">输出一个整数，表示从 (1,1) 到 (n,n) 的路径总数。*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*思路：</span></span><br><span class="line"><span class="comment">1.状态定义：dp[i][j]表示从起点 (0,0) 到达位置 (i,j) 的路径总数;</span></span><br><span class="line"><span class="comment">2.状态转移方程：dp[i][j] = dp[i-1][j] + dp[i][j-1];</span></span><br><span class="line"><span class="comment">3.边界条件：dp[0][0] = 1 ，dp[i][0] = 1 ，dp[0][j] = 1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果不是起点 (0, 0)，则计算当前点的路径数</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>) dp[i][j]+=dp[i - <span class="number">1</span>][j];<span class="comment">//从上方来（前提不是第一行）</span></span><br><span class="line">            <span class="keyword">if</span> (j&gt;<span class="number">0</span>) dp[i][j]+=dp[i][j - <span class="number">1</span>];<span class="comment">//从左方来（前提不是第一列）</span></span><br><span class="line">            <span class="comment">// 若既不是第一行，也不是第一列，则dp[i][j]=dp[i-1][j]+dp[i][j-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[n - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>

<p><strong>DP例题3：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*题目内容：</span></span><br><span class="line"><span class="comment">圣诞节到了，小塔的妈妈准备了很多圣诞礼盒，礼盒大小不同，小塔在玩堆盒子的游戏，妈妈问小塔，怎么堆</span></span><br><span class="line"><span class="comment">盒子使得堆出的高度最高，每个礼盒的大小由长、宽、高表示，堆盒子的时候要求下面的盒子长、宽、高都必</span></span><br><span class="line"><span class="comment">须大于上面的盒子，不包含等于。请你帮助小塔一起堆出最高的一堆礼盒，高度为堆出的礼盒的所有高度的总和。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输入描述：</span></span><br><span class="line"><span class="comment">输入的第一行是礼盒的个数N，接下来输入N行，每行表示每个礼盒的长、宽、高。</span></span><br><span class="line"><span class="comment">礼盒的数量不超过1000个，每个盒子的长、宽、高取值范围为1~10。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出描述：</span></span><br><span class="line"><span class="comment">输出一行，输出能堆出盒子的最高高度*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*思路：</span></span><br><span class="line"><span class="comment">1.排序：首先，将所有盒子按照长、宽、高三个维度进行从小到大的排序。由于后面的盒子在长、宽、高方面</span></span><br><span class="line"><span class="comment">  都大于前面的盒子，因此可以确保后一个盒子不会被放在前一个盒子上面，从而简化了问题。</span></span><br><span class="line"><span class="comment">2.动态规划：接下来，使用动态规划来解决问题。定义 dp[i] 表示以第 i 个盒子为底部盒子时，所能达到的</span></span><br><span class="line"><span class="comment">  最大堆叠高度。我们需要考虑所有之前的盒子，如果一个盒子可以放在另一个盒子上面，就更新 dp[i] 的值。</span></span><br><span class="line"><span class="comment">3.结果计算：最终，结果为所有 dp[i] 中的最大值，即为我们能够堆叠的最高高度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l, w, h;</span><br><span class="line">&#125;box[maxn];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">    	cin&gt;&gt;box[i].l&gt;&gt;box[i].w&gt;&gt;box[i].h;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//长、宽、高的三个优先级进行从小到大的排序</span></span><br><span class="line">    <span class="built_in">sort</span>(box<span class="number">+1</span>, box+n<span class="number">+1</span>, [&amp;](node a, node b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.l!=b.l)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.l&lt;b.l;   </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a.w!=b.w)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[i]表示第i个盒子作为底部时所能达到的最大高度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=box[i].h;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (box[i].h &gt; box[j].h &amp;&amp; box[i].l &gt; box[j].l &amp;&amp; box[i].w &gt; box[j].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=<span class="built_in">max</span>(dp[i],dp[j]+box[i].h); <span class="comment">//尝试匹配前面所有的“前最大高度”dp[j]，取最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong><br>如下所示，上述代码中的此部分是一种C++中使用sort函数对一个结构体数组（数组或容器）进行自定义排序，其形式为<code>sort(box+1, box+n+1, lambda);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(box<span class="number">+1</span>, box+n<span class="number">+1</span>, [&amp;](node a, node b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a.l!=b.l)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.l&lt;b.l;   </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a.w!=b.w)&#123;</span><br><span class="line">			<span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a.h&lt;b.h;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<ul>
<li>前两个参数表示对从box[1]到box[n]（左闭右开区间，实际包含box[1]到box[n]）的元素进行排序；</li>
<li>第三个参数是一个 lambda 表达式，定义了排序的比较规则：<ul>
<li>[&amp;]表示按引用捕获外部变量；</li>
<li>参数a和b是node类型的对象，代表要比较的两个元素；</li>
<li>比较逻辑采用优先级排序：先比较 l，l 相等再比较 w ，前两者都相等最后比较 h ；</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://shenkeyang.github.io/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" data-id="cmg3ip18f0004f8965eihaxen" data-title="算法笔记(C++) ——动态规划" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          算法笔记(C++) ——贪心
        
      </div>
    </a>
  
  
    <a href="/2025/09/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">算法笔记(C++) ——广度优先搜索</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">九月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">八月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">六月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/09/28/Python%E8%AF%AD%E6%B3%95/">Python ——基础语法</a>
          </li>
        
          <li>
            <a href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%B6%E6%9F%A5%E9%9B%86/">算法笔记(C++) ——并查集</a>
          </li>
        
          <li>
            <a href="/2025/09/23/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E8%B4%AA%E5%BF%83/">算法笔记(C++) ——贪心</a>
          </li>
        
          <li>
            <a href="/2025/09/22/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">算法笔记(C++) ——动态规划</a>
          </li>
        
          <li>
            <a href="/2025/09/20/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-C-%E2%80%94%E2%80%94%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">算法笔记(C++) ——广度优先搜索</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 ShenKeyang<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>